From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Be4rJP <bea0224@outlook.jp>
Date: Sun, 12 Dec 2021 20:15:31 +0900
Subject: [PATCH] Add world thread and fix log4j2


diff --git a/build.gradle.kts b/build.gradle.kts
index d27d2c69c2443a03e8dd8705ed2a49a9dcc9fd10..9a1694539d97ecdbce32e8d97d7a1db671387381 100644
--- a/build.gradle.kts
+++ b/build.gradle.kts
@@ -19,6 +19,7 @@ repositories {
         mavenContent { includeModule("net.fabricmc", "mapping-io") }
     }
     // Paper end
+    maven ( "https://jitpack.io" )
 }
 
 dependencies {
@@ -61,6 +62,8 @@ dependencies {
     testImplementation("io.github.classgraph:classgraph:4.8.47") // Paper - mob goal test
     testImplementation("junit:junit:4.13.1")
     testImplementation("org.hamcrest:hamcrest-library:1.3")
+
+    implementation("com.github.Be4rJP:ChiyogamiLib:f5e45239d5")
 }
 
 tasks.jar {
diff --git a/src/main/java/co/aikar/timings/WorldTimingsHandler.java b/src/main/java/co/aikar/timings/WorldTimingsHandler.java
index 8d9ddad1879e7616d980ca70de8aecacaa86db35..5acd559a05cd6e5008b1937c610e05581840331d 100644
--- a/src/main/java/co/aikar/timings/WorldTimingsHandler.java
+++ b/src/main/java/co/aikar/timings/WorldTimingsHandler.java
@@ -72,70 +72,70 @@ public class WorldTimingsHandler {
     public WorldTimingsHandler(Level server) {
         String name = ((PrimaryLevelData) server.getLevelData()).getLevelName() + " - ";
 
-        mobSpawn = Timings.ofSafe(name + "mobSpawn");
-        doChunkUnload = Timings.ofSafe(name + "doChunkUnload");
-        scheduledBlocks = Timings.ofSafe(name + "Scheduled Blocks");
-        scheduledBlocksCleanup = Timings.ofSafe(name + "Scheduled Blocks - Cleanup");
-        scheduledBlocksTicking = Timings.ofSafe(name + "Scheduled Blocks - Ticking");
-        chunkTicks = Timings.ofSafe(name + "Chunk Ticks");
-        lightChunk = Timings.ofSafe(name + "Light Chunk");
-        chunkTicksBlocks = Timings.ofSafe(name + "Chunk Ticks - Blocks");
-        doVillages = Timings.ofSafe(name + "doVillages");
-        doChunkMap = Timings.ofSafe(name + "doChunkMap");
-        doChunkMapUpdate = Timings.ofSafe(name + "doChunkMap - Update");
-        doChunkMapToUpdate = Timings.ofSafe(name + "doChunkMap - To Update");
-        doChunkMapSortMissing = Timings.ofSafe(name + "doChunkMap - Sort Missing");
-        doChunkMapSortSendToPlayers = Timings.ofSafe(name + "doChunkMap - Sort Send To Players");
-        doChunkMapPlayersNeedingChunks = Timings.ofSafe(name + "doChunkMap - Players Needing Chunks");
-        doChunkMapPendingSendToPlayers = Timings.ofSafe(name + "doChunkMap - Pending Send To Players");
-        doChunkMapUnloadChunks = Timings.ofSafe(name + "doChunkMap - Unload Chunks");
-        doSounds = Timings.ofSafe(name + "doSounds");
-        doChunkGC = Timings.ofSafe(name + "doChunkGC");
-        doPortalForcer = Timings.ofSafe(name + "doPortalForcer");
-        entityTick = Timings.ofSafe(name + "entityTick");
-        entityRemoval = Timings.ofSafe(name + "entityRemoval");
-        tileEntityTick = Timings.ofSafe(name + "tileEntityTick");
-        tileEntityPending = Timings.ofSafe(name + "tileEntityPending");
+        mobSpawn = Timings.ofSafeW(name + "mobSpawn");
+        doChunkUnload = Timings.ofSafeW(name + "doChunkUnload");
+        scheduledBlocks = Timings.ofSafeW(name + "Scheduled Blocks");
+        scheduledBlocksCleanup = Timings.ofSafeW(name + "Scheduled Blocks - Cleanup");
+        scheduledBlocksTicking = Timings.ofSafeW(name + "Scheduled Blocks - Ticking");
+        chunkTicks = Timings.ofSafeW(name + "Chunk Ticks");
+        lightChunk = Timings.ofSafeW(name + "Light Chunk");
+        chunkTicksBlocks = Timings.ofSafeW(name + "Chunk Ticks - Blocks");
+        doVillages = Timings.ofSafeW(name + "doVillages");
+        doChunkMap = Timings.ofSafeW(name + "doChunkMap");
+        doChunkMapUpdate = Timings.ofSafeW(name + "doChunkMap - Update");
+        doChunkMapToUpdate = Timings.ofSafeW(name + "doChunkMap - To Update");
+        doChunkMapSortMissing = Timings.ofSafeW(name + "doChunkMap - Sort Missing");
+        doChunkMapSortSendToPlayers = Timings.ofSafeW(name + "doChunkMap - Sort Send To Players");
+        doChunkMapPlayersNeedingChunks = Timings.ofSafeW(name + "doChunkMap - Players Needing Chunks");
+        doChunkMapPendingSendToPlayers = Timings.ofSafeW(name + "doChunkMap - Pending Send To Players");
+        doChunkMapUnloadChunks = Timings.ofSafeW(name + "doChunkMap - Unload Chunks");
+        doSounds = Timings.ofSafeW(name + "doSounds");
+        doChunkGC = Timings.ofSafeW(name + "doChunkGC");
+        doPortalForcer = Timings.ofSafeW(name + "doPortalForcer");
+        entityTick = Timings.ofSafeW(name + "entityTick");
+        entityRemoval = Timings.ofSafeW(name + "entityRemoval");
+        tileEntityTick = Timings.ofSafeW(name + "tileEntityTick");
+        tileEntityPending = Timings.ofSafeW(name + "tileEntityPending");
 
-        chunkLoad = Timings.ofSafe(name + "Chunk Load");
-        chunkLoadPopulate = Timings.ofSafe(name + "Chunk Load - Populate");
-        syncChunkLoad = Timings.ofSafe(name + "Sync Chunk Load");
-        chunkLoadLevelTimer = Timings.ofSafe(name + "Chunk Load - Load Level");
-        chunkIO = Timings.ofSafe(name + "Chunk Load - DiskIO");
-        chunkPostLoad = Timings.ofSafe(name + "Chunk Load - Post Load");
-        worldSave = Timings.ofSafe(name + "World Save");
-        worldSaveLevel = Timings.ofSafe(name + "World Save - Level");
-        worldSaveChunks = Timings.ofSafe(name + "World Save - Chunks");
-        chunkSaveData = Timings.ofSafe(name + "Chunk Save - Data");
+        chunkLoad = Timings.ofSafeW(name + "Chunk Load");
+        chunkLoadPopulate = Timings.ofSafeW(name + "Chunk Load - Populate");
+        syncChunkLoad = Timings.ofSafeW(name + "Sync Chunk Load");
+        chunkLoadLevelTimer = Timings.ofSafeW(name + "Chunk Load - Load Level");
+        chunkIO = Timings.ofSafeW(name + "Chunk Load - DiskIO");
+        chunkPostLoad = Timings.ofSafeW(name + "Chunk Load - Post Load");
+        worldSave = Timings.ofSafeW(name + "World Save");
+        worldSaveLevel = Timings.ofSafeW(name + "World Save - Level");
+        worldSaveChunks = Timings.ofSafeW(name + "World Save - Chunks");
+        chunkSaveData = Timings.ofSafeW(name + "Chunk Save - Data");
 
-        tracker1 = Timings.ofSafe(name + "tracker stage 1");
-        tracker2 = Timings.ofSafe(name + "tracker stage 2");
-        doTick = Timings.ofSafe(name + "doTick");
-        tickEntities = Timings.ofSafe(name + "tickEntities");
+        tracker1 = Timings.ofSafeW(name + "tracker stage 1");
+        tracker2 = Timings.ofSafeW(name + "tracker stage 2");
+        doTick = Timings.ofSafeW(name + "doTick");
+        tickEntities = Timings.ofSafeW(name + "tickEntities");
 
-        chunks = Timings.ofSafe(name + "Chunks");
-        newEntities = Timings.ofSafe(name + "New entity registration");
-        raids = Timings.ofSafe(name + "Raids");
-        chunkProviderTick = Timings.ofSafe(name + "Chunk provider tick");
-        broadcastChunkUpdates = Timings.ofSafe(name + "Broadcast chunk updates");
-        countNaturalMobs = Timings.ofSafe(name + "Count natural mobs");
+        chunks = Timings.ofSafeW(name + "Chunks");
+        newEntities = Timings.ofSafeW(name + "New entity registration");
+        raids = Timings.ofSafeW(name + "Raids");
+        chunkProviderTick = Timings.ofSafeW(name + "Chunk provider tick");
+        broadcastChunkUpdates = Timings.ofSafeW(name + "Broadcast chunk updates");
+        countNaturalMobs = Timings.ofSafeW(name + "Count natural mobs");
 
 
-        miscMobSpawning = Timings.ofSafe(name + "Mob spawning - Misc");
-        playerMobDistanceMapUpdate = Timings.ofSafe(name + "Per Player Mob Spawning - Distance Map Update");
+        miscMobSpawning = Timings.ofSafeW(name + "Mob spawning - Misc");
+        playerMobDistanceMapUpdate = Timings.ofSafeW(name + "Per Player Mob Spawning - Distance Map Update");
 
-        poiUnload = Timings.ofSafe(name + "Chunk unload - POI");
-        chunkUnload = Timings.ofSafe(name + "Chunk unload - Chunk");
-        poiSaveDataSerialization = Timings.ofSafe(name + "Chunk save - POI Data serialization");
-        chunkSave = Timings.ofSafe(name + "Chunk save - Chunk");
-        chunkSaveDataSerialization = Timings.ofSafe(name + "Chunk save - Chunk Data serialization");
-        chunkSaveIOWait = Timings.ofSafe(name + "Chunk save - Chunk IO Wait");
-        chunkUnloadPrepareSave = Timings.ofSafe(name + "Chunk unload - Async Save Prepare");
-        chunkUnloadPOISerialization = Timings.ofSafe(name + "Chunk unload - POI Data Serialization");
-        chunkUnloadDataSave = Timings.ofSafe(name + "Chunk unload - Data Serialization");
+        poiUnload = Timings.ofSafeW(name + "Chunk unload - POI");
+        chunkUnload = Timings.ofSafeW(name + "Chunk unload - Chunk");
+        poiSaveDataSerialization = Timings.ofSafeW(name + "Chunk save - POI Data serialization");
+        chunkSave = Timings.ofSafeW(name + "Chunk save - Chunk");
+        chunkSaveDataSerialization = Timings.ofSafeW(name + "Chunk save - Chunk Data serialization");
+        chunkSaveIOWait = Timings.ofSafeW(name + "Chunk save - Chunk IO Wait");
+        chunkUnloadPrepareSave = Timings.ofSafeW(name + "Chunk unload - Async Save Prepare");
+        chunkUnloadPOISerialization = Timings.ofSafeW(name + "Chunk unload - POI Data Serialization");
+        chunkUnloadDataSave = Timings.ofSafeW(name + "Chunk unload - Data Serialization");
     }
 
     public static Timing getTickList(ServerLevel worldserver, String timingsType) {
-        return Timings.ofSafe(((PrimaryLevelData) worldserver.getLevelData()).getLevelName() + " - Scheduled " + timingsType);
+        return Timings.ofSafeW(((PrimaryLevelData) worldserver.getLevelData()).getLevelName() + " - Scheduled " + timingsType);
     }
 }
diff --git a/src/main/java/io/papermc/paper/util/CachedLists.java b/src/main/java/io/papermc/paper/util/CachedLists.java
index e08f4e39db4ee3fed62e37364d17dcc5c5683504..25eb9fc84edb94e89c3e5fed10be65b464d7eb70 100644
--- a/src/main/java/io/papermc/paper/util/CachedLists.java
+++ b/src/main/java/io/papermc/paper/util/CachedLists.java
@@ -1,57 +1,181 @@
 package io.papermc.paper.util;
 
+import net.minecraft.server.MinecraftServer;
 import net.minecraft.world.entity.Entity;
 import net.minecraft.world.phys.AABB;
 import org.bukkit.Bukkit;
+import org.bukkit.World;
 import org.bukkit.craftbukkit.util.UnsafeList;
+import world.chiyogami.chiyogamilib.WorldThreads;
+
 import java.util.List;
+import java.util.Set;
+import java.util.concurrent.ConcurrentHashMap;
 
 public final class CachedLists {
-
+    
+    private final World world;
+    
+    private final UnsafeList<AABB> TEMP_COLLISION_LIST = new UnsafeList<>(1024);
+    private boolean tempCollisionListInUse;
+    
+    private final UnsafeList<Entity> TEMP_GET_ENTITIES_LIST = new UnsafeList<>(1024);
+    private boolean tempGetEntitiesListInUse;
+    
+    private CachedLists(World world){
+        this.world = world;
+    }
+    
+    
+    
     // Paper start - optimise collisions
-    static final UnsafeList<AABB> TEMP_COLLISION_LIST = new UnsafeList<>(1024);
-    static boolean tempCollisionListInUse;
-
-    public static UnsafeList<AABB> getTempCollisionList() {
-        if (!Bukkit.isPrimaryThread() || tempCollisionListInUse) {
+    static final Set<CachedLists> cashedListSet = ConcurrentHashMap.newKeySet();
+    
+    public static List<AABB> getTempCollisionList(World world) {
+        
+        for(CachedLists cachedLists : cashedListSet){
+            if(world == cachedLists.world){
+                if (!Bukkit.isPrimaryThread() || cachedLists.tempCollisionListInUse) {
+                    return new UnsafeList<>(16);
+                }
+                
+                cachedLists.tempCollisionListInUse = true;
+                return cachedLists.TEMP_COLLISION_LIST;
+            }
+        }
+        
+        CachedLists cachedLists = new CachedLists(world);
+        cachedLists.tempCollisionListInUse = true;
+        cashedListSet.add(cachedLists);
+        return cachedLists.TEMP_COLLISION_LIST;
+    }
+    
+    
+    public static List<AABB> getTempCollisionList() {
+        
+        for(CachedLists cachedLists : cashedListSet){
+            World world = cachedLists.world;
+            Thread thread = WorldThreads.worldThreadMap.get(world);
+            
+            if(Thread.currentThread() == thread && !cachedLists.tempCollisionListInUse){
+                cachedLists.tempCollisionListInUse = true;
+                return cachedLists.TEMP_COLLISION_LIST;
+            }
+        }
+        
+        if (!Bukkit.isPrimaryThread()) {
             return new UnsafeList<>(16);
         }
-        tempCollisionListInUse = true;
-        return TEMP_COLLISION_LIST;
+        
+        UnsafeList<AABB> allList = new UnsafeList<>(1024);
+        for(CachedLists cachedLists : cashedListSet){
+            allList.addAll(cachedLists.TEMP_COLLISION_LIST);
+        }
+        return allList;
     }
-
+    
+    public static void returnTempCollisionList(List<AABB> list, World world) {
+        for(CachedLists cachedLists : cashedListSet){
+            if(world == cachedLists.world){
+                if (cachedLists.TEMP_COLLISION_LIST != list) {
+                    return;
+                }
+                
+                cachedLists.TEMP_COLLISION_LIST.setSize(0);
+                cachedLists.tempCollisionListInUse = false;
+                return;
+            }
+        }
+    }
+    
     public static void returnTempCollisionList(List<AABB> list) {
-        if (list != TEMP_COLLISION_LIST) {
-            return;
+        for(CachedLists cachedLists : cashedListSet){
+            if(cachedLists.TEMP_COLLISION_LIST == list){
+                cachedLists.TEMP_COLLISION_LIST.setSize(0);
+                cachedLists.tempCollisionListInUse = false;
+                return;
+            }
         }
-        ((UnsafeList)list).setSize(0);
-        tempCollisionListInUse = false;
+        
+        ((UnsafeList<?>)list).setSize(0);
     }
-
-    static final UnsafeList<Entity> TEMP_GET_ENTITIES_LIST = new UnsafeList<>(1024);
-    static boolean tempGetEntitiesListInUse;
-
-    public static UnsafeList<Entity> getTempGetEntitiesList() {
-        if (!Bukkit.isPrimaryThread() || tempGetEntitiesListInUse) {
+    
+    
+    public static List<Entity> getTempGetEntitiesList(World world) {
+        for(CachedLists cachedLists : cashedListSet){
+            if(world == cachedLists.world){
+                if (!Bukkit.isPrimaryThread() || cachedLists.tempGetEntitiesListInUse) {
+                    return new UnsafeList<>(16);
+                }
+                
+                cachedLists.tempGetEntitiesListInUse = true;
+                return cachedLists.TEMP_GET_ENTITIES_LIST;
+            }
+        }
+        
+        CachedLists cachedLists = new CachedLists(world);
+        cachedLists.tempGetEntitiesListInUse = true;
+        cashedListSet.add(cachedLists);
+        return cachedLists.TEMP_GET_ENTITIES_LIST;
+    }
+    
+    public static List<Entity> getTempGetEntitiesList() {
+        for(CachedLists cachedLists : cashedListSet){
+            World world = cachedLists.world;
+            Thread thread = WorldThreads.worldThreadMap.get(world);
+            
+            if(Thread.currentThread() == thread && !cachedLists.tempGetEntitiesListInUse){
+                cachedLists.tempGetEntitiesListInUse = true;
+                return cachedLists.TEMP_GET_ENTITIES_LIST;
+            }
+        }
+        
+        if (!Bukkit.isPrimaryThread()) {
             return new UnsafeList<>(16);
         }
-        tempGetEntitiesListInUse = true;
-        return TEMP_GET_ENTITIES_LIST;
+        
+        UnsafeList<Entity> allList = new UnsafeList<>(1024);
+        for(CachedLists cachedLists : cashedListSet){
+            allList.addAll(cachedLists.TEMP_GET_ENTITIES_LIST);
+        }
+        return allList;
     }
-
+    
+    public static void returnTempGetEntitiesList(List<Entity> list, World world) {
+        for(CachedLists cachedLists : cashedListSet){
+            if(world == cachedLists.world){
+                if (cachedLists.TEMP_GET_ENTITIES_LIST != list) {
+                    return;
+                }
+                
+                cachedLists.TEMP_GET_ENTITIES_LIST.setSize(0);
+                cachedLists.tempGetEntitiesListInUse = false;
+                return;
+            }
+        }
+    }
+    
     public static void returnTempGetEntitiesList(List<Entity> list) {
-        if (list != TEMP_GET_ENTITIES_LIST) {
-            return;
+        for(CachedLists cachedLists : cashedListSet){
+            if(cachedLists.TEMP_GET_ENTITIES_LIST == list){
+                cachedLists.TEMP_GET_ENTITIES_LIST.setSize(0);
+                cachedLists.tempGetEntitiesListInUse = false;
+                return;
+            }
         }
-        ((UnsafeList)list).setSize(0);
-        tempGetEntitiesListInUse = false;
+        
+        ((UnsafeList<?>)list).setSize(0);
     }
     // Paper end - optimise collisions
-
+    
     public static void reset() {
         // Paper start - optimise collisions
-        TEMP_COLLISION_LIST.completeReset();
-        TEMP_GET_ENTITIES_LIST.completeReset();
+        //TEMP_COLLISION_LIST.completeReset();
+        for(CachedLists cachedLists : cashedListSet){
+            cachedLists.TEMP_COLLISION_LIST.completeReset();
+            cachedLists.TEMP_GET_ENTITIES_LIST.completeReset();
+        }
+        //TEMP_GET_ENTITIES_LIST.completeReset();
         // Paper end - optimise collisions
     }
 }
diff --git a/src/main/java/net/minecraft/server/MCUtil.java b/src/main/java/net/minecraft/server/MCUtil.java
index b5be0486d1cffe60808948b4b0bfd709664b2ae4..bb7edde6c944f68176cd6fbb5357c95d14fbc780 100644
--- a/src/main/java/net/minecraft/server/MCUtil.java
+++ b/src/main/java/net/minecraft/server/MCUtil.java
@@ -325,7 +325,7 @@ public final class MCUtil {
      * @return
      */
     public static void ensureMain(String reason, Runnable run) {
-        if (AsyncCatcher.enabled && Thread.currentThread() != MinecraftServer.getServer().serverThread) {
+        if (AsyncCatcher.enabled && AsyncCatcher.isAsync()) {
             if (reason != null) {
                 new IllegalStateException("Asynchronous " + reason + "!").printStackTrace();
             }
@@ -350,7 +350,7 @@ public final class MCUtil {
      * @return
      */
     public static <T> T ensureMain(String reason, Supplier<T> run) {
-        if (AsyncCatcher.enabled && Thread.currentThread() != MinecraftServer.getServer().serverThread) {
+        if (AsyncCatcher.enabled && AsyncCatcher.isAsync()) {
             if (reason != null) {
                 new IllegalStateException("Asynchronous " + reason + "! Blocking thread until it returns ").printStackTrace();
             }
diff --git a/src/main/java/net/minecraft/server/MinecraftServer.java b/src/main/java/net/minecraft/server/MinecraftServer.java
index aba3401e447a8d70cdccd9c119a7a64302f25059..a3897c8c4c013a7f30284f2e2f67fcb5de58eeb6 100644
--- a/src/main/java/net/minecraft/server/MinecraftServer.java
+++ b/src/main/java/net/minecraft/server/MinecraftServer.java
@@ -1,5 +1,6 @@
 package net.minecraft.server;
 
+import co.aikar.timings.TimingHandler;
 import com.google.common.base.Splitter;
 import com.google.common.collect.ImmutableList;
 import co.aikar.timings.Timings;
@@ -187,7 +188,12 @@ import org.bukkit.event.server.ServerLoadEvent;
 // CraftBukkit end
 
 import co.aikar.timings.MinecraftTimings; // Paper
+import org.spigotmc.AsyncCatcher;
 import org.spigotmc.SlackActivityAccountant; // Spigot
+import world.chiyogami.chiyogamilib.WorldThreads;
+import world.chiyogami.chiyogamilib.monitor.PerformanceMonitor;
+import world.chiyogami.chiyogamilib.scheduler.WorldThreadRunnable;
+import world.chiyogami.thread.WorldThreadPool;
 
 public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTask> implements SnooperPopulator, CommandSource, AutoCloseable {
 
@@ -361,6 +367,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
 
     public final void executeMidTickTasks() {
         org.spigotmc.AsyncCatcher.catchOp("mid tick chunk task execution");
+        if(Thread.currentThread() != this.serverThread) return;
         long startTime = System.nanoTime();
         if ((startTime - lastMidTickExecute) <= CHUNK_TASK_QUEUE_BACKOFF_MIN_TIME || (startTime - lastMidTickExecuteFailure) <= TASK_EXECUTION_FAILURE_BACKOFF) {
             // it's shown to be bad to constantly hit the queue (chunk loads slow to a crawl), even if no tasks are executed.
@@ -1057,6 +1064,11 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         if (this.getConnection() != null) {
             this.getConnection().stop();
         }
+    
+        try{ // Chiyogami
+            MinecraftServer.LOGGER.info("Stopping WorldThreadPool");
+            WorldThreadPool.shutdown();
+        }catch (Exception e){e.printStackTrace();}
 
         if (this.playerList != null) {
             MinecraftServer.LOGGER.info("Saving players");
@@ -1466,6 +1478,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
     public void onServerExit() {}
 
     public void tickServer(BooleanSupplier shouldKeepTicking) {
+        long fullServerTickNanoTime = System.nanoTime(); // Chiyogami
         co.aikar.timings.TimingsManager.FULL_SERVER_TICK.startTiming(); // Paper
         this.slackActivityAccountant.tickStarted(); // Spigot
         long i = Util.getNanos();
@@ -1560,7 +1573,10 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         org.spigotmc.WatchdogThread.tick(); // Spigot
         this.slackActivityAccountant.tickEnded(l); // Spigot
         co.aikar.timings.TimingsManager.FULL_SERVER_TICK.stopTiming(); // Paper
+        PerformanceMonitor.setFullServerTickNanoTime(System.nanoTime() - fullServerTickNanoTime); // Chiyogami
     }
+    
+    private static BooleanSupplier staticBooleanSupplier = null;
 
     public void tickChildren(BooleanSupplier shouldKeepTicking) {
         MinecraftTimings.bukkitSchedulerTimer.startTiming(); // Spigot // Paper
@@ -1602,16 +1618,31 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         }
         // Paper end
         MinecraftTimings.timeUpdateTimer.stopTiming(); // Spigot // Paper
-
+    
+        staticBooleanSupplier = shouldKeepTicking;
+        long worldServerTickNanoTime = System.nanoTime();
+        
         while (iterator.hasNext()) {
             ServerLevel worldserver = (ServerLevel) iterator.next();
-            worldserver.hasPhysicsEvent =  org.bukkit.event.block.BlockPhysicsEvent.getHandlerList().getRegisteredListeners().length > 0; // Paper
-            worldserver.hasEntityMoveEvent =  io.papermc.paper.event.entity.EntityMoveEvent.getHandlerList().getRegisteredListeners().length > 0; // Paper
-            net.minecraft.world.level.block.entity.HopperBlockEntity.skipHopperEvents = worldserver.paperConfig.disableHopperMoveEvents || org.bukkit.event.inventory.InventoryMoveItemEvent.getHandlerList().getRegisteredListeners().length == 0; // Paper
-
-            this.profiler.push(() -> {
-                return worldserver + " " + worldserver.dimension().location();
-            });
+    
+            WorldThreadPool.worldServers.add(worldserver);
+    
+            WorldThreadPool.tickRunnableMap.computeIfAbsent(worldserver, k -> () -> {
+    
+                WorldThreads.worldThreadMap.put(worldserver.getWorld(), Thread.currentThread());
+    
+                TimingHandler.initializeWorldTiming();
+    
+                long worldServerThreadNanoTime = System.nanoTime();
+    
+                WorldThreadRunnable.worldThreadHeartBeat(worldserver.getWorld(), currentTick); // Chiyogami
+                worldserver.hasPhysicsEvent = org.bukkit.event.block.BlockPhysicsEvent.getHandlerList().getRegisteredListeners().length > 0; // Paper
+                worldserver.hasEntityMoveEvent = io.papermc.paper.event.entity.EntityMoveEvent.getHandlerList().getRegisteredListeners().length > 0; // Paper
+                net.minecraft.world.level.block.entity.HopperBlockEntity.skipHopperEvents = worldserver.paperConfig.disableHopperMoveEvents || org.bukkit.event.inventory.InventoryMoveItemEvent.getHandlerList().getRegisteredListeners().length == 0; // Paper
+    
+                this.profiler.push(() -> {
+                    return worldserver + " " + worldserver.dimension().location();
+                });
             /* Drop global time updates
             if (this.tickCount % 20 == 0) {
                 this.profiler.enter("timeSync");
@@ -1619,37 +1650,47 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
                 this.profiler.exit();
             }
             // CraftBukkit end */
-
-            this.profiler.push("tick");
-
-            try {
-                worldserver.timings.doTick.startTiming(); // Spigot
-                worldserver.tick(shouldKeepTicking);
-                // Paper start
-                for (final io.papermc.paper.chunk.SingleThreadChunkRegionManager regionManager : worldserver.getChunkSource().chunkMap.regionManagers) {
-                    regionManager.recalculateRegions();
-                }
-                // Paper end
-                worldserver.timings.doTick.stopTiming(); // Spigot
-            } catch (Throwable throwable) {
-                // Spigot Start
-                CrashReport crashreport;
+    
+                this.profiler.push("tick");
+    
                 try {
-                    crashreport = CrashReport.forThrowable(throwable, "Exception ticking world");
-                } catch (Throwable t) {
-                    if (throwable instanceof ThreadDeath) { throw (ThreadDeath)throwable; } // Paper
-                    throw new RuntimeException("Error generating crash report", t);
+                    worldserver.timings.doTick.startTiming(); // Spigot
+                    worldserver.tick(staticBooleanSupplier);
+                    // Paper start
+                    for (final io.papermc.paper.chunk.SingleThreadChunkRegionManager regionManager : worldserver.getChunkSource().chunkMap.regionManagers) {
+                        regionManager.recalculateRegions();
+                    }
+                    // Paper end
+                    worldserver.timings.doTick.stopTiming(); // Spigot
+                } catch (Throwable throwable) {
+                    // Spigot Start
+                    CrashReport crashreport;
+                    try {
+                        crashreport = CrashReport.forThrowable(throwable, "Exception ticking world");
+                    } catch (Throwable t) {
+                        if (throwable instanceof ThreadDeath) {
+                            throw (ThreadDeath) throwable;
+                        } // Paper
+                        throw new RuntimeException("Error generating crash report", t);
+                    }
+                    // Spigot End
+        
+                    worldserver.fillReportDetails(crashreport);
+                    throw new ReportedException(crashreport);
                 }
-                // Spigot End
-
-                worldserver.fillReportDetails(crashreport);
-                throw new ReportedException(crashreport);
-            }
-
-            this.profiler.pop();
-            this.profiler.pop();
-            worldserver.explosionDensityCache.clear(); // Paper - Optimize explosions
+    
+                this.profiler.pop();
+                this.profiler.pop();
+                worldserver.explosionDensityCache.clear(); // Paper - Optimize explosions
+                PerformanceMonitor.getWorldTickNanoTimeMap().put(worldserver.getWorld(), System.nanoTime() - worldServerThreadNanoTime);
+            });
         }
+    
+        WorldThreadPool.doTick();
+    
+        WorldThreads.worldThreadMap.clear();
+        TimingHandler.clearWorldTimings();
+        PerformanceMonitor.setAllWorldTickNanoTime(System.nanoTime() - worldServerTickNanoTime);
 
         this.profiler.popPush("connection");
         MinecraftTimings.connectionTimer.startTiming(); // Spigot
@@ -2125,7 +2166,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
             this.worldData.setDataPackConfig(MinecraftServer.getSelectedPacks(this.packRepository));
             datapackresources.updateGlobals();
             new io.papermc.paper.event.server.ServerResourcesReloadedEvent(cause).callEvent(); // Paper
-            if (Thread.currentThread() != this.serverThread) return; // Paper
+            if (AsyncCatcher.isAsync()) return; // Paper
             //this.getPlayerList().savePlayers(); // Paper - we don't need to do this
             this.getPlayerList().reloadResources();
             this.functionManager.replaceLibrary(this.resources.getFunctionLibrary());
diff --git a/src/main/java/net/minecraft/server/dedicated/DedicatedServer.java b/src/main/java/net/minecraft/server/dedicated/DedicatedServer.java
index b6ee0e709b0f0529b99567bc9b8fb6bfd99bcd8e..b93c70ada4367ecba168a1b3412fb36fde5ca255 100644
--- a/src/main/java/net/minecraft/server/dedicated/DedicatedServer.java
+++ b/src/main/java/net/minecraft/server/dedicated/DedicatedServer.java
@@ -71,6 +71,7 @@ import co.aikar.timings.MinecraftTimings; // Paper
 import org.bukkit.event.server.ServerCommandEvent;
 import org.bukkit.craftbukkit.util.Waitable;
 import org.bukkit.event.server.RemoteServerCommandEvent;
+import world.chiyogami.config.ChiyogamiConfig;
 // CraftBukkit end
 
 public class DedicatedServer extends MinecraftServer implements ServerInterface {
@@ -234,6 +235,8 @@ public class DedicatedServer extends MinecraftServer implements ServerInterface
         io.papermc.paper.util.ObfHelper.INSTANCE.getClass(); // load mappings for stacktrace deobf and etc.
         io.papermc.paper.brigadier.PaperBrigadierProviderImpl.INSTANCE.getClass(); // init PaperBrigadierProvider
         // Paper end
+    
+        ChiyogamiConfig.load(); // Chiyogami
 
         this.setPvpAllowed(dedicatedserverproperties.pvp);
         this.setFlightAllowed(dedicatedserverproperties.allowFlight);
diff --git a/src/main/java/net/minecraft/server/level/ChunkMap.java b/src/main/java/net/minecraft/server/level/ChunkMap.java
index 7bb12a30d8b4a817f5a85969c6200306fd45a43d..4a59a86ad9481a56cad24b34ef8aec75215a3b3e 100644
--- a/src/main/java/net/minecraft/server/level/ChunkMap.java
+++ b/src/main/java/net/minecraft/server/level/ChunkMap.java
@@ -104,6 +104,7 @@ import org.apache.logging.log4j.Logger;
 
 import org.bukkit.entity.Player; // CraftBukkit
 import it.unimi.dsi.fastutil.objects.ReferenceOpenHashSet; // Paper
+import org.spigotmc.AsyncCatcher;
 
 public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider {
 
@@ -714,7 +715,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
     @Nullable
     public ChunkHolder getVisibleChunkIfPresent(long pos) {
         // Paper start - Don't copy
-        if (Thread.currentThread() == this.level.thread) {
+        if (!AsyncCatcher.isAsync()) {
             return this.updatingChunks.getVisible(pos);
         }
         return this.updatingChunks.getVisibleAsync(pos);
diff --git a/src/main/java/net/minecraft/server/level/ServerChunkCache.java b/src/main/java/net/minecraft/server/level/ServerChunkCache.java
index 4a3dbcfdacb809d162663c379c4e8151be522432..9af5dd64ff511760488f8d4857ae732fa85fff77 100644
--- a/src/main/java/net/minecraft/server/level/ServerChunkCache.java
+++ b/src/main/java/net/minecraft/server/level/ServerChunkCache.java
@@ -45,6 +45,7 @@ import net.minecraft.world.level.storage.DimensionDataStorage;
 import net.minecraft.world.level.storage.LevelData;
 import net.minecraft.world.level.storage.LevelStorageSource;
 import it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap; // Paper
+import org.spigotmc.AsyncCatcher;
 
 public class ServerChunkCache extends ChunkSource {
     public static final org.apache.logging.log4j.Logger LOGGER = org.apache.logging.log4j.LogManager.getLogger(); // Paper
@@ -142,7 +143,7 @@ public class ServerChunkCache extends ChunkSource {
     long chunkFutureAwaitCounter; // Paper - private -> package private
 
     public void getEntityTickingChunkAsync(int x, int z, java.util.function.Consumer<LevelChunk> onLoad) {
-        if (Thread.currentThread() != this.mainThread) {
+        if (AsyncCatcher.isAsync()) {
             this.mainThreadProcessor.execute(() -> {
                 ServerChunkCache.this.getEntityTickingChunkAsync(x, z, onLoad);
             });
@@ -152,7 +153,7 @@ public class ServerChunkCache extends ChunkSource {
     }
 
     public void getTickingChunkAsync(int x, int z, java.util.function.Consumer<LevelChunk> onLoad) {
-        if (Thread.currentThread() != this.mainThread) {
+        if (AsyncCatcher.isAsync()) {
             this.mainThreadProcessor.execute(() -> {
                 ServerChunkCache.this.getTickingChunkAsync(x, z, onLoad);
             });
@@ -162,7 +163,7 @@ public class ServerChunkCache extends ChunkSource {
     }
 
     public void getFullChunkAsync(int x, int z, java.util.function.Consumer<LevelChunk> onLoad) {
-        if (Thread.currentThread() != this.mainThread) {
+        if (AsyncCatcher.isAsync()) {
             this.mainThreadProcessor.execute(() -> {
                 ServerChunkCache.this.getFullChunkAsync(x, z, onLoad);
             });
@@ -172,7 +173,7 @@ public class ServerChunkCache extends ChunkSource {
     }
 
     private void getChunkFutureAsynchronously(int x, int z, int ticketLevel, Function<ChunkHolder, CompletableFuture<Either<LevelChunk, ChunkHolder.ChunkLoadingFailure>>> futureGet, java.util.function.Consumer<LevelChunk> onLoad) {
-        if (Thread.currentThread() != this.mainThread) {
+        if (AsyncCatcher.isAsync()) {
             throw new IllegalStateException();
         }
         ChunkPos chunkPos = new ChunkPos(x, z);
@@ -274,7 +275,7 @@ public class ServerChunkCache extends ChunkSource {
     void getChunkAtAsynchronously(int chunkX, int chunkZ, int ticketLevel,
                                   java.util.function.Function<ChunkHolder, CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>>> function,
                                   java.util.function.Consumer<ChunkAccess> consumer) {
-        if (Thread.currentThread() != this.mainThread) {
+        if (AsyncCatcher.isAsync()) {
             throw new IllegalStateException();
         }
 
@@ -471,7 +472,7 @@ public class ServerChunkCache extends ChunkSource {
     public LevelChunk getChunkAtIfLoadedImmediately(int x, int z) {
         long k = ChunkPos.asLong(x, z);
 
-        if (Thread.currentThread() == this.mainThread) {
+        if (!AsyncCatcher.isAsync()) {
             return this.getChunkAtIfLoadedMainThread(x, z);
         }
 
@@ -507,7 +508,7 @@ public class ServerChunkCache extends ChunkSource {
     private long asyncLoadSeqCounter;
 
     public CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> getChunkAtAsynchronously(int x, int z, boolean gen, boolean isUrgent) {
-        if (Thread.currentThread() != this.mainThread) {
+        if (AsyncCatcher.isAsync()) {
             CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> future = new CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>>();
             this.mainThreadProcessor.execute(() -> {
                 this.getChunkAtAsynchronously(x, z, gen, isUrgent).whenComplete((chunk, ex) -> {
@@ -636,7 +637,7 @@ public class ServerChunkCache extends ChunkSource {
     @Override
     public ChunkAccess getChunk(int x, int z, ChunkStatus leastStatus, boolean create) {
         final int x1 = x; final int z1 = z; // Paper - conflict on variable change
-        if (Thread.currentThread() != this.mainThread) {
+        if (AsyncCatcher.isAsync()) {
             return (ChunkAccess) CompletableFuture.supplyAsync(() -> {
                 return this.getChunk(x, z, leastStatus, create);
             }, this.mainThreadProcessor).join();
@@ -700,7 +701,7 @@ public class ServerChunkCache extends ChunkSource {
     @Nullable
     @Override
     public LevelChunk getChunkNow(int chunkX, int chunkZ) {
-        if (Thread.currentThread() != this.mainThread) {
+        if (AsyncCatcher.isAsync()) {
             return null;
         } else {
             return this.getChunkAtIfLoadedMainThread(chunkX, chunkZ); // Paper - optimise for loaded chunks
@@ -714,7 +715,7 @@ public class ServerChunkCache extends ChunkSource {
     }
 
     public CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> getChunkFuture(int chunkX, int chunkZ, ChunkStatus leastStatus, boolean create) {
-        boolean flag1 = Thread.currentThread() == this.mainThread;
+        boolean flag1 = !AsyncCatcher.isAsync();
         CompletableFuture completablefuture;
 
         if (flag1) {
diff --git a/src/main/java/net/minecraft/server/level/ServerLevel.java b/src/main/java/net/minecraft/server/level/ServerLevel.java
index d40a367670ccea01978cabf7d45f3c1a690662fc..66a6a8a4d31503f13324d9aeb246a42d0b36d3aa 100644
--- a/src/main/java/net/minecraft/server/level/ServerLevel.java
+++ b/src/main/java/net/minecraft/server/level/ServerLevel.java
@@ -162,6 +162,7 @@ import org.bukkit.event.weather.LightningStrikeEvent;
 import org.bukkit.event.world.TimeSkipEvent;
 // CraftBukkit end
 import it.unimi.dsi.fastutil.ints.IntArrayList; // Paper
+import org.spigotmc.AsyncCatcher;
 
 public class ServerLevel extends Level implements WorldGenLevel {
 
@@ -240,7 +241,7 @@ public class ServerLevel extends Level implements WorldGenLevel {
 
     public final void loadChunksForMoveAsync(AABB axisalignedbb, double toX, double toZ,
                                              java.util.function.Consumer<List<net.minecraft.world.level.chunk.ChunkAccess>> onLoad) {
-        if (Thread.currentThread() != this.thread) {
+        if (AsyncCatcher.isAsync()) {
             this.getChunkSource().mainThreadProcessor.execute(() -> {
                 this.loadChunksForMoveAsync(axisalignedbb, toX, toZ, onLoad);
             });
@@ -1104,7 +1105,7 @@ public class ServerLevel extends Level implements WorldGenLevel {
         // Spigot end
         // Paper start- timings
         final boolean isActive = org.spigotmc.ActivationRange.checkIfActive(entity);
-        timer = isActive ? entity.getType().tickTimer.startTiming() : entity.getType().inactiveTickTimer.startTiming(); // Paper
+        timer = isActive ? entity.getType().getTickTimer(this).startTiming() : entity.getType().getInactiveTickTimer(this).startTiming(); // Paper // Chiyogami
         try {
         // Paper end - timings
         entity.setOldPosAndRot();
@@ -1144,7 +1145,7 @@ public class ServerLevel extends Level implements WorldGenLevel {
             if (passenger instanceof Player || this.entityTickList.contains(passenger)) {
                 // Paper - EAR 2
                 final boolean isActive = org.spigotmc.ActivationRange.checkIfActive(passenger);
-                co.aikar.timings.Timing timer = isActive ? passenger.getType().passengerTickTimer.startTiming() : passenger.getType().passengerInactiveTickTimer.startTiming(); // Paper
+                co.aikar.timings.Timing timer = isActive ? passenger.getType().getPassengerTickTimer(this).startTiming() : passenger.getType().getPassengerInactiveTickTimer(this).startTiming(); // Paper // Chiyogami
                 try {
                 // Paper end
                 passenger.setOldPosAndRot();
diff --git a/src/main/java/net/minecraft/server/network/ServerGamePacketListenerImpl.java b/src/main/java/net/minecraft/server/network/ServerGamePacketListenerImpl.java
index 621ec8e8a197323da6b423fee57c816ac9d7c875..e3116e95be43a773652593e4de9965fd47b2d1f3 100644
--- a/src/main/java/net/minecraft/server/network/ServerGamePacketListenerImpl.java
+++ b/src/main/java/net/minecraft/server/network/ServerGamePacketListenerImpl.java
@@ -1529,7 +1529,7 @@ public class ServerGamePacketListenerImpl implements ServerPlayerConnection, Ser
 
     // Paper start - optimise out extra getCubes
     private boolean hasNewCollision(final ServerLevel world, final Entity entity, final AABB oldBox, final AABB newBox) {
-        final List<AABB> collisions = io.papermc.paper.util.CachedLists.getTempCollisionList();
+        final List<AABB> collisions = io.papermc.paper.util.CachedLists.getTempCollisionList(world.getWorld());
         try {
             io.papermc.paper.util.CollisionUtil.getCollisions(world, entity, newBox, collisions, false, true,
                 true, false, null, null);
@@ -1543,7 +1543,7 @@ public class ServerGamePacketListenerImpl implements ServerPlayerConnection, Ser
 
             return false;
         } finally {
-            io.papermc.paper.util.CachedLists.returnTempCollisionList(collisions);
+            io.papermc.paper.util.CachedLists.returnTempCollisionList(collisions, world.getWorld());
         }
     }
     // Paper end - optimise out extra getCubes
diff --git a/src/main/java/net/minecraft/world/entity/Entity.java b/src/main/java/net/minecraft/world/entity/Entity.java
index b7c4700fd5db14c77e7ee78311dd77a754d9d41c..36d400130f3c84aa98ff2bf89f1284aaac466d8b 100644
--- a/src/main/java/net/minecraft/world/entity/Entity.java
+++ b/src/main/java/net/minecraft/world/entity/Entity.java
@@ -147,6 +147,7 @@ import org.bukkit.event.entity.EntityPortalEvent;
 import org.bukkit.event.entity.EntityPoseChangeEvent;
 import org.bukkit.event.player.PlayerTeleportEvent;
 import org.bukkit.plugin.PluginManager;
+import world.chiyogami.thread.WorldThreadPool;
 // CraftBukkit end
 
 public abstract class Entity implements Nameable, EntityAccess, CommandSource, net.minecraft.server.KeyedObject { // Paper
@@ -1240,7 +1241,7 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource, n
             return moveVector;
         }
 
-        final List<AABB> potentialCollisions = io.papermc.paper.util.CachedLists.getTempCollisionList();
+        final List<AABB> potentialCollisions = io.papermc.paper.util.CachedLists.getTempCollisionList(world.getWorld());
         try {
             final double stepHeight = (double)this.maxUpStep;
             final AABB collisionBox;
@@ -1296,7 +1297,7 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource, n
                 return limitedMoveVector;
             }
         } finally {
-            io.papermc.paper.util.CachedLists.returnTempCollisionList(potentialCollisions);
+            io.papermc.paper.util.CachedLists.returnTempCollisionList(potentialCollisions, world.getWorld());
         }
         // Paper end - optimise collisions
     }
@@ -3173,6 +3174,14 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource, n
             LOGGER.warn("Illegal Entity Teleport " + this + " to " + worldserver + ":" + location, new Throwable());
             return null;
         }
+        WorldThreadPool.catchWrongThread(level.getWorld(), "Entity teleportTo");
+        if(!this.level.isClientSide) { // Chiyogami - Thread wait request
+            if(worldserver != null) {
+                if (worldserver != this.level) {
+                    WorldThreadPool.requestWaitForTask((ServerLevel) this.level, worldserver);
+                }
+            }
+        }
         // Paper end
         if (this.level instanceof ServerLevel && !this.isRemoved()) {
             this.level.getProfiler().push("changeDimension");
diff --git a/src/main/java/net/minecraft/world/entity/EntityType.java b/src/main/java/net/minecraft/world/entity/EntityType.java
index 1c446dba5de89698397041ee38a2e1a00bec8a56..ef5a65820513e732ee55838fe7fcfab9217129a3 100644
--- a/src/main/java/net/minecraft/world/entity/EntityType.java
+++ b/src/main/java/net/minecraft/world/entity/EntityType.java
@@ -1,11 +1,11 @@
 package net.minecraft.world.entity;
 
+import co.aikar.timings.Timing;
+import co.aikar.timings.Timings;
 import com.google.common.collect.ImmutableSet;
-import java.util.List;
-import java.util.Optional;
-import java.util.Spliterator;
-import java.util.Set; // Paper
-import java.util.UUID;
+
+import java.util.*;
+import java.util.concurrent.ConcurrentHashMap;
 import java.util.function.Consumer;
 import java.util.function.Function;
 import java.util.stream.Stream;
@@ -321,6 +321,28 @@ public class EntityType<T extends Entity> implements EntityTypeTest<Entity, T> {
         this.passengerInactiveTickTimer = co.aikar.timings.MinecraftTimings.getEntityTimings(id, "passengerInactiveTick");
         // Paper end
     }
+    
+    // Chiyogami - timings
+    private final Map<String, Timing> tickMap = new ConcurrentHashMap<>();
+    private final Map<String, Timing> inactiveTickMap = new ConcurrentHashMap<>();
+    private final Map<String, Timing> passengerTickMap = new ConcurrentHashMap<>();
+    private final Map<String, Timing> passengerInactiveTickMap = new ConcurrentHashMap<>();
+    
+    public Timing getTickTimer(Level level){
+        return tickMap.computeIfAbsent(level.getWorld().getName(), k -> Timings.ofSafeW(k + ": " + id + " - tick"));
+    }
+    
+    public Timing getInactiveTickTimer(Level level){
+        return inactiveTickMap.computeIfAbsent(level.getWorld().getName(), k -> Timings.ofSafeW(k + ": " + id + " - inactiveTick"));
+    }
+    
+    public Timing getPassengerTickTimer(Level level){
+        return passengerTickMap.computeIfAbsent(level.getWorld().getName(), k -> Timings.ofSafeW(k + ": " + id + " - passengerTick"));
+    }
+    
+    public Timing getPassengerInactiveTickTimer(Level level){
+        return passengerInactiveTickMap.computeIfAbsent(level.getWorld().getName(), k -> Timings.ofSafeW(k + ": " + id + " - passengerInactiveTick"));
+    }
 
     @Nullable
     public Entity spawn(ServerLevel world, @Nullable ItemStack stack, @Nullable Player player, BlockPos pos, MobSpawnType spawnReason, boolean alignPosition, boolean invertY) {
diff --git a/src/main/java/net/minecraft/world/level/Level.java b/src/main/java/net/minecraft/world/level/Level.java
index 9cafd000b3533ed9fd35df2ec880f55e262084fb..b2c6b87c58178d3a6dc5b2ec2aa632d3e4a98ade 100644
--- a/src/main/java/net/minecraft/world/level/Level.java
+++ b/src/main/java/net/minecraft/world/level/Level.java
@@ -98,6 +98,7 @@ import org.bukkit.craftbukkit.block.data.CraftBlockData;
 import org.bukkit.craftbukkit.util.CraftNamespacedKey;
 import org.bukkit.event.block.BlockPhysicsEvent;
 import org.bukkit.event.world.GenericGameEvent;
+import org.spigotmc.AsyncCatcher;
 // CraftBukkit end
 
 public abstract class Level implements LevelAccessor, AutoCloseable {
@@ -465,7 +466,7 @@ public abstract class Level implements LevelAccessor, AutoCloseable {
     public final LevelChunk getChunk(int chunkX, int chunkZ) { // Paper - final to help inline
         // Paper start - make sure loaded chunks get the inlined variant of this function
         net.minecraft.server.level.ServerChunkCache cps = ((ServerLevel)this).getChunkSource();
-        if (cps.mainThread == Thread.currentThread()) {
+        if (!AsyncCatcher.isAsync()) {
             LevelChunk ifLoaded = cps.getChunkAtIfLoadedMainThread(chunkX, chunkZ);
             if (ifLoaded != null) {
                 return ifLoaded;
@@ -1028,7 +1029,7 @@ public abstract class Level implements LevelAccessor, AutoCloseable {
         }
         // Paper end
         // CraftBukkit end
-        return this.isOutsideBuildHeight(blockposition) ? null : (!this.isClientSide && Thread.currentThread() != this.thread ? null : this.getChunkAt(blockposition).getBlockEntity(blockposition, LevelChunk.EntityCreationType.IMMEDIATE));
+        return this.isOutsideBuildHeight(blockposition) ? null : (!this.isClientSide && AsyncCatcher.isAsync() ? null : this.getChunkAt(blockposition).getBlockEntity(blockposition, LevelChunk.EntityCreationType.IMMEDIATE));
     }
 
     public void setBlockEntity(BlockEntity blockEntity) {
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftServer.java b/src/main/java/org/bukkit/craftbukkit/CraftServer.java
index 30758966b0d4496c8d33e71eac44b63eb8b956f1..1954ebfa458281bf0a70e862b50424123cf4651b 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftServer.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftServer.java
@@ -246,6 +246,7 @@ import org.yaml.snakeyaml.constructor.SafeConstructor;
 import org.yaml.snakeyaml.error.MarkedYAMLException;
 
 import net.md_5.bungee.api.chat.BaseComponent; // Spigot
+import world.chiyogami.chiyogamilib.WorldThreads;
 
 import javax.annotation.Nullable; // Paper
 import javax.annotation.Nonnull; // Paper
@@ -2118,7 +2119,7 @@ public final class CraftServer implements Server {
 
     @Override
     public boolean isPrimaryThread() {
-        return Thread.currentThread().equals(console.serverThread) || Thread.currentThread().equals(net.minecraft.server.MinecraftServer.getServer().shutdownThread); // Paper - Fix issues with detecting main thread properly, the only time Watchdog will be used is during a crash shutdown which is a "try our best" scenario
+        return Thread.currentThread().equals(console.serverThread) || Thread.currentThread().equals(net.minecraft.server.MinecraftServer.getServer().shutdownThread) || WorldThreads.isWorldThread(); // Paper - Fix issues with detecting main thread properly, the only time Watchdog will be used is during a crash shutdown which is a "try our best" scenario
     }
 
     // Paper start
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftWorld.java b/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
index 858e29ad77aee8a1b7797c2d82902abbfd662da2..95e34c34c481fc1e103b26ef81234a0a4f2c3c79 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
@@ -114,6 +114,7 @@ import org.bukkit.util.BoundingBox;
 import org.bukkit.util.Consumer;
 import org.bukkit.util.RayTraceResult;
 import org.bukkit.util.Vector;
+import org.spigotmc.AsyncCatcher;
 
 public class CraftWorld extends CraftRegionAccessor implements World {
     public static final int CUSTOM_DIMENSION_OFFSET = 10;
@@ -345,7 +346,7 @@ public class CraftWorld extends CraftRegionAccessor implements World {
     @Override
     public Chunk[] getLoadedChunks() {
         // Paper start
-        if (Thread.currentThread() != world.getLevel().thread) {
+        if (AsyncCatcher.isAsync()) {
             // Paper start - change updating chunks map
             Long2ObjectLinkedOpenHashMap<ChunkHolder> chunks;
             synchronized (world.getChunkSource().chunkMap.updatingChunks) {
diff --git a/src/main/java/org/bukkit/craftbukkit/entity/CraftEntity.java b/src/main/java/org/bukkit/craftbukkit/entity/CraftEntity.java
index 0bd800e1aeda87689a6c56ee6fadda381c74a4ff..02fc3c54b4be6fa4832da10b8851ed0d81f894df 100644
--- a/src/main/java/org/bukkit/craftbukkit/entity/CraftEntity.java
+++ b/src/main/java/org/bukkit/craftbukkit/entity/CraftEntity.java
@@ -181,6 +181,7 @@ import org.bukkit.plugin.Plugin;
 import org.bukkit.util.BoundingBox;
 import org.bukkit.util.NumberConversions;
 import org.bukkit.util.Vector;
+import world.chiyogami.thread.WorldThreadPool;
 
 public abstract class CraftEntity implements org.bukkit.entity.Entity {
     private static PermissibleBase perm;
@@ -560,6 +561,7 @@ public abstract class CraftEntity implements org.bukkit.entity.Entity {
     public boolean teleport(Location location, TeleportCause cause) {
         Preconditions.checkArgument(location != null, "location");
         location.checkFinite();
+        WorldThreadPool.catchWrongThread(this.getWorld(), "CraftEntity teleport"); // Chiyogami
 
         if (this.entity.isVehicle() || this.entity.isRemoved()) {
             return false;
diff --git a/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java b/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
index 4ff4143f3a7cd89ef92f4b8882fa3e5addfe0f06..d023d2ca7991f8e16ee051bde02533b42c10b57a 100644
--- a/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
+++ b/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
@@ -133,6 +133,7 @@ import org.bukkit.scoreboard.Scoreboard;
 import org.jetbrains.annotations.NotNull;
 
 import net.md_5.bungee.api.chat.BaseComponent; // Spigot
+import world.chiyogami.thread.WorldThreadPool;
 
 @DelegateDeserialization(CraftOfflinePlayer.class)
 public class CraftPlayer extends CraftHumanEntity implements Player {
@@ -999,6 +1000,12 @@ public class CraftPlayer extends CraftHumanEntity implements Player {
         Preconditions.checkArgument(location != null, "location");
         Preconditions.checkArgument(location.getWorld() != null, "location.world");
         location.checkFinite();
+        WorldThreadPool.catchWrongThread(this.getWorld(), "CraftPlayer teleport"); // Chiyogami
+    
+        // Chiyogami - Thread wait request
+        if (this.getWorld() != location.getWorld()) {
+            WorldThreadPool.requestWaitForTask(((CraftWorld) this.getWorld()).getHandle(), ((CraftWorld) location.getWorld()).getHandle());
+        }
 
         ServerPlayer entity = this.getHandle();
 
diff --git a/src/main/java/org/spigotmc/AsyncCatcher.java b/src/main/java/org/spigotmc/AsyncCatcher.java
index 41ddd9e0517571c7bffb494766f7097198b50842..080449097746646e2bdfdf143180582838dcc8e2 100644
--- a/src/main/java/org/spigotmc/AsyncCatcher.java
+++ b/src/main/java/org/spigotmc/AsyncCatcher.java
@@ -1,6 +1,7 @@
 package org.spigotmc;
 
 import net.minecraft.server.MinecraftServer;
+import world.chiyogami.chiyogamilib.WorldThreads;
 
 public class AsyncCatcher
 {
@@ -10,10 +11,14 @@ public class AsyncCatcher
 
     public static void catchOp(String reason)
     {
-        if ( (AsyncCatcher.enabled || io.papermc.paper.util.TickThread.STRICT_THREAD_CHECKS) && Thread.currentThread() != MinecraftServer.getServer().serverThread ) // Paper
+        if ( (AsyncCatcher.enabled || io.papermc.paper.util.TickThread.STRICT_THREAD_CHECKS) && Thread.currentThread() != MinecraftServer.getServer().serverThread && !WorldThreads.isWorldThread()) // Paper
         {
             MinecraftServer.LOGGER.fatal("Thread " + Thread.currentThread().getName() + " failed main thread check: " + reason, new Throwable()); // Paper
             throw new IllegalStateException( "Asynchronous " + reason + "!" );
         }
     }
+    
+    public static boolean isAsync(){
+        return Thread.currentThread() != MinecraftServer.getServer().serverThread && !WorldThreads.isWorldThread();
+    }
 }
diff --git a/src/main/java/world/chiyogami/bridge/ParallelWorldBridge.java b/src/main/java/world/chiyogami/bridge/ParallelWorldBridge.java
new file mode 100644
index 0000000000000000000000000000000000000000..0a9f3fa64141eb02f23af9cc6f1752fa31b96966
--- /dev/null
+++ b/src/main/java/world/chiyogami/bridge/ParallelWorldBridge.java
@@ -0,0 +1,18 @@
+package world.chiyogami.bridge;
+
+import java.util.Map;
+import java.util.UUID;
+import java.util.concurrent.ConcurrentHashMap;
+
+public class ParallelWorldBridge {
+    
+    public static boolean parallelWorldBridge = false;
+    
+    private static final Map<UUID, WrappedParallelWorld> wrappedParallelWorldMap = new ConcurrentHashMap<>();
+    
+    public static WrappedParallelWorld getWrappedParallelWorld(UUID uuid){
+        if(!parallelWorldBridge) return null;
+        return wrappedParallelWorldMap.computeIfAbsent(uuid, WrappedParallelWorld::new);
+    }
+    
+}
diff --git a/src/main/java/world/chiyogami/bridge/WrappedParallelWorld.java b/src/main/java/world/chiyogami/bridge/WrappedParallelWorld.java
new file mode 100644
index 0000000000000000000000000000000000000000..81ec91f8a0f7f85b151a8fd92fd3ff9d3869bafd
--- /dev/null
+++ b/src/main/java/world/chiyogami/bridge/WrappedParallelWorld.java
@@ -0,0 +1,60 @@
+package world.chiyogami.bridge;
+
+import net.minecraft.server.MCUtil;
+import net.minecraft.world.phys.AABB;
+import org.bukkit.World;
+
+import java.util.Map;
+import java.util.Set;
+import java.util.UUID;
+import java.util.concurrent.ConcurrentHashMap;
+
+public class WrappedParallelWorld {
+    
+    private final UUID uuid;
+    
+    private final Map<World, Map<Long, Set<Integer>>> editedBlockMap = new ConcurrentHashMap<>();
+    
+    public WrappedParallelWorld(UUID uuid){
+        this.uuid = uuid;
+    }
+    
+    public void addEditedBlock(World world, int x, int y, int z){
+        long chunkCoordinate = MCUtil.getCoordinateKey(x, z);
+        editedBlockMap.computeIfAbsent(world, k -> new ConcurrentHashMap<>())
+            .computeIfAbsent(chunkCoordinate, k -> ConcurrentHashMap.newKeySet()).add((x & 0xF) * y * (z & 0xF));
+    }
+    
+    public void removeEditedBlock(World world, int x, int y, int z){
+        Map<Long, Set<Integer>> editedMap = editedBlockMap.get(world);
+        if(editedMap == null) return;
+        
+        Set<Integer> blocks = editedMap.get(MCUtil.getCoordinateKey(x, z));
+        if(blocks == null) return;
+        
+        blocks.remove((x & 0xF) * y * (z & 0xF));
+    }
+    
+    public boolean isEditedBlock(World world, int x, int y, int z){
+        Map<Long, Set<Integer>> editedMap = editedBlockMap.get(world);
+        if(editedMap == null) return false;
+        
+        Set<Integer> blocks = editedMap.get(MCUtil.getCoordinateKey(x, z));
+        if(blocks == null) return false;
+        
+        return blocks.contains((x & 0xF) * y * (z & 0xF));
+    }
+    
+    public boolean isBoundingBoxInEditedBlock(World world, AABB bb){
+        if(isEditedBlock(world, (int)bb.maxX, (int)bb.minY, (int)bb.maxZ)) return true;
+        if(isEditedBlock(world, (int)bb.maxX, (int)bb.minY, (int)bb.minZ)) return true;
+        if(isEditedBlock(world, (int)bb.minX, (int)bb.minY, (int)bb.maxZ)) return true;
+        if(isEditedBlock(world, (int)bb.minX, (int)bb.minY, (int)bb.minZ)) return true;
+        if(isEditedBlock(world, (int)bb.maxX, (int)bb.maxY, (int)bb.maxZ)) return true;
+        if(isEditedBlock(world, (int)bb.maxX, (int)bb.maxY, (int)bb.minZ)) return true;
+        if(isEditedBlock(world, (int)bb.minX, (int)bb.maxY, (int)bb.maxZ)) return true;
+        if(isEditedBlock(world, (int)bb.minX, (int)bb.maxY, (int)bb.minZ)) return true;
+        return false;
+    }
+    
+}
diff --git a/src/main/java/world/chiyogami/config/ChiyogamiConfig.java b/src/main/java/world/chiyogami/config/ChiyogamiConfig.java
new file mode 100644
index 0000000000000000000000000000000000000000..88812e348a75b5eedffc6843682253c75a1a7bcd
--- /dev/null
+++ b/src/main/java/world/chiyogami/config/ChiyogamiConfig.java
@@ -0,0 +1,117 @@
+package world.chiyogami.config;
+
+
+import org.bukkit.configuration.file.YamlConfiguration;
+import org.bukkit.plugin.SimplePluginManager;
+import world.chiyogami.bridge.ParallelWorldBridge;
+import world.chiyogami.chiyogamilib.monitor.WorkMode;
+import world.chiyogami.log.ChiyogamiLogger;
+import world.chiyogami.thread.WorldThreadPool;
+
+import java.io.File;
+import java.util.ArrayList;
+import java.util.List;
+
+public final class ChiyogamiConfig {
+    
+    private static final int VERSION = 2;
+    
+    private static final List<ConfigComponent<?>> configComponentList = new ArrayList<>();
+    
+    private static final ConfigComponent<Integer> CONFIG_VERSION = new ConfigComponent<>("config-version", VERSION, VERSION);
+    private static final ConfigComponent<Integer> MAX_WORLD_THREADS = new ConfigComponent<>("max-world-threads", 0, 0);
+    private static final ConfigComponent<Boolean> SHOW_CHIYOGAMI_LOG = new ConfigComponent<>("show-detail-log", true, 0);
+    private static final ConfigComponent<Boolean> SYNCHRONIZED_EVENT = new ConfigComponent<>("synchronized-event", true, 1);
+    private static final ConfigComponent<Boolean> PARALLEL_WORLD_BRIDGE = new ConfigComponent<>("parallel-world-bridge", false, 2);
+    
+    
+    private static void setDefaultValues(YamlConfiguration yml){
+        int configVer = 0;
+        if(yml.contains(CONFIG_VERSION.path)) configVer = yml.getInt(CONFIG_VERSION.path);
+        
+        for(ConfigComponent<?> configComponent : configComponentList){
+            String path = configComponent.path;
+            Object defaultValue = configComponent.defaultValue;
+            int componentVer = configComponent.version;
+            
+            if(configVer < componentVer || !yml.contains(path)){
+                yml.set(path, defaultValue);
+            }
+        }
+    }
+    
+    
+    private static void loadValues(YamlConfiguration yml){
+        for(ConfigComponent<?> configComponent : configComponentList){
+            String path = configComponent.path;
+            if(yml.contains(path)){
+                try {
+                    configComponent.setValue(yml.get(path));
+                }catch (Exception e){e.printStackTrace();}
+            }
+        }
+    }
+    
+    
+    private static class ConfigComponent<T>{
+        
+        private final String path;
+        
+        private final T defaultValue;
+        
+        private final int version;
+        
+        private T value = null;
+        
+        private ConfigComponent(String path, T defaultValue, int version){
+            this.path = path;
+            this.defaultValue = defaultValue;
+            this.version = version;
+            configComponentList.add(this);
+        }
+        
+        private void setValue(Object value) {this.value = (T)value;}
+        
+        private T getValue() {
+            if(value != null) return value;
+            return defaultValue;
+        }
+    }
+    
+    
+    
+    
+    public static void load(){
+        try {
+            
+            File file = new File("chiyogami.yml");
+            
+            YamlConfiguration yml;
+            if (file.exists()) {
+                yml = YamlConfiguration.loadConfiguration(file);
+            } else {
+                yml = new YamlConfiguration();
+            }
+            setDefaultValues(yml);
+            yml.save(file);
+            
+            loadValues(yml);
+            
+            WorkMode.MULTI_THREAD_TICK = MAX_WORLD_THREADS.getValue() != 1;
+            WorldThreadPool.setMaxPoolSize(MAX_WORLD_THREADS.getValue());
+            
+            ChiyogamiLogger.isShowLogs = SHOW_CHIYOGAMI_LOG.getValue();
+            
+            SimplePluginManager.synchronizedEvent = SYNCHRONIZED_EVENT.getValue();
+            
+            ParallelWorldBridge.parallelWorldBridge = PARALLEL_WORLD_BRIDGE.getValue();
+            
+        }catch (Exception e){e.printStackTrace();}
+    }
+    
+    public static int getMaxWorldThreads() {return MAX_WORLD_THREADS.getValue();}
+    
+    public static boolean isShowLogs() {return SHOW_CHIYOGAMI_LOG.getValue();}
+    
+    public static boolean isSynchronizedEvent(){return SYNCHRONIZED_EVENT.getValue();}
+}
diff --git a/src/main/java/world/chiyogami/log/ChiyogamiLogger.java b/src/main/java/world/chiyogami/log/ChiyogamiLogger.java
new file mode 100644
index 0000000000000000000000000000000000000000..a5812a694c07800f602b7eddfb880b0657e7ff4d
--- /dev/null
+++ b/src/main/java/world/chiyogami/log/ChiyogamiLogger.java
@@ -0,0 +1,16 @@
+package world.chiyogami.log;
+
+
+import net.minecraft.server.MinecraftServer;
+
+public class ChiyogamiLogger {
+    
+    public static boolean isShowLogs = true;
+    
+    public static void info(String string){
+        if(!isShowLogs) return;
+        string = "Chiyogami : INFO > " + string;
+        MinecraftServer.LOGGER.info(string);
+    }
+    
+}
diff --git a/src/main/java/world/chiyogami/thread/WorldThreadPool.java b/src/main/java/world/chiyogami/thread/WorldThreadPool.java
new file mode 100644
index 0000000000000000000000000000000000000000..3ef46a7977230d6abe5bb4cd3c3ca8374bc8df51
--- /dev/null
+++ b/src/main/java/world/chiyogami/thread/WorldThreadPool.java
@@ -0,0 +1,160 @@
+package world.chiyogami.thread;
+
+
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.server.level.ServerLevel;
+import org.bukkit.World;
+import org.bukkit.craftbukkit.CraftWorld;
+import world.chiyogami.chiyogamilib.WorldThreads;
+import world.chiyogami.log.ChiyogamiLogger;
+
+import java.util.*;
+import java.util.concurrent.*;
+import java.util.concurrent.locks.ReentrantLock;
+
+public class WorldThreadPool {
+    
+    public static final Map<ServerLevel, Runnable> tickRunnableMap = new HashMap<>();
+    
+    public static final Set<ServerLevel> worldServers = new HashSet<>();
+    
+    private static final Map<ServerLevel, Future<?>> worldThreadFutureMap = new HashMap<>();
+    
+    
+    private static ExecutorService executorService = null;
+    
+    private static int maxPoolSize = 0;
+    
+    private static int previousPoolSize = 0;
+    
+    public static void setMaxPoolSize(int poolSize) {WorldThreadPool.maxPoolSize = poolSize;}
+    
+    
+    private static final Map<ServerLevel, ServerLevel> waitWorldServerMap = new HashMap<>();
+    
+    private static final Map<ServerLevel, ServerLevel> waitedWorldServerMap = new HashMap<>();
+    
+    private static final ReentrantLock WAIT_REQUEST_LOCK = new ReentrantLock(true);
+    
+    public static boolean isDoneWorldServerTask(ServerLevel worldServer){
+        WAIT_REQUEST_LOCK.lock();
+        try {
+            return worldThreadFutureMap.get(worldServer).isDone();
+        } finally {
+            WAIT_REQUEST_LOCK.unlock();
+        }
+    }
+    
+    public static void catchWrongThread(World world, String reason){
+        
+        Thread currentThread = Thread.currentThread();
+        
+        if(currentThread == MinecraftServer.getServer().serverThread) return;
+        if(currentThread == WorldThreads.worldThreadMap.get(world)) return;
+        if(isDoneWorldServerTask(((CraftWorld) world).getHandle())) return;
+        
+        throw new IllegalStateException("Chiyogami > Called from a thread in another world -> " + reason
+            + System.lineSeparator() + "This operation is unacceptable because it can cause serious damage to this server."
+            + System.lineSeparator() + "It has been rejected by Chiyogami, it is not a bug.");
+    }
+    
+    public static void requestWaitForTask(ServerLevel from, ServerLevel to){
+        
+        if(maxPoolSize == 1) return;
+        if(Thread.currentThread() == MinecraftServer.getServer().serverThread) return;
+        if(!WorldThreads.isWorldThread()) return;
+        
+        ChiyogamiLogger.info("Lock request : " + from.serverLevelData.getLevelName() + " -> " + to.serverLevelData.getLevelName());
+        
+        Future<?> worldServerFuture = null;
+        
+        WAIT_REQUEST_LOCK.lock();
+        try{
+            if(!waitWorldServerMap.containsKey(from)){
+    
+                ServerLevel lowest = getWaitWorldServer(to);
+                
+                if(lowest != from) {
+                    ServerLevel highest = getWaitedWorldServer(to);
+                    waitWorldServerMap.put(from, highest);
+                    waitedWorldServerMap.put(highest, from);
+                    
+                    ChiyogamiLogger.info("Wait thread : " + from.serverLevelData.getLevelName() + " -> " + highest.serverLevelData.getLevelName());
+                    worldServerFuture = worldThreadFutureMap.get(highest);
+                }
+            }else{
+                ServerLevel fromHighest = getWaitedWorldServer(from);
+                ServerLevel highest = getWaitedWorldServer(to);
+                ServerLevel lowest = getWaitWorldServer(to);
+                
+                if(highest != fromHighest) {
+                    ServerLevel low = waitWorldServerMap.get(from);
+                    waitWorldServerMap.put(lowest, low);
+                    waitedWorldServerMap.put(low, lowest);
+                    
+                    waitWorldServerMap.put(from, highest);
+                    waitedWorldServerMap.put(highest, from);
+                    
+                    ChiyogamiLogger.info("Wait thread : " + from.serverLevelData.getLevelName() + " -> " + highest.serverLevelData.getLevelName());
+                    worldServerFuture = worldThreadFutureMap.get(highest);
+                }
+            }
+        } finally {
+            WAIT_REQUEST_LOCK.unlock();
+        }
+        
+        if(worldServerFuture != null){
+            try {
+                worldServerFuture.get();
+            } catch (Exception e){e.printStackTrace();}
+        }
+    }
+    
+    
+    public static ServerLevel getWaitWorldServer(ServerLevel from){
+        ServerLevel worldServer = waitWorldServerMap.get(from);
+        if(worldServer == null) return from;
+        else return getWaitWorldServer(worldServer);
+    }
+    
+    public static ServerLevel getWaitedWorldServer(ServerLevel from){
+        ServerLevel worldServer = waitedWorldServerMap.get(from);
+        if(worldServer == null) return from;
+        else return getWaitedWorldServer(worldServer);
+    }
+    
+    public static void shutdown(){
+        executorService.shutdown();
+    }
+    
+    public static void doTick(){
+        int pool = maxPoolSize > 0 ? maxPoolSize : worldServers.size();
+        
+        if(pool != previousPoolSize){
+            if(executorService != null) executorService.shutdown();
+            executorService = Executors.newFixedThreadPool(pool);
+            previousPoolSize = pool;
+        }
+        
+        WAIT_REQUEST_LOCK.lock();
+        try {
+            for (ServerLevel worldServer : worldServers) {
+                Future<?> future = executorService.submit(tickRunnableMap.get(worldServer));
+                worldThreadFutureMap.put(worldServer, future);
+            }
+        } finally {
+            WAIT_REQUEST_LOCK.unlock();
+        }
+        
+        for(Future<?> future : worldThreadFutureMap.values()){
+            try {
+                future.get();
+            } catch (Exception e){e.printStackTrace();}
+        }
+        
+        waitWorldServerMap.clear();
+        worldThreadFutureMap.clear();
+        waitedWorldServerMap.clear();
+        worldServers.clear();
+    }
+}
