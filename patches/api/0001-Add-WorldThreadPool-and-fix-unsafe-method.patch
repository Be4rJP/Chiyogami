From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Be4rJP <bea0224@outlook.jp>
Date: Wed, 3 Nov 2021 23:15:37 +0900
Subject: [PATCH] Add WorldThreadPool and fix unsafe method


diff --git a/src/main/java/co/aikar/timings/TimingHandler.java b/src/main/java/co/aikar/timings/TimingHandler.java
index 199789d56d22fcb1b77ebd56805cc28aa5a5ab0a..787bd960c6b285109a10385e3f700dcc1c6df9a5 100644
--- a/src/main/java/co/aikar/timings/TimingHandler.java
+++ b/src/main/java/co/aikar/timings/TimingHandler.java
@@ -28,6 +28,8 @@ import it.unimi.dsi.fastutil.ints.Int2ObjectOpenHashMap;
 
 import java.util.ArrayDeque;
 import java.util.Deque;
+import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.logging.Level;
 import java.util.logging.Logger;
@@ -36,26 +38,28 @@ import org.bukkit.Bukkit;
 import org.jetbrains.annotations.NotNull;
 import org.jetbrains.annotations.Nullable;
 
-class TimingHandler implements Timing {
-
-    private static AtomicInteger idPool = new AtomicInteger(1);
-    private static Deque<TimingHandler> TIMING_STACK = new ArrayDeque<>();
+public class TimingHandler implements Timing {
+    
+    protected static AtomicInteger idPool = new AtomicInteger(1);
+    protected static Deque<TimingHandler> MAIN_THREAD_TIMING_STACK = new ArrayDeque<>();
+    protected static Map<Thread, Deque<TimingHandler>> WORLD_THREAD_TIMING_STACK = new ConcurrentHashMap<>();
+    protected static TimingHandler WORLD_PARENT_TIMING = null;
     final int id = idPool.getAndIncrement();
-
+    
     final TimingIdentifier identifier;
-    private final boolean verbose;
-
-    private final Int2ObjectOpenHashMap<TimingData> children = new LoadingIntMap<>(TimingData::new);
-
+    protected final boolean verbose;
+    
+    protected final Map<Integer, TimingData> children = new ConcurrentHashMap<>();
+    
     final TimingData record;
-    private TimingHandler startParent;
-    private final TimingHandler groupHandler;
-
-    private long start = 0;
-    private int timingDepth = 0;
-    private boolean added;
-    private boolean timed;
-    private boolean enabled;
+    protected TimingHandler startParent;
+    protected final TimingHandler groupHandler;
+    
+    protected long start = 0;
+    protected int timingDepth = 0;
+    protected boolean added;
+    protected boolean timed;
+    protected boolean enabled;
 
     TimingHandler(@NotNull TimingIdentifier id) {
         this.identifier = id;
@@ -66,7 +70,64 @@ class TimingHandler implements Timing {
         TimingIdentifier.getGroup(id.group).handlers.add(this);
         checkEnabled();
     }
-
+    
+    public static class WorldTiming extends TimingHandler{
+        
+        WorldTiming(@NotNull TimingIdentifier id) {
+            super(id);
+        }
+        
+        
+        @Override
+        @NotNull
+        public Timing startTiming() {
+            return startTiming(false);
+        }
+        
+        
+        @NotNull
+        public Timing startTiming(boolean parent) {
+            if (!enabled || !Bukkit.isPrimaryThread()) {
+                return this;
+            }
+            
+            if(Bukkit.getServer().isPrimaryThreadNotWorldThread()) return this;
+            
+            Deque<TimingHandler> timingHandlers = WORLD_THREAD_TIMING_STACK.computeIfAbsent(Thread.currentThread(), k -> new ArrayDeque<>());
+            if (++timingDepth == 1) {
+                startParent = timingHandlers.peekLast();
+                if(parent){
+                    startParent = WORLD_PARENT_TIMING;
+                }
+                start = System.nanoTime();
+            }
+            timingHandlers.addLast(this);
+            
+            return this;
+        }
+        
+        @Override
+        public void stopTiming() {
+            if (!enabled || timingDepth <= 0 || start == 0 || !Bukkit.isPrimaryThread()) {
+                return;
+            }
+            
+            if(Bukkit.getServer().isPrimaryThreadNotWorldThread()) return;
+            
+            popTimingStack();
+            if (--timingDepth == 0) {
+                addDiff(System.nanoTime() - start, startParent);
+                startParent = null;
+                start = 0;
+            }
+        }
+    }
+    
+    
+    
+    
+    
+    
     final void checkEnabled() {
         enabled = Timings.timingsEnabled && (!verbose || Timings.verboseEnabled);
     }
@@ -101,11 +162,15 @@ class TimingHandler implements Timing {
         if (!enabled || !Bukkit.isPrimaryThread()) {
             return this;
         }
-        if (++timingDepth == 1) {
-            startParent = TIMING_STACK.peekLast();
-            start = System.nanoTime();
+    
+        if(Bukkit.getServer().isPrimaryThreadNotWorldThread()){
+            if (++timingDepth == 1) {
+                startParent = MAIN_THREAD_TIMING_STACK.peekLast();
+                start = System.nanoTime();
+            }
+            MAIN_THREAD_TIMING_STACK.addLast(this);
         }
-        TIMING_STACK.addLast(this);
+    
         return this;
     }
 
@@ -113,6 +178,8 @@ class TimingHandler implements Timing {
         if (!enabled || timingDepth <= 0 || start == 0 || !Bukkit.isPrimaryThread()) {
             return;
         }
+        
+        if(!Bukkit.getServer().isPrimaryThreadNotWorldThread()) return;
 
         popTimingStack();
         if (--timingDepth == 0) {
@@ -121,22 +188,52 @@ class TimingHandler implements Timing {
             start = 0;
         }
     }
-
-    private void popTimingStack() {
+    
+    
+    public static synchronized void initializeWorldTiming(){
+        WORLD_PARENT_TIMING = MAIN_THREAD_TIMING_STACK.peekLast();
+    }
+    
+    public static void clearWorldTimings(){
+        WORLD_THREAD_TIMING_STACK.clear();
+        WORLD_PARENT_TIMING = null;
+    }
+    
+    protected void popTimingStack() {
         TimingHandler last;
-        while ((last = TIMING_STACK.removeLast()) != this) {
-            last.timingDepth = 0;
-            if ("Minecraft".equalsIgnoreCase(last.identifier.group)) {
-                Logger.getGlobal().log(Level.SEVERE, "TIMING_STACK_CORRUPTION - Look above this for any errors and report this to Paper unless it has a plugin in the stack trace (" + last.identifier + " did not stopTiming)");
-            } else {
-                Logger.getGlobal().log(Level.SEVERE, "TIMING_STACK_CORRUPTION - Report this to the plugin " + last.identifier.group + " (Look for errors above this in the logs) (" + last.identifier + " did not stopTiming)", new Throwable());
+        
+        if(Bukkit.getServer().isPrimaryThreadNotWorldThread()) {
+            while ((last = MAIN_THREAD_TIMING_STACK.removeLast()) != this) {
+                last.timingDepth = 0;
+                if ("Minecraft".equalsIgnoreCase(last.identifier.group)) {
+                    Logger.getGlobal().log(Level.SEVERE, "TIMING_STACK_CORRUPTION - Look above this for any errors and report this to Paper unless it has a plugin in the stack trace (" + last.identifier + " did not stopTiming)");
+                } else {
+                    Logger.getGlobal().log(Level.SEVERE, "TIMING_STACK_CORRUPTION - Report this to the plugin " + last.identifier.group + " (Look for errors above this in the logs) (" + last.identifier + " did not stopTiming)", new Throwable());
+                }
+                
+                boolean found = MAIN_THREAD_TIMING_STACK.contains(this);
+                if (!found) {
+                    // We aren't even in the stack... Don't pop everything
+                    MAIN_THREAD_TIMING_STACK.addLast(last);
+                    break;
+                }
             }
-
-            boolean found = TIMING_STACK.contains(this);
-            if (!found) {
-                // We aren't even in the stack... Don't pop everything
-                TIMING_STACK.addLast(last);
-                break;
+        } else {
+            Deque<TimingHandler> timingHandlers = WORLD_THREAD_TIMING_STACK.computeIfAbsent(Thread.currentThread(), k -> new ArrayDeque<>());
+            while ((last = timingHandlers.removeLast()) != this) {
+                last.timingDepth = 0;
+                if ("Minecraft".equalsIgnoreCase(last.identifier.group)) {
+                    Logger.getGlobal().log(Level.SEVERE, "TIMING_STACK_CORRUPTION - Look above this for any errors and report this to Paper unless it has a plugin in the stack trace (" + last.identifier + " did not stopTiming)");
+                } else {
+                    Logger.getGlobal().log(Level.SEVERE, "TIMING_STACK_CORRUPTION - Report this to the plugin " + last.identifier.group + " (Look for errors above this in the logs) (" + last.identifier + " did not stopTiming)", new Throwable());
+                }
+                
+                boolean found = timingHandlers.contains(this);
+                if (!found) {
+                    // We aren't even in the stack... Don't pop everything
+                    timingHandlers.addLast(last);
+                    break;
+                }
             }
         }
     }
@@ -148,7 +245,7 @@ class TimingHandler implements Timing {
 
     void addDiff(long diff, @Nullable TimingHandler parent) {
         if (parent != null) {
-            parent.children.get(id).add(diff);
+            parent.children.computeIfAbsent(id, TimingData::new).add(diff);
         }
 
         record.add(diff);
@@ -159,7 +256,7 @@ class TimingHandler implements Timing {
         }
         if (groupHandler != null) {
             groupHandler.addDiff(diff, parent);
-            groupHandler.children.get(id).add(diff);
+            groupHandler.children.computeIfAbsent(id, TimingData::new).add(diff);
         }
     }
 
diff --git a/src/main/java/co/aikar/timings/Timings.java b/src/main/java/co/aikar/timings/Timings.java
index da76e1aaee1dee794e38ddd4e0a28e0071e90bbf..9cac6b1a1a4395766f3e046b5c3ea98dbebabdcd 100644
--- a/src/main/java/co/aikar/timings/Timings.java
+++ b/src/main/java/co/aikar/timings/Timings.java
@@ -293,4 +293,31 @@ public final class Timings {
     static TimingHandler ofSafe(@Nullable String groupName, @NotNull String name, @Nullable Timing groupHandler) {
         return TimingsManager.getHandler(groupName, name, groupHandler);
     }
+    
+    
+    
+    
+    @NotNull
+    public static TimingHandler ofSafeW(@NotNull String name) {
+        return ofSafeW(null, name, null);
+    }
+    
+    @NotNull
+    static Timing ofSafeW(@Nullable Plugin plugin, @NotNull String name) {
+        Timing pluginHandler = null;
+        if (plugin != null) {
+            pluginHandler = ofSafeW(plugin.getName(), "Combined Total", TimingsManager.PLUGIN_GROUP_HANDLER);
+        }
+        return ofSafeW(plugin != null ? plugin.getName() : "Minecraft - Invalid Plugin", name, pluginHandler);
+    }
+    
+    @NotNull
+    static TimingHandler ofSafeW(@NotNull String name, @Nullable Timing groupHandler) {
+        return ofSafeW(null, name, groupHandler);
+    }
+    
+    @NotNull
+    static TimingHandler ofSafeW(@Nullable String groupName, @NotNull String name, @Nullable Timing groupHandler) {
+        return TimingsManager.getHandlerW(groupName, name, groupHandler);
+    }
 }
diff --git a/src/main/java/co/aikar/timings/TimingsManager.java b/src/main/java/co/aikar/timings/TimingsManager.java
index a92925d41110226f7fda055b71ce7be60eedd038..7fda02259ea30bf570272ec94a26240778079d86 100644
--- a/src/main/java/co/aikar/timings/TimingsManager.java
+++ b/src/main/java/co/aikar/timings/TimingsManager.java
@@ -40,9 +40,7 @@ import org.jetbrains.annotations.NotNull;
 import org.jetbrains.annotations.Nullable;
 
 public final class TimingsManager {
-    static final Map<TimingIdentifier, TimingHandler> TIMING_MAP = LoadingMap.of(
-        new ConcurrentHashMap<>(4096, .5F), TimingHandler::new
-    );
+    static final Map<TimingIdentifier, TimingHandler> TIMING_MAP = new ConcurrentHashMap<>(4096, .5F);
     public static final FullServerTickHandler FULL_SERVER_TICK = new FullServerTickHandler();
     public static final TimingHandler TIMINGS_TICK = Timings.ofSafe("Timings Tick", FULL_SERVER_TICK);
     public static final Timing PLUGIN_GROUP_HANDLER = Timings.ofSafe("Plugins");
@@ -129,10 +127,15 @@ public final class TimingsManager {
         TimingHistory.resetTicks(true);
         historyStart = System.currentTimeMillis();
     }
-
+    
     @NotNull
     static TimingHandler getHandler(@Nullable String group, @NotNull String name, @Nullable Timing parent) {
-        return TIMING_MAP.get(new TimingIdentifier(group, name, parent));
+        return TIMING_MAP.computeIfAbsent(new TimingIdentifier(group, name, parent), TimingHandler::new);
+    }
+    
+    @NotNull
+    static TimingHandler getHandlerW(@Nullable String group, @NotNull String name, @Nullable Timing parent) {
+        return TIMING_MAP.computeIfAbsent(new TimingIdentifier(group, name, parent), TimingHandler.WorldTiming::new);
     }
 
 
diff --git a/src/main/java/org/bukkit/Server.java b/src/main/java/org/bukkit/Server.java
index 1db87711dd9b67bcba42e731c8c1a81502abf56c..cd1fc7f117ce300a44102957d7718d5fc6bbeae0 100644
--- a/src/main/java/org/bukkit/Server.java
+++ b/src/main/java/org/bukkit/Server.java
@@ -1259,6 +1259,8 @@ public interface Server extends PluginMessageRecipient, net.kyori.adventure.audi
      *     false otherwise
      */
     boolean isPrimaryThread();
+    
+    boolean isPrimaryThreadNotWorldThread();
 
     // Paper start
     /**
diff --git a/src/main/java/org/bukkit/plugin/SimplePluginManager.java b/src/main/java/org/bukkit/plugin/SimplePluginManager.java
index ebc3dbe22d11c70559b3fd65579eacefaba327d3..f6b0fd86d998c1424ca126e276c3b4854f1ebad9 100644
--- a/src/main/java/org/bukkit/plugin/SimplePluginManager.java
+++ b/src/main/java/org/bukkit/plugin/SimplePluginManager.java
@@ -20,6 +20,7 @@ import java.util.List;
 import java.util.Map;
 import java.util.Set;
 import java.util.WeakHashMap;
+import java.util.concurrent.locks.ReentrantLock;
 import java.util.logging.Level;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
@@ -61,6 +62,8 @@ public final class SimplePluginManager implements PluginManager {
     private final Map<Boolean, Map<Permissible, Boolean>> defSubs = new HashMap<Boolean, Map<Permissible, Boolean>>();
     private boolean useTimings = false;
     private File pluginsDirectory; public @Nullable File pluginsDirectory() { return this.pluginsDirectory; } // Paper
+    
+    private final ReentrantLock EVENT_LOCK = new ReentrantLock(true); // Chiyogami
 
     public SimplePluginManager(@NotNull Server instance, @NotNull SimpleCommandMap commandMap) {
         server = instance;
@@ -614,32 +617,47 @@ public final class SimplePluginManager implements PluginManager {
         // Paper - replace callEvent by merging to below method
         if (event.isAsynchronous() && server.isPrimaryThread()) {
             throw new IllegalStateException(event.getEventName() + " may only be triggered asynchronously.");
-        } else if (!event.isAsynchronous() && !server.isPrimaryThread() && !server.isStopping() ) {
+        } else if (!event.isAsynchronous() && !server.isPrimaryThread() && !server.isStopping()) {
             throw new IllegalStateException(event.getEventName() + " may only be triggered synchronously.");
         }
-
+    
+        boolean isSync = !event.isAsynchronous();
+    
+        if(isSync && !server.isPrimaryThreadNotWorldThread()){
+            EVENT_LOCK.lock();
+            try{
+                runEvent(event);
+            } finally {
+                EVENT_LOCK.unlock();
+            }
+        }else{
+            runEvent(event);
+        }
+    }
+    
+    private void runEvent(Event event){
         HandlerList handlers = event.getHandlers();
         RegisteredListener[] listeners = handlers.getRegisteredListeners();
-
+    
         for (RegisteredListener registration : listeners) {
             if (!registration.getPlugin().isEnabled()) {
                 continue;
             }
-
+        
             try {
                 registration.callEvent(event);
             } catch (AuthorNagException ex) {
                 Plugin plugin = registration.getPlugin();
-
+            
                 if (plugin.isNaggable()) {
                     plugin.setNaggable(false);
-
+                
                     server.getLogger().log(Level.SEVERE, String.format(
-                            "Nag author(s): '%s' of '%s' about the following: %s",
-                            plugin.getDescription().getAuthors(),
-                            plugin.getDescription().getFullName(),
-                            ex.getMessage()
-                            ));
+                        "Nag author(s): '%s' of '%s' about the following: %s",
+                        plugin.getDescription().getAuthors(),
+                        plugin.getDescription().getFullName(),
+                        ex.getMessage()
+                    ));
                 }
             } catch (Throwable ex) {
                 // Paper start - error reporting
