diff --strip-trailing-cr -urN Original/Paper-Server/src/main/java/io/papermc/paper/util/CachedLists.java Chiyogami/Paper-Server/src/main/java/io/papermc/paper/util/CachedLists.java
--- Original/Paper-Server/src/main/java/io/papermc/paper/util/CachedLists.java	2021-09-23 16:59:22.804500100 +0900
+++ Chiyogami/Paper-Server/src/main/java/io/papermc/paper/util/CachedLists.java	2021-09-23 21:10:14.737204000 +0900
@@ -5,14 +5,15 @@
 import org.bukkit.Bukkit;
 import org.bukkit.craftbukkit.util.UnsafeList;
 import java.util.List;
+import java.util.concurrent.CopyOnWriteArrayList;
 
 public final class CachedLists {
 
     // Paper start - optimise collisions
-    static final UnsafeList<AABB> TEMP_COLLISION_LIST = new UnsafeList<>(1024);
+    static final List<AABB> TEMP_COLLISION_LIST = new CopyOnWriteArrayList<>();
     static boolean tempCollisionListInUse;
 
-    public static UnsafeList<AABB> getTempCollisionList() {
+    public static List<AABB> getTempCollisionList() {
         if (!Bukkit.isPrimaryThread() || tempCollisionListInUse) {
             return new UnsafeList<>(16);
         }
@@ -24,14 +25,15 @@
         if (list != TEMP_COLLISION_LIST) {
             return;
         }
-        ((UnsafeList)list).setSize(0);
+        //((UnsafeList)list).setSize(0);
+        TEMP_COLLISION_LIST.clear();
         tempCollisionListInUse = false;
     }
 
-    static final UnsafeList<Entity> TEMP_GET_ENTITIES_LIST = new UnsafeList<>(1024);
+    static final List<Entity> TEMP_GET_ENTITIES_LIST = new CopyOnWriteArrayList<>();
     static boolean tempGetEntitiesListInUse;
 
-    public static UnsafeList<Entity> getTempGetEntitiesList() {
+    public static List<Entity> getTempGetEntitiesList() {
         if (!Bukkit.isPrimaryThread() || tempGetEntitiesListInUse) {
             return new UnsafeList<>(16);
         }
@@ -43,15 +45,18 @@
         if (list != TEMP_GET_ENTITIES_LIST) {
             return;
         }
-        ((UnsafeList)list).setSize(0);
+        //((UnsafeList)list).setSize(0);
+        TEMP_GET_ENTITIES_LIST.clear();
         tempGetEntitiesListInUse = false;
     }
     // Paper end - optimise collisions
 
     public static void reset() {
         // Paper start - optimise collisions
-        TEMP_COLLISION_LIST.completeReset();
-        TEMP_GET_ENTITIES_LIST.completeReset();
+        //TEMP_COLLISION_LIST.completeReset();
+        TEMP_COLLISION_LIST.clear();
+        TEMP_GET_ENTITIES_LIST.clear();
+        //TEMP_GET_ENTITIES_LIST.completeReset();
         // Paper end - optimise collisions
     }
 }
diff --strip-trailing-cr -urN Original/Paper-Server/src/main/java/io/papermc/paper/util/CollisionUtil.java Chiyogami/Paper-Server/src/main/java/io/papermc/paper/util/CollisionUtil.java
--- Original/Paper-Server/src/main/java/io/papermc/paper/util/CollisionUtil.java	2021-09-23 16:59:22.807498300 +0900
+++ Chiyogami/Paper-Server/src/main/java/io/papermc/paper/util/CollisionUtil.java	2021-09-23 22:03:37.566717100 +0900
@@ -213,27 +213,36 @@
     }
 
     public static double performCollisionsX(final AABB currentBoundingBox, double value, final List<AABB> potentialCollisions) {
-        for (int i = 0, len = potentialCollisions.size(); i < len; ++i) {
+        /*for (int i = 0, len = potentialCollisions.size(); i < len; ++i) {
             final AABB target = potentialCollisions.get(i);
             value = collideX(target, currentBoundingBox, value);
+        }*/
+        for(AABB target : potentialCollisions){
+            value = collideX(target, currentBoundingBox, value);
         }
 
         return value;
     }
 
     public static double performCollisionsY(final AABB currentBoundingBox, double value, final List<AABB> potentialCollisions) {
-        for (int i = 0, len = potentialCollisions.size(); i < len; ++i) {
+        /*for (int i = 0, len = potentialCollisions.size(); i < len; ++i) {
             final AABB target = potentialCollisions.get(i);
             value = collideY(target, currentBoundingBox, value);
+        }*/
+        for(AABB target : potentialCollisions){
+            value = collideY(target, currentBoundingBox, value);
         }
 
         return value;
     }
 
     public static double performCollisionsZ(final AABB currentBoundingBox, double value, final List<AABB> potentialCollisions) {
-        for (int i = 0, len = potentialCollisions.size(); i < len; ++i) {
+        /*for (int i = 0, len = potentialCollisions.size(); i < len; ++i) {
             final AABB target = potentialCollisions.get(i);
             value = collideZ(target, currentBoundingBox, value);
+        }*/
+        for(AABB target : potentialCollisions){
+            value = collideZ(target, currentBoundingBox, value);
         }
 
         return value;
diff --strip-trailing-cr -urN Original/Paper-Server/src/main/java/net/minecraft/server/level/ChunkMap.java Chiyogami/Paper-Server/src/main/java/net/minecraft/server/level/ChunkMap.java
--- Original/Paper-Server/src/main/java/net/minecraft/server/level/ChunkMap.java	2021-09-23 16:59:24.663502500 +0900
+++ Chiyogami/Paper-Server/src/main/java/net/minecraft/server/level/ChunkMap.java	2021-09-23 19:32:25.440541000 +0900
@@ -34,12 +34,8 @@
 import java.util.Optional;
 import java.util.Queue;
 import java.util.Set;
-import java.util.concurrent.CancellationException;
+import java.util.concurrent.*;
 import java.util.UUID; // Paper
-import java.util.concurrent.CompletableFuture;
-import java.util.concurrent.CompletionException;
-import java.util.concurrent.CompletionStage;
-import java.util.concurrent.Executor;
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.function.BooleanSupplier;
 import java.util.function.Consumer;
@@ -104,6 +100,7 @@
 
 import org.bukkit.entity.Player; // CraftBukkit
 import it.unimi.dsi.fastutil.objects.ReferenceOpenHashSet; // Paper
+import org.spigotmc.AsyncCatcher;
 
 public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider {
 
@@ -120,7 +117,7 @@
     // Paper end - Don't copy
     public static final int FORCED_TICKET_LEVEL = 31;
     // Paper - Don't copy
-    private final Long2ObjectLinkedOpenHashMap<ChunkHolder> pendingUnloads;
+    private final Map<Long, ChunkHolder> pendingUnloads;
     public final LongSet entitiesInLevel;
     public final ServerLevel level;
     private final ThreadedLevelLightEngine lightEngine;
@@ -147,7 +144,7 @@
     public final StructureManager structureManager;
     private final String storageName;
     private final PlayerMap playerMap;
-    public final Int2ObjectMap<ChunkMap.TrackedEntity> entityMap;
+    public final Map<Integer, ChunkMap.TrackedEntity> entityMap;
     private final Long2ByteMap chunkTypeCache;
     private final Queue<Runnable> unloadQueue;
     int viewDistance;
@@ -395,12 +392,12 @@
     public ChunkMap(ServerLevel world, LevelStorageSource.LevelStorageAccess session, DataFixer dataFixer, StructureManager structureManager, Executor executor, BlockableEventLoop<Runnable> mainThreadExecutor, LightChunkGetter chunkProvider, ChunkGenerator chunkGenerator, ChunkProgressListener worldGenerationProgressListener, ChunkStatusUpdateListener chunkStatusChangeListener, Supplier<DimensionDataStorage> persistentStateManagerFactory, int viewDistance, boolean dsync) {
         super(new File(session.getDimensionPath(world.dimension()), "region"), dataFixer, dsync);
         // Paper - don't copy
-        this.pendingUnloads = new Long2ObjectLinkedOpenHashMap();
+        this.pendingUnloads = new ConcurrentHashMap<>();
         this.entitiesInLevel = new LongOpenHashSet();
         this.toDrop = new LongOpenHashSet();
         this.tickingGenerated = new AtomicInteger();
         this.playerMap = new PlayerMap();
-        this.entityMap = new Int2ObjectOpenHashMap();
+        this.entityMap = new ConcurrentHashMap<>();
         this.chunkTypeCache = new Long2ByteOpenHashMap();
         this.unloadQueue = new com.destroystokyo.paper.utils.CachedSizeConcurrentLinkedQueue<>(); // Paper - need constant-time size()
         this.structureManager = structureManager;
@@ -714,7 +711,7 @@
     @Nullable
     public ChunkHolder getVisibleChunkIfPresent(long pos) {
         // Paper start - Don't copy
-        if (Thread.currentThread() == this.level.thread) {
+        if (!AsyncCatcher.isAsync()) {
             return this.updatingChunks.getVisible(pos);
         }
         return this.updatingChunks.getVisibleAsync(pos);
@@ -2001,7 +1998,7 @@
                         ServerPlayer entityplayer = (ServerPlayer) entity;
 
                         this.updatePlayerStatus(entityplayer, true);
-                        ObjectIterator objectiterator = this.entityMap.values().iterator();
+                        Iterator objectiterator = this.entityMap.values().iterator();
 
                         while (objectiterator.hasNext()) {
                             ChunkMap.TrackedEntity playerchunkmap_entitytracker1 = (ChunkMap.TrackedEntity) objectiterator.next();
@@ -2023,7 +2020,7 @@
             ServerPlayer entityplayer = (ServerPlayer) entity;
 
             this.updatePlayerStatus(entityplayer, false);
-            ObjectIterator objectiterator = this.entityMap.values().iterator();
+            Iterator objectiterator = this.entityMap.values().iterator();
 
             while (objectiterator.hasNext()) {
                 ChunkMap.TrackedEntity playerchunkmap_entitytracker = (ChunkMap.TrackedEntity) objectiterator.next();
@@ -2075,7 +2072,7 @@
         List<ServerPlayer> list1 = this.level.players();
 
         ChunkMap.TrackedEntity playerchunkmap_entitytracker;
-        ObjectIterator objectiterator;
+        Iterator objectiterator;
         level.timings.tracker1.startTiming(); // Paper
 
         for (objectiterator = this.entityMap.values().iterator(); objectiterator.hasNext(); playerchunkmap_entitytracker.serverEntity.sendChanges()) {
diff --strip-trailing-cr -urN Original/Paper-Server/src/main/java/net/minecraft/server/level/DistanceManager.java Chiyogami/Paper-Server/src/main/java/net/minecraft/server/level/DistanceManager.java
--- Original/Paper-Server/src/main/java/net/minecraft/server/level/DistanceManager.java	2021-09-23 16:59:23.391286800 +0900
+++ Chiyogami/Paper-Server/src/main/java/net/minecraft/server/level/DistanceManager.java	2021-09-23 23:59:13.447275500 +0900
@@ -22,10 +22,13 @@
 import java.io.IOException;
 import java.nio.charset.StandardCharsets;
 import java.util.Iterator;
+import java.util.Map;
 import java.util.Objects;
 import java.util.Set;
 import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.Executor;
+import java.util.concurrent.locks.ReentrantLock;
 import javax.annotation.Nullable;
 import net.minecraft.core.SectionPos;
 import net.minecraft.util.SortedArraySet;
@@ -44,7 +47,7 @@
     static final int PLAYER_TICKET_LEVEL = 33 + ChunkStatus.getDistance(ChunkStatus.FULL) - 2;
     private static final int INITIAL_TICKET_LIST_CAPACITY = 4;
     final Long2ObjectMap<ObjectSet<ServerPlayer>> playersPerChunk = new Long2ObjectOpenHashMap();
-    public final Long2ObjectOpenHashMap<SortedArraySet<Ticket<?>>> tickets = new Long2ObjectOpenHashMap();
+    public final Map<Long, SortedArraySet<Ticket<?>>> tickets = new ConcurrentHashMap<>();
     //private final DistanceManager.ChunkTicketTracker ticketTracker = new DistanceManager.ChunkTicketTracker(); // Paper - replace ticket level propagator
     public static final int MOB_SPAWN_RANGE = 8; // private final ChunkMapDistance.b f = new ChunkMapDistance.b(8); // Paper - no longer used
     //private final DistanceManager.PlayerTicketTracker playerTicketManager = new DistanceManager.PlayerTicketTracker(33); // Paper - no longer used
@@ -120,15 +123,15 @@
 
     protected void purgeStaleTickets() {
         ++this.ticketTickCounter;
-        ObjectIterator objectiterator = this.tickets.long2ObjectEntrySet().fastIterator();
+        Iterator objectiterator = this.tickets.entrySet().iterator();
 
         while (objectiterator.hasNext()) {
-            Entry<SortedArraySet<Ticket<?>>> entry = (Entry) objectiterator.next();
+            Map.Entry<Long, SortedArraySet<Ticket<?>>> entry = (Map.Entry) objectiterator.next();
 
             if ((entry.getValue()).removeIf((ticket) -> { // CraftBukkit - decompile error
                 return ticket.timedOut(this.ticketTickCounter);
             })) {
-                this.updateTicketLevel(entry.getLongKey(), getTicketLevelAt(entry.getValue())); // Paper - replace ticket level propagator
+                this.updateTicketLevel(entry.getKey(), getTicketLevelAt(entry.getValue())); // Paper - replace ticket level propagator
             }
 
             if (((SortedArraySet) entry.getValue()).isEmpty()) {
@@ -542,11 +545,11 @@
             FileOutputStream fileoutputstream = new FileOutputStream(new File(s));
 
             try {
-                ObjectIterator objectiterator = this.tickets.long2ObjectEntrySet().iterator();
+                Iterator objectiterator = this.tickets.entrySet().iterator();
 
                 while (objectiterator.hasNext()) {
-                    Entry<SortedArraySet<Ticket<?>>> entry = (Entry) objectiterator.next();
-                    ChunkPos chunkcoordintpair = new ChunkPos(entry.getLongKey());
+                    Map.Entry<Long, SortedArraySet<Ticket<?>>> entry = (Map.Entry) objectiterator.next();
+                    ChunkPos chunkcoordintpair = new ChunkPos(entry.getKey());
                     Iterator iterator = ((SortedArraySet) entry.getValue()).iterator();
 
                     while (iterator.hasNext()) {
@@ -576,12 +579,12 @@
     public <T> void removeAllTicketsFor(TicketType<T> ticketType, int ticketLevel, T ticketIdentifier) {
         Ticket<T> target = new Ticket<>(ticketType, ticketLevel, ticketIdentifier);
 
-        for (java.util.Iterator<Entry<SortedArraySet<Ticket<?>>>> iterator = this.tickets.long2ObjectEntrySet().fastIterator(); iterator.hasNext();) {
-            Entry<SortedArraySet<Ticket<?>>> entry = iterator.next();
+        for (java.util.Iterator<Map.Entry<Long, SortedArraySet<Ticket<?>>>> iterator = this.tickets.entrySet().iterator(); iterator.hasNext();) {
+            Map.Entry<Long, SortedArraySet<Ticket<?>>> entry = iterator.next();
             SortedArraySet<Ticket<?>> tickets = entry.getValue();
             if (tickets.remove(target)) {
                 // copied from removeTicket
-                this.updateTicketLevel(entry.getLongKey(), getTicketLevelAt(tickets)); // Paper - replace ticket level propagator
+                this.updateTicketLevel(entry.getKey(), getTicketLevelAt(tickets)); // Paper - replace ticket level propagator
 
                 // can't use entry after it's removed
                 if (tickets.isEmpty()) {
@@ -593,6 +596,8 @@
     // CraftBukkit end
 
     private class ChunkTicketTracker extends ChunkTracker {
+    
+        private final ReentrantLock LOCK = new ReentrantLock(true);
 
         public ChunkTicketTracker() {
             super(ChunkMap.MAX_CHUNK_DISTANCE + 2, 16, 256);
@@ -600,40 +605,60 @@
 
         @Override
         protected int getLevelFromSource(long id) {
-            SortedArraySet<Ticket<?>> arraysetsorted = (SortedArraySet) DistanceManager.this.tickets.get(id);
-
-            return arraysetsorted == null ? Integer.MAX_VALUE : (arraysetsorted.isEmpty() ? Integer.MAX_VALUE : ((Ticket) arraysetsorted.first()).getTicketLevel());
+            LOCK.lock();
+            try {
+                SortedArraySet<Ticket<?>> arraysetsorted = (SortedArraySet) DistanceManager.this.tickets.get(id);
+    
+                return arraysetsorted == null ? Integer.MAX_VALUE : (arraysetsorted.isEmpty() ? Integer.MAX_VALUE : ((Ticket) arraysetsorted.first()).getTicketLevel());
+            } finally {
+                LOCK.unlock();
+            }
         }
 
         @Override
         protected int getLevel(long id) {
-            if (!DistanceManager.this.isChunkToRemove(id)) {
-                ChunkHolder playerchunk = DistanceManager.this.getChunk(id);
-
-                if (playerchunk != null) {
-                    return playerchunk.getTicketLevel();
+            LOCK.lock();
+            try {
+                if (!DistanceManager.this.isChunkToRemove(id)) {
+                    ChunkHolder playerchunk = DistanceManager.this.getChunk(id);
+        
+                    if (playerchunk != null) {
+                        return playerchunk.getTicketLevel();
+                    }
                 }
+    
+                return ChunkMap.MAX_CHUNK_DISTANCE + 1;
+            } finally {
+                LOCK.unlock();
             }
-
-            return ChunkMap.MAX_CHUNK_DISTANCE + 1;
         }
 
         @Override
         protected void setLevel(long id, int level) {
-            ChunkHolder playerchunk = DistanceManager.this.getChunk(id);
-            int k = playerchunk == null ? ChunkMap.MAX_CHUNK_DISTANCE + 1 : playerchunk.getTicketLevel();
-
-            if (k != level) {
-                playerchunk = DistanceManager.this.updateChunkScheduling(id, level, playerchunk, k);
-                if (playerchunk != null) {
-                    DistanceManager.this.pendingChunkUpdates.add(playerchunk);
+            LOCK.lock();
+            try {
+                ChunkHolder playerchunk = DistanceManager.this.getChunk(id);
+                int k = playerchunk == null ? ChunkMap.MAX_CHUNK_DISTANCE + 1 : playerchunk.getTicketLevel();
+    
+                if (k != level) {
+                    playerchunk = DistanceManager.this.updateChunkScheduling(id, level, playerchunk, k);
+                    if (playerchunk != null) {
+                        DistanceManager.this.pendingChunkUpdates.add(playerchunk);
+                    }
+        
                 }
-
+            } finally {
+                LOCK.unlock();
             }
         }
 
         public int runDistanceUpdates(int distance) {
-            return this.runUpdates(distance);
+            LOCK.lock();
+            try {
+                return this.runUpdates(distance);
+            } finally {
+                LOCK.unlock();
+            }
         }
     }
 
diff --strip-trailing-cr -urN Original/Paper-Server/src/main/java/net/minecraft/server/level/ServerChunkCache.java Chiyogami/Paper-Server/src/main/java/net/minecraft/server/level/ServerChunkCache.java
--- Original/Paper-Server/src/main/java/net/minecraft/server/level/ServerChunkCache.java	2021-09-23 16:59:24.014872800 +0900
+++ Chiyogami/Paper-Server/src/main/java/net/minecraft/server/level/ServerChunkCache.java	2021-09-23 19:07:26.092678500 +0900
@@ -45,6 +45,7 @@
 import net.minecraft.world.level.storage.LevelData;
 import net.minecraft.world.level.storage.LevelStorageSource;
 import it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap; // Paper
+import org.spigotmc.AsyncCatcher;
 
 public class ServerChunkCache extends ChunkSource {
     public static final org.apache.logging.log4j.Logger LOGGER = org.apache.logging.log4j.LogManager.getLogger(); // Paper
@@ -142,7 +143,7 @@
     long chunkFutureAwaitCounter; // Paper - private -> package private
 
     public void getEntityTickingChunkAsync(int x, int z, java.util.function.Consumer<LevelChunk> onLoad) {
-        if (Thread.currentThread() != this.mainThread) {
+        if (AsyncCatcher.isAsync()) {
             this.mainThreadProcessor.execute(() -> {
                 ServerChunkCache.this.getEntityTickingChunkAsync(x, z, onLoad);
             });
@@ -152,7 +153,7 @@
     }
 
     public void getTickingChunkAsync(int x, int z, java.util.function.Consumer<LevelChunk> onLoad) {
-        if (Thread.currentThread() != this.mainThread) {
+        if (AsyncCatcher.isAsync()) {
             this.mainThreadProcessor.execute(() -> {
                 ServerChunkCache.this.getTickingChunkAsync(x, z, onLoad);
             });
@@ -162,7 +163,7 @@
     }
 
     public void getFullChunkAsync(int x, int z, java.util.function.Consumer<LevelChunk> onLoad) {
-        if (Thread.currentThread() != this.mainThread) {
+        if (AsyncCatcher.isAsync()) {
             this.mainThreadProcessor.execute(() -> {
                 ServerChunkCache.this.getFullChunkAsync(x, z, onLoad);
             });
@@ -172,7 +173,7 @@
     }
 
     private void getChunkFutureAsynchronously(int x, int z, int ticketLevel, Function<ChunkHolder, CompletableFuture<Either<LevelChunk, ChunkHolder.ChunkLoadingFailure>>> futureGet, java.util.function.Consumer<LevelChunk> onLoad) {
-        if (Thread.currentThread() != this.mainThread) {
+        if (AsyncCatcher.isAsync()) {
             throw new IllegalStateException();
         }
         ChunkPos chunkPos = new ChunkPos(x, z);
@@ -274,7 +275,7 @@
     void getChunkAtAsynchronously(int chunkX, int chunkZ, int ticketLevel,
                                   java.util.function.Function<ChunkHolder, CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>>> function,
                                   java.util.function.Consumer<ChunkAccess> consumer) {
-        if (Thread.currentThread() != this.mainThread) {
+        if (AsyncCatcher.isAsync()) {
             throw new IllegalStateException();
         }
 
@@ -471,7 +472,7 @@
     public LevelChunk getChunkAtIfLoadedImmediately(int x, int z) {
         long k = ChunkPos.asLong(x, z);
 
-        if (Thread.currentThread() == this.mainThread) {
+        if (!AsyncCatcher.isAsync()) {
             return this.getChunkAtIfLoadedMainThread(x, z);
         }
 
@@ -507,7 +508,7 @@
     private long asyncLoadSeqCounter;
 
     public CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> getChunkAtAsynchronously(int x, int z, boolean gen, boolean isUrgent) {
-        if (Thread.currentThread() != this.mainThread) {
+        if (AsyncCatcher.isAsync()) {
             CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> future = new CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>>();
             this.mainThreadProcessor.execute(() -> {
                 this.getChunkAtAsynchronously(x, z, gen, isUrgent).whenComplete((chunk, ex) -> {
@@ -636,7 +637,7 @@
     @Override
     public ChunkAccess getChunk(int x, int z, ChunkStatus leastStatus, boolean create) {
         final int x1 = x; final int z1 = z; // Paper - conflict on variable change
-        if (Thread.currentThread() != this.mainThread) {
+        if (AsyncCatcher.isAsync()) {
             return (ChunkAccess) CompletableFuture.supplyAsync(() -> {
                 return this.getChunk(x, z, leastStatus, create);
             }, this.mainThreadProcessor).join();
@@ -700,7 +701,7 @@
     @Nullable
     @Override
     public LevelChunk getChunkNow(int chunkX, int chunkZ) {
-        if (Thread.currentThread() != this.mainThread) {
+        if (AsyncCatcher.isAsync()) {
             return null;
         } else {
             return this.getChunkAtIfLoadedMainThread(chunkX, chunkZ); // Paper - optimise for loaded chunks
@@ -714,7 +715,7 @@
     }
 
     public CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> getChunkFuture(int chunkX, int chunkZ, ChunkStatus leastStatus, boolean create) {
-        boolean flag1 = Thread.currentThread() == this.mainThread;
+        boolean flag1 = !AsyncCatcher.isAsync();
         CompletableFuture completablefuture;
 
         if (flag1) {
diff --strip-trailing-cr -urN Original/Paper-Server/src/main/java/net/minecraft/server/level/ServerLevel.java Chiyogami/Paper-Server/src/main/java/net/minecraft/server/level/ServerLevel.java
--- Original/Paper-Server/src/main/java/net/minecraft/server/level/ServerLevel.java	2021-09-23 16:59:24.668499300 +0900
+++ Chiyogami/Paper-Server/src/main/java/net/minecraft/server/level/ServerLevel.java	2021-09-23 19:41:16.194079300 +0900
@@ -19,13 +19,9 @@
 import java.io.Writer;
 import java.nio.file.Files;
 import java.nio.file.Path;
-import java.util.Comparator;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Objects;
-import java.util.Optional;
-import java.util.Set;
-import java.util.UUID;
+import java.util.*;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.CopyOnWriteArrayList;
 import java.util.concurrent.Executor;
 import java.util.function.BooleanSupplier;
 import java.util.function.Function;
@@ -162,6 +158,7 @@
 import org.bukkit.event.world.TimeSkipEvent;
 // CraftBukkit end
 import it.unimi.dsi.fastutil.ints.IntArrayList; // Paper
+import org.spigotmc.AsyncCatcher;
 
 public class ServerLevel extends Level implements WorldGenLevel {
 
@@ -187,7 +184,7 @@
     private final List<CustomSpawner> customSpawners;
     @Nullable
     private final EndDragonFight dragonFight;
-    final Int2ObjectMap<EnderDragonPart> dragonParts;
+    final Map<Integer, EnderDragonPart> dragonParts;
     private final StructureFeatureManager structureFeatureManager;
     private final boolean tickTime;
     // Paper start - execute chunk tasks mid tick
@@ -240,7 +237,7 @@
 
     public final void loadChunksForMoveAsync(AABB axisalignedbb, double toX, double toZ,
                                              java.util.function.Consumer<List<net.minecraft.world.level.chunk.ChunkAccess>> onLoad) {
-        if (Thread.currentThread() != this.thread) {
+        if (AsyncCatcher.isAsync()) {
             this.getChunkSource().mainThreadProcessor.execute(() -> {
                 this.loadChunksForMoveAsync(axisalignedbb, toX, toZ, onLoad);
             });
@@ -478,7 +475,7 @@
         this.convertable = convertable_conversionsession;
         this.uuid = WorldUUID.getUUID(convertable_conversionsession.levelPath.toFile());
         // CraftBukkit end
-        this.players = Lists.newArrayList();
+        this.players = new CopyOnWriteArrayList<>();
         this.entityTickList = new EntityTickList();
         Predicate<Block> predicate = (block) -> { // CraftBukkit - decompile eror
             return block == null || block.defaultBlockState().isAir();
@@ -499,9 +496,9 @@
             this.blockTicks = new ServerTickList<>(this, predicate, Registry.BLOCK::getKey, this::tickBlock, "Blocks"); // CraftBukkit - decompile error // Paper - Timings & copied from above
         this.liquidTicks = new ServerTickList<>(this, predicate2, Registry.FLUID::getKey, this::tickLiquid, "Fluids"); // CraftBukkit - decompile error // Paper - Timings
         }
-        this.navigatingMobs = new ObjectOpenHashSet();
+        this.navigatingMobs = ConcurrentHashMap.newKeySet();
         this.blockEvents = new ObjectLinkedOpenHashSet();
-        this.dragonParts = new Int2ObjectOpenHashMap();
+        this.dragonParts = new ConcurrentHashMap<>();
         this.tickTime = flag1;
         this.server = minecraftserver;
         this.customSpawners = list;
diff --strip-trailing-cr -urN Original/Paper-Server/src/main/java/net/minecraft/server/MCUtil.java Chiyogami/Paper-Server/src/main/java/net/minecraft/server/MCUtil.java
--- Original/Paper-Server/src/main/java/net/minecraft/server/MCUtil.java	2021-09-23 16:59:24.591542900 +0900
+++ Chiyogami/Paper-Server/src/main/java/net/minecraft/server/MCUtil.java	2021-09-23 18:27:37.151415700 +0900
@@ -320,7 +320,7 @@
      * @return
      */
     public static void ensureMain(String reason, Runnable run) {
-        if (AsyncCatcher.enabled && Thread.currentThread() != MinecraftServer.getServer().serverThread) {
+        if (AsyncCatcher.enabled && AsyncCatcher.isAsync()) {
             if (reason != null) {
                 new IllegalStateException("Asynchronous " + reason + "!").printStackTrace();
             }
@@ -345,7 +345,7 @@
      * @return
      */
     public static <T> T ensureMain(String reason, Supplier<T> run) {
-        if (AsyncCatcher.enabled && Thread.currentThread() != MinecraftServer.getServer().serverThread) {
+        if (AsyncCatcher.enabled && AsyncCatcher.isAsync()) {
             if (reason != null) {
                 new IllegalStateException("Asynchronous " + reason + "! Blocking thread until it returns ").printStackTrace();
             }
diff --strip-trailing-cr -urN Original/Paper-Server/src/main/java/net/minecraft/server/MinecraftServer.java Chiyogami/Paper-Server/src/main/java/net/minecraft/server/MinecraftServer.java
--- Original/Paper-Server/src/main/java/net/minecraft/server/MinecraftServer.java	2021-09-23 16:59:22.976850500 +0900
+++ Chiyogami/Paper-Server/src/main/java/net/minecraft/server/MinecraftServer.java	2021-09-23 21:32:15.891449500 +0900
@@ -31,22 +31,10 @@
 import java.nio.file.Path;
 import java.security.KeyPair;
 import java.text.SimpleDateFormat;
-import java.util.Arrays;
-import java.util.Base64;
-import java.util.Collection;
-import java.util.Collections;
-import java.util.Comparator;
-import java.util.Date;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Map;
+import java.util.*;
 import java.util.Map.Entry;
-import java.util.Objects;
-import java.util.Optional;
-import java.util.Random;
-import java.util.Set;
-import java.util.UUID;
 import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.Executor;
 import java.util.concurrent.atomic.AtomicReference;
 import java.util.function.BooleanSupplier;
@@ -188,6 +176,8 @@
 
 import co.aikar.timings.MinecraftTimings; // Paper
 import org.spigotmc.SlackActivityAccountant; // Spigot
+import world.chiyogami.chiyogamilib.monitor.PerformanceMonitor;
+import world.chiyogami.chiyogamilib.scheduler.WorldThreadRunnable;
 
 public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTask> implements SnooperPopulator, CommandSource, AutoCloseable {
 
@@ -309,6 +299,8 @@
     public final SlackActivityAccountant slackActivityAccountant = new SlackActivityAccountant();
     // Spigot end
     public static long currentTickLong = 0L; // Paper
+    
+    public final Map<org.bukkit.World, Thread> worldServerThreads = new HashMap<>(); // Chiyogami
 
     public volatile Thread shutdownThread; // Paper
     public volatile boolean abnormalExit = false; // Paper
@@ -361,6 +353,7 @@
 
     public final void executeMidTickTasks() {
         org.spigotmc.AsyncCatcher.catchOp("mid tick chunk task execution");
+        if(Thread.currentThread() != this.serverThread) return;
         long startTime = System.nanoTime();
         if ((startTime - lastMidTickExecute) <= CHUNK_TASK_QUEUE_BACKOFF_MIN_TIME || (startTime - lastMidTickExecuteFailure) <= TASK_EXECUTION_FAILURE_BACKOFF) {
             // it's shown to be bad to constantly hit the queue (chunk loads slow to a crawl), even if no tasks are executed.
@@ -1458,6 +1451,7 @@
     public void onServerExit() {}
 
     public void tickServer(BooleanSupplier shouldKeepTicking) {
+        long fullServerTickNanoTime = System.nanoTime(); // Chiyogami
         co.aikar.timings.TimingsManager.FULL_SERVER_TICK.startTiming(); // Paper
         this.slackActivityAccountant.tickStarted(); // Spigot
         long i = Util.getNanos();
@@ -1552,6 +1546,7 @@
         org.spigotmc.WatchdogThread.tick(); // Spigot
         this.slackActivityAccountant.tickEnded(l); // Spigot
         co.aikar.timings.TimingsManager.FULL_SERVER_TICK.stopTiming(); // Paper
+        PerformanceMonitor.setFullServerTickNanoTime(System.nanoTime() - fullServerTickNanoTime); // Chiyogami
     }
 
     public void tickChildren(BooleanSupplier shouldKeepTicking) {
@@ -1594,16 +1589,25 @@
         }
         // Paper end
         MinecraftTimings.timeUpdateTimer.stopTiming(); // Spigot // Paper
-
+    
+        long worldServerTickNanoTime = System.nanoTime();
+        Map<org.bukkit.World, Long> worldThreadTimeMap = new ConcurrentHashMap<>();
         while (iterator.hasNext()) {
             ServerLevel worldserver = (ServerLevel) iterator.next();
-            worldserver.hasPhysicsEvent =  org.bukkit.event.block.BlockPhysicsEvent.getHandlerList().getRegisteredListeners().length > 0; // Paper
-            worldserver.hasEntityMoveEvent =  io.papermc.paper.event.entity.EntityMoveEvent.getHandlerList().getRegisteredListeners().length > 0; // Paper
-            net.minecraft.world.level.block.entity.HopperBlockEntity.skipHopperEvents = worldserver.paperConfig.disableHopperMoveEvents || org.bukkit.event.inventory.InventoryMoveItemEvent.getHandlerList().getRegisteredListeners().length == 0; // Paper
-
-            this.profiler.push(() -> {
-                return worldserver + " " + worldserver.dimension().location();
-            });
+            
+            Thread worldServerThread = new Thread(() -> {
+                
+                long worldServerThreadNanoTime = System.nanoTime();
+    
+                WorldThreadRunnable.worldThreadHeartBeat(worldserver.getWorld(), currentTick);
+    
+                worldserver.hasPhysicsEvent =  org.bukkit.event.block.BlockPhysicsEvent.getHandlerList().getRegisteredListeners().length > 0; // Paper
+                worldserver.hasEntityMoveEvent =  io.papermc.paper.event.entity.EntityMoveEvent.getHandlerList().getRegisteredListeners().length > 0; // Paper
+                net.minecraft.world.level.block.entity.HopperBlockEntity.skipHopperEvents = worldserver.paperConfig.disableHopperMoveEvents || org.bukkit.event.inventory.InventoryMoveItemEvent.getHandlerList().getRegisteredListeners().length == 0; // Paper
+    
+                this.profiler.push(() -> {
+                    return worldserver + " " + worldserver.dimension().location();
+                });
             /* Drop global time updates
             if (this.tickCount % 20 == 0) {
                 this.profiler.enter("timeSync");
@@ -1611,37 +1615,63 @@
                 this.profiler.exit();
             }
             // CraftBukkit end */
-
-            this.profiler.push("tick");
-
-            try {
-                worldserver.timings.doTick.startTiming(); // Spigot
-                worldserver.tick(shouldKeepTicking);
-                // Paper start
-                for (final io.papermc.paper.chunk.SingleThreadChunkRegionManager regionManager : worldserver.getChunkSource().chunkMap.regionManagers) {
-                    regionManager.recalculateRegions();
-                }
-                // Paper end
-                worldserver.timings.doTick.stopTiming(); // Spigot
-            } catch (Throwable throwable) {
-                // Spigot Start
-                CrashReport crashreport;
+    
+                this.profiler.push("tick");
+    
                 try {
-                    crashreport = CrashReport.forThrowable(throwable, "Exception ticking world");
-                } catch (Throwable t) {
-                    if (throwable instanceof ThreadDeath) { throw (ThreadDeath)throwable; } // Paper
-                    throw new RuntimeException("Error generating crash report", t);
+                    worldserver.timings.doTick.startTiming(); // Spigot
+                    worldserver.tick(shouldKeepTicking);
+                    // Paper start
+                    for (final io.papermc.paper.chunk.SingleThreadChunkRegionManager regionManager : worldserver.getChunkSource().chunkMap.regionManagers) {
+                        regionManager.recalculateRegions();
+                    }
+                    // Paper end
+                    worldserver.timings.doTick.stopTiming(); // Spigot
+                } catch (Throwable throwable) {
+                    // Spigot Start
+                    CrashReport crashreport;
+                    try {
+                        crashreport = CrashReport.forThrowable(throwable, "Exception ticking world");
+                    } catch (Throwable t) {
+                        if (throwable instanceof ThreadDeath) { throw (ThreadDeath)throwable; } // Paper
+                        throw new RuntimeException("Error generating crash report", t);
+                    }
+                    // Spigot End
+        
+                    worldserver.fillReportDetails(crashreport);
+                    throw new ReportedException(crashreport);
                 }
-                // Spigot End
-
-                worldserver.fillReportDetails(crashreport);
-                throw new ReportedException(crashreport);
+    
+                this.profiler.pop();
+                this.profiler.pop();
+                worldserver.explosionDensityCache.clear(); // Paper - Optimize explosions
+                worldThreadTimeMap.put(worldserver.getWorld(), System.nanoTime() - worldServerThreadNanoTime);
+            });
+    
+            worldServerThread.setDaemon(true);
+            this.worldServerThreads.put(worldserver.getWorld(), worldServerThread);
+            worldServerThread.start();
+        }
+    
+        for(Thread thread : worldServerThreads.values()){
+            try {
+                thread.join();
+            } catch (InterruptedException e) {
+                e.printStackTrace();
             }
-
-            this.profiler.pop();
-            this.profiler.pop();
-            worldserver.explosionDensityCache.clear(); // Paper - Optimize explosions
         }
+        worldServerThreads.clear();
+        /*
+        while (iterator.hasNext()) {
+            ServerLevel worldserver = (ServerLevel) iterator.next();
+            for (final io.papermc.paper.chunk.SingleThreadChunkRegionManager regionManager : worldserver.getChunkSource().chunkMap.regionManagers) {
+                regionManager.recalculateRegions();
+            }
+        }*/
+        
+        PerformanceMonitor.setWorldTickNanoTimeMap(worldThreadTimeMap);
+        PerformanceMonitor.setAllWorldTickNanoTime(System.nanoTime() - worldServerTickNanoTime);
+        
 
         this.profiler.popPush("connection");
         MinecraftTimings.connectionTimer.startTiming(); // Spigot
@@ -1721,7 +1751,7 @@
 
     @DontObfuscate
     public String getServerModName() {
-        return "Paper"; // Paper - Paper > // Spigot - Spigot > // CraftBukkit - cb > vanilla!
+        return "Chiyogami"; // Paper - Paper > // Spigot - Spigot > // CraftBukkit - cb > vanilla!
     }
 
     public SystemReport fillSystemReport(SystemReport details) {
diff --strip-trailing-cr -urN Original/Paper-Server/src/main/java/net/minecraft/util/thread/BlockableEventLoop.java Chiyogami/Paper-Server/src/main/java/net/minecraft/util/thread/BlockableEventLoop.java
--- Original/Paper-Server/src/main/java/net/minecraft/util/thread/BlockableEventLoop.java	2021-09-23 16:59:03.745711800 +0900
+++ Chiyogami/Paper-Server/src/main/java/net/minecraft/util/thread/BlockableEventLoop.java	2021-09-23 18:34:14.322860400 +0900
@@ -15,6 +15,7 @@
 import net.minecraft.util.profiling.metrics.ProfilerMeasured;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
+import org.spigotmc.AsyncCatcher;
 
 public abstract class BlockableEventLoop<R extends Runnable> implements ProfilerMeasured, ProcessorHandle<R>, Executor {
     private final String name;
@@ -32,7 +33,7 @@
     protected abstract boolean shouldRun(R task);
 
     public boolean isSameThread() {
-        return Thread.currentThread() == this.getRunningThread();
+        return !AsyncCatcher.isAsync();
     }
 
     protected abstract Thread getRunningThread();
diff --strip-trailing-cr -urN Original/Paper-Server/src/main/java/net/minecraft/world/level/entity/EntitySection.java Chiyogami/Paper-Server/src/main/java/net/minecraft/world/level/entity/EntitySection.java
--- Original/Paper-Server/src/main/java/net/minecraft/world/level/entity/EntitySection.java	2021-09-23 16:59:02.119643900 +0900
+++ Chiyogami/Paper-Server/src/main/java/net/minecraft/world/level/entity/EntitySection.java	2021-09-23 19:20:25.673640400 +0900
@@ -1,5 +1,10 @@
 package net.minecraft.world.level.entity;
 
+import java.lang.reflect.Field;
+import java.util.List;
+import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.CopyOnWriteArrayList;
 import java.util.function.Consumer;
 import java.util.function.Predicate;
 import java.util.stream.Stream;
@@ -19,7 +24,29 @@
 
     public EntitySection(Class<T> entityClass, Visibility status) {
         this.chunkStatus = status;
-        this.storage = new ClassInstanceMultiMap<>(entityClass);
+        this.storage = new ClassInstanceMultiMap<T>(entityClass){
+            {
+                Class<ClassInstanceMultiMap> classInstanceMultiMapClass = ClassInstanceMultiMap.class;
+                try {
+                    Field byClass = classInstanceMultiMapClass.getDeclaredField("a");
+                    Map<Class<?>, List<T>> newMap = new ConcurrentHashMap<>();
+                
+                    Field allInstances = classInstanceMultiMapClass.getDeclaredField("c");
+                    List<T> newList = new CopyOnWriteArrayList<>();
+                
+                    byClass.setAccessible(true);
+                    allInstances.setAccessible(true);
+                
+                    newMap.put(entityClass, newList);
+                
+                    byClass.set(this, newMap);
+                    allInstances.set(this, newList);
+                
+                } catch (Exception e) {
+                    e.printStackTrace();
+                }
+            }
+        };
     }
 
     public void add(T obj) {
diff --strip-trailing-cr -urN Original/Paper-Server/src/main/java/net/minecraft/world/level/Level.java Chiyogami/Paper-Server/src/main/java/net/minecraft/world/level/Level.java
--- Original/Paper-Server/src/main/java/net/minecraft/world/level/Level.java	2021-09-23 16:59:24.530577700 +0900
+++ Chiyogami/Paper-Server/src/main/java/net/minecraft/world/level/Level.java	2021-09-23 19:18:29.784555700 +0900
@@ -98,6 +98,7 @@
 import org.bukkit.craftbukkit.util.CraftNamespacedKey;
 import org.bukkit.event.block.BlockPhysicsEvent;
 import org.bukkit.event.world.GenericGameEvent;
+import org.spigotmc.AsyncCatcher;
 // CraftBukkit end
 
 public abstract class Level implements LevelAccessor, AutoCloseable {
@@ -474,7 +475,7 @@
     public final LevelChunk getChunk(int chunkX, int chunkZ) { // Paper - final to help inline
         // Paper start - make sure loaded chunks get the inlined variant of this function
         net.minecraft.server.level.ServerChunkCache cps = ((ServerLevel)this).getChunkSource();
-        if (cps.mainThread == Thread.currentThread()) {
+        if (!AsyncCatcher.isAsync()) {
             LevelChunk ifLoaded = cps.getChunkAtIfLoadedMainThread(chunkX, chunkZ);
             if (ifLoaded != null) {
                 return ifLoaded;
@@ -1037,7 +1038,7 @@
         }
         // Paper end
         // CraftBukkit end
-        return this.isOutsideBuildHeight(blockposition) ? null : (!this.isClientSide && Thread.currentThread() != this.thread ? null : this.getChunkAt(blockposition).getBlockEntity(blockposition, LevelChunk.EntityCreationType.IMMEDIATE));
+        return this.isOutsideBuildHeight(blockposition) ? null : (!this.isClientSide && AsyncCatcher.isAsync() ? null : this.getChunkAt(blockposition).getBlockEntity(blockposition, LevelChunk.EntityCreationType.IMMEDIATE));
     }
 
     public void setBlockEntity(BlockEntity blockEntity) {
diff --strip-trailing-cr -urN Original/Paper-Server/src/main/java/org/bukkit/craftbukkit/CraftServer.java Chiyogami/Paper-Server/src/main/java/org/bukkit/craftbukkit/CraftServer.java
--- Original/Paper-Server/src/main/java/org/bukkit/craftbukkit/CraftServer.java	2021-09-23 16:59:20.615226200 +0900
+++ Chiyogami/Paper-Server/src/main/java/org/bukkit/craftbukkit/CraftServer.java	2021-09-23 19:45:15.069955500 +0900
@@ -236,6 +236,7 @@
 import org.bukkit.scheduler.BukkitWorker;
 import org.bukkit.util.StringUtil;
 import org.bukkit.util.permissions.DefaultPermissions;
+import org.spigotmc.AsyncCatcher;
 import org.yaml.snakeyaml.Yaml;
 import org.yaml.snakeyaml.constructor.SafeConstructor;
 import org.yaml.snakeyaml.error.MarkedYAMLException;
@@ -246,7 +247,7 @@
 import javax.annotation.Nonnull; // Paper
 
 public final class CraftServer implements Server {
-    private final String serverName = "Paper"; // Paper
+    private final String serverName = "Chiyogami"; // Paper
     private final String serverVersion;
     private final String bukkitVersion = Versioning.getBukkitVersion();
     private final Logger logger = Logger.getLogger("Minecraft");
@@ -2075,7 +2076,7 @@
 
     @Override
     public boolean isPrimaryThread() {
-        return Thread.currentThread().equals(console.serverThread) || Thread.currentThread().equals(net.minecraft.server.MinecraftServer.getServer().shutdownThread); // Paper - Fix issues with detecting main thread properly, the only time Watchdog will be used is during a crash shutdown which is a "try our best" scenario
+        return Thread.currentThread().equals(console.serverThread) || Thread.currentThread().equals(net.minecraft.server.MinecraftServer.getServer().shutdownThread) || !AsyncCatcher.isAsync(); // Paper - Fix issues with detecting main thread properly, the only time Watchdog will be used is during a crash shutdown which is a "try our best" scenario
     }
 
     // Paper start
diff --strip-trailing-cr -urN Original/Paper-Server/src/main/java/org/bukkit/craftbukkit/CraftWorld.java Chiyogami/Paper-Server/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
--- Original/Paper-Server/src/main/java/org/bukkit/craftbukkit/CraftWorld.java	2021-09-23 16:59:23.287346100 +0900
+++ Chiyogami/Paper-Server/src/main/java/org/bukkit/craftbukkit/CraftWorld.java	2021-09-23 23:53:18.178258700 +0900
@@ -114,6 +114,7 @@
 import org.bukkit.util.Consumer;
 import org.bukkit.util.RayTraceResult;
 import org.bukkit.util.Vector;
+import org.spigotmc.AsyncCatcher;
 
 public class CraftWorld extends CraftRegionAccessor implements World {
     public static final int CUSTOM_DIMENSION_OFFSET = 10;
@@ -342,7 +343,7 @@
     @Override
     public Chunk[] getLoadedChunks() {
         // Paper start
-        if (Thread.currentThread() != world.getLevel().thread) {
+        if (AsyncCatcher.isAsync()) {
             // Paper start - change updating chunks map
             Long2ObjectLinkedOpenHashMap<ChunkHolder> chunks;
             synchronized (world.getChunkSource().chunkMap.updatingChunks) {
@@ -572,8 +573,8 @@
         Map<Plugin, ImmutableList.Builder<Chunk>> ret = new HashMap<>();
         DistanceManager chunkDistanceManager = this.world.getChunkSource().chunkMap.distanceManager;
 
-        for (Long2ObjectMap.Entry<SortedArraySet<Ticket<?>>> chunkTickets : chunkDistanceManager.tickets.long2ObjectEntrySet()) {
-            long chunkKey = chunkTickets.getLongKey();
+        for (Map.Entry<Long, SortedArraySet<Ticket<?>>> chunkTickets : chunkDistanceManager.tickets.entrySet()) {
+            long chunkKey = chunkTickets.getKey();
             SortedArraySet<Ticket<?>> tickets = chunkTickets.getValue();
 
             Chunk chunk = null;
diff --strip-trailing-cr -urN Original/Paper-Server/src/main/java/org/spigotmc/AsyncCatcher.java Chiyogami/Paper-Server/src/main/java/org/spigotmc/AsyncCatcher.java
--- Original/Paper-Server/src/main/java/org/spigotmc/AsyncCatcher.java	2021-09-23 16:59:22.212752700 +0900
+++ Chiyogami/Paper-Server/src/main/java/org/spigotmc/AsyncCatcher.java	2021-09-23 18:23:12.535848500 +0900
@@ -10,10 +10,17 @@
 
     public static void catchOp(String reason)
     {
-        if ( (AsyncCatcher.enabled || io.papermc.paper.util.TickThread.STRICT_THREAD_CHECKS) && Thread.currentThread() != MinecraftServer.getServer().serverThread ) // Paper
+        if ( (AsyncCatcher.enabled || io.papermc.paper.util.TickThread.STRICT_THREAD_CHECKS) && Thread.currentThread() != MinecraftServer.getServer().serverThread
+            && !MinecraftServer.getServer().worldServerThreads.containsValue(Thread.currentThread())) // Chiyogami
         {
             MinecraftServer.LOGGER.fatal("Thread " + Thread.currentThread().getName() + " failed main thread check: " + reason, new Throwable()); // Paper
             throw new IllegalStateException( "Asynchronous " + reason + "!" );
         }
     }
+    
+    // Chiyogami
+    public static boolean isAsync(){
+        return Thread.currentThread() != MinecraftServer.getServer().serverThread
+            && !MinecraftServer.getServer().worldServerThreads.containsValue(Thread.currentThread());
+    }
 }
