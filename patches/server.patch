diff --strip-trailing-cr -urN Original/Paper-Server/src/main/java/net/minecraft/server/Chunk.java Paper-Server/src/main/java/net/minecraft/server/Chunk.java
--- Original/Paper-Server/src/main/java/net/minecraft/server/Chunk.java	2021-08-21 15:30:48.389641200 +0900
+++ Paper-Server/src/main/java/net/minecraft/server/Chunk.java	2021-08-21 15:33:35.255416600 +0900
@@ -14,6 +14,7 @@
 import java.util.Map;
 import java.util.Set;
 import java.util.Map.Entry;
+import java.util.concurrent.CopyOnWriteArrayList;
 import java.util.function.Consumer;
 import java.util.function.Predicate;
 import java.util.function.Supplier;
@@ -162,7 +163,7 @@
         }
 
         for (int l = 0; l < this.entitySlices.length; ++l) {
-            this.entitySlices[l] = new org.bukkit.craftbukkit.util.UnsafeList(); // Spigot
+            this.entitySlices[l] = new CopyOnWriteArrayList(); // Chiyogami
         }
 
         this.d = biomestorage;
diff --strip-trailing-cr -urN Original/Paper-Server/src/main/java/net/minecraft/server/ChunkProviderServer.java Paper-Server/src/main/java/net/minecraft/server/ChunkProviderServer.java
--- Original/Paper-Server/src/main/java/net/minecraft/server/ChunkProviderServer.java	2021-08-21 15:30:49.073928300 +0900
+++ Paper-Server/src/main/java/net/minecraft/server/ChunkProviderServer.java	2021-08-21 15:33:35.265411000 +0900
@@ -18,6 +18,7 @@
 import com.destroystokyo.paper.exception.ServerInternalException;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
+import org.spigotmc.AsyncCatcher;
 
 public class ChunkProviderServer extends IChunkProvider {
 
@@ -121,7 +122,7 @@
     private long chunkFutureAwaitCounter;
 
     public void getEntityTickingChunkAsync(int x, int z, java.util.function.Consumer<Chunk> onLoad) {
-        if (Thread.currentThread() != this.serverThread) {
+        if (AsyncCatcher.isAsync()) {
             this.serverThreadQueue.execute(() -> {
                 ChunkProviderServer.this.getEntityTickingChunkAsync(x, z, onLoad);
             });
@@ -131,7 +132,7 @@
     }
 
     public void getTickingChunkAsync(int x, int z, java.util.function.Consumer<Chunk> onLoad) {
-        if (Thread.currentThread() != this.serverThread) {
+        if (AsyncCatcher.isAsync()) {
             this.serverThreadQueue.execute(() -> {
                 ChunkProviderServer.this.getTickingChunkAsync(x, z, onLoad);
             });
@@ -141,7 +142,7 @@
     }
 
     public void getFullChunkAsync(int x, int z, java.util.function.Consumer<Chunk> onLoad) {
-        if (Thread.currentThread() != this.serverThread) {
+        if (AsyncCatcher.isAsync()) {
             this.serverThreadQueue.execute(() -> {
                 ChunkProviderServer.this.getFullChunkAsync(x, z, onLoad);
             });
@@ -151,7 +152,7 @@
     }
 
     private void getChunkFutureAsynchronously(int x, int z, int ticketLevel, Function<PlayerChunk, CompletableFuture<Either<Chunk, PlayerChunk.Failure>>> futureGet, java.util.function.Consumer<Chunk> onLoad) {
-        if (Thread.currentThread() != this.serverThread) {
+        if (AsyncCatcher.isAsync()) {
             throw new IllegalStateException();
         }
         ChunkCoordIntPair chunkPos = new ChunkCoordIntPair(x, z);
@@ -280,7 +281,7 @@
     public Chunk getChunkAtIfLoadedImmediately(int x, int z) {
         long k = ChunkCoordIntPair.pair(x, z);
 
-        if (Thread.currentThread() == this.serverThread) {
+        if (!AsyncCatcher.isAsync()) {
             return this.getChunkAtIfLoadedMainThread(x, z);
         }
 
@@ -320,7 +321,7 @@
     private long asyncLoadSeqCounter;
 
     public CompletableFuture<Either<IChunkAccess, PlayerChunk.Failure>> getChunkAtAsynchronously(int x, int z, boolean gen, boolean isUrgent) {
-        if (Thread.currentThread() != this.serverThread) {
+        if (AsyncCatcher.isAsync()) {
             CompletableFuture<Either<IChunkAccess, PlayerChunk.Failure>> future = new CompletableFuture<Either<IChunkAccess, PlayerChunk.Failure>>();
             this.serverThreadQueue.execute(() -> {
                 this.getChunkAtAsynchronously(x, z, gen, isUrgent).whenComplete((chunk, ex) -> {
@@ -468,7 +469,7 @@
     @Override
     public IChunkAccess getChunkAt(int i, int j, ChunkStatus chunkstatus, boolean flag) {
         final int x = i; final int z = j; // Paper - conflict on variable change
-        if (Thread.currentThread() != this.serverThread) {
+        if (AsyncCatcher.isAsync()) {
             return (IChunkAccess) CompletableFuture.supplyAsync(() -> {
                 return this.getChunkAt(i, j, chunkstatus, flag);
             }, this.serverThreadQueue).join();
@@ -530,7 +531,7 @@
     @Nullable
     @Override
     public Chunk a(int i, int j) {
-        if (Thread.currentThread() != this.serverThread) {
+        if (AsyncCatcher.isAsync()) {
             return null;
         } else {
             return this.getChunkAtIfLoadedMainThread(i, j); // Paper - optimise for loaded chunks
diff --strip-trailing-cr -urN Original/Paper-Server/src/main/java/net/minecraft/server/IAsyncTaskHandler.java Paper-Server/src/main/java/net/minecraft/server/IAsyncTaskHandler.java
--- Original/Paper-Server/src/main/java/net/minecraft/server/IAsyncTaskHandler.java	2021-08-21 15:30:44.420664600 +0900
+++ Paper-Server/src/main/java/net/minecraft/server/IAsyncTaskHandler.java	2021-08-21 15:33:35.274405100 +0900
@@ -8,6 +8,7 @@
 import java.util.function.BooleanSupplier;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
+import org.spigotmc.AsyncCatcher;
 
 public abstract class IAsyncTaskHandler<R extends Runnable> implements Mailbox<R>, Executor {
 
@@ -25,7 +26,7 @@
     protected abstract boolean canExecute(R r0);
 
     public boolean isMainThread() {
-        return Thread.currentThread() == this.getThread();
+        return !AsyncCatcher.isAsync();
     }
 
     protected abstract Thread getThread();
diff --strip-trailing-cr -urN Original/Paper-Server/src/main/java/net/minecraft/server/MCUtil.java Paper-Server/src/main/java/net/minecraft/server/MCUtil.java
--- Original/Paper-Server/src/main/java/net/minecraft/server/MCUtil.java	2021-08-21 15:30:48.478590700 +0900
+++ Paper-Server/src/main/java/net/minecraft/server/MCUtil.java	2021-08-21 15:33:35.288397400 +0900
@@ -303,7 +303,7 @@
      * @return
      */
     public static void ensureMain(String reason, Runnable run) {
-        if (AsyncCatcher.enabled && Thread.currentThread() != MinecraftServer.getServer().serverThread) {
+        if (AsyncCatcher.enabled && AsyncCatcher.isAsync()) {
             if (reason != null) {
                 new IllegalStateException("Asynchronous " + reason + "!").printStackTrace();
             }
@@ -328,7 +328,7 @@
      * @return
      */
     public static <T> T ensureMain(String reason, Supplier<T> run) {
-        if (AsyncCatcher.enabled && Thread.currentThread() != MinecraftServer.getServer().serverThread) {
+        if (AsyncCatcher.enabled && AsyncCatcher.isAsync()) {
             if (reason != null) {
                 new IllegalStateException("Asynchronous " + reason + "! Blocking thread until it returns ").printStackTrace();
             }
diff --strip-trailing-cr -urN Original/Paper-Server/src/main/java/net/minecraft/server/MinecraftServer.java Paper-Server/src/main/java/net/minecraft/server/MinecraftServer.java
--- Original/Paper-Server/src/main/java/net/minecraft/server/MinecraftServer.java	2021-08-21 15:30:47.478860900 +0900
+++ Paper-Server/src/main/java/net/minecraft/server/MinecraftServer.java	2021-09-09 20:01:12.477030500 +0900
@@ -1,11 +1,7 @@
 package net.minecraft.server;
 
 import com.google.common.base.Splitter;
-import co.aikar.timings.Timings;
-import com.destroystokyo.paper.event.server.PaperServerListPingEvent;
-import com.google.common.base.Stopwatch;
 import com.google.common.collect.Lists;
-import com.google.common.collect.Maps;
 import com.google.gson.JsonElement;
 import com.mojang.authlib.GameProfile;
 import com.mojang.authlib.GameProfileRepository;
@@ -33,41 +29,27 @@
 import java.nio.file.Paths;
 import java.security.KeyPair;
 import java.text.SimpleDateFormat;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Base64;
-import java.util.Collection;
-import java.util.Collections;
-import java.util.Comparator;
-import java.util.Date;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Map;
-import java.util.Optional;
-import java.util.Random;
-import java.util.UUID;
+import java.util.*;
 import java.util.Map.Entry;
 import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.Executor;
 import java.util.function.BooleanSupplier;
 import javax.annotation.Nullable;
 import javax.imageio.ImageIO;
-import joptsimple.NonOptionArgumentSpec;
-import joptsimple.OptionParser;
+
 import joptsimple.OptionSet;
-import joptsimple.OptionSpec;
 import org.apache.commons.lang3.Validate;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 // CraftBukkit start
-import joptsimple.OptionSet;
-import org.bukkit.Bukkit;
-import org.bukkit.craftbukkit.CraftServer;
-import org.bukkit.craftbukkit.Main;
+import org.bukkit.event.block.BlockPhysicsEvent;
+import org.bukkit.event.inventory.InventoryMoveItemEvent;
 import org.bukkit.event.server.ServerLoadEvent;
 // CraftBukkit end
 import co.aikar.timings.MinecraftTimings; // Paper
+import org.spigotmc.AsyncCatcher;
 import org.spigotmc.SlackActivityAccountant; // Spigot
+import world.chiyogami.chiyogamilib.scheduler.WorldThreadRunnable;
 
 public abstract class MinecraftServer extends IAsyncTaskHandlerReentrant<TickTask> implements IMojangStatistics, ICommandListener, AutoCloseable, Runnable {
 
@@ -186,6 +168,8 @@
     public final double[] recentTps = new double[ 3 ];
     public final SlackActivityAccountant slackActivityAccountant = new SlackActivityAccountant();
     // Spigot end
+    public final Map<org.bukkit.World, Thread> worldServerThreads = new HashMap<>(); // Chiyogami
+    
 
     public MinecraftServer(OptionSet options, Proxy proxy, DataFixer datafixer, CommandDispatcher commanddispatcher, YggdrasilAuthenticationService yggdrasilauthenticationservice, MinecraftSessionService minecraftsessionservice, GameProfileRepository gameprofilerepository, UserCache usercache, WorldLoadListenerFactory worldloadlistenerfactory, String s) {
         super("Server");
@@ -732,7 +716,7 @@
         // Paper start - kill main thread, and kill it hard
         shutdownThread = Thread.currentThread();
         org.spigotmc.WatchdogThread.doStop(); // Paper
-        if (!isMainThread()) {
+        if (AsyncCatcher.isAsync()) {
             MinecraftServer.LOGGER.info("Stopping main thread (Ignore any thread death message you see! - DO NOT REPORT THREAD DEATH TO PAPER)");
             while (this.getThread().isAlive()) {
                 this.getThread().stop();
@@ -1032,7 +1016,7 @@
 
     }
 
-    public boolean canSleepForTick() { // Paper
+    public synchronized boolean canSleepForTick() { // Paper
         // CraftBukkit start
         if (isOversleep) return canOversleep();// Paper - because of our changes, this logic is broken
         return this.forceTicks || this.isEntered() || SystemUtils.getMonotonicMillis() < (this.ac ? this.ab : this.nextTick);
@@ -1066,7 +1050,7 @@
     public int midTickChunksTasksRan = 0;
     private long midTickLastRan = 0;
     public void midTickLoadChunks() {
-        if (!isMainThread() || System.nanoTime() - midTickLastRan < 1000000) {
+        if (Thread.currentThread() != this.serverThread || System.nanoTime() - midTickLastRan < 1000000) {
             // only check once per 0.25ms incase this code is called in a hot method
             return;
         }
@@ -1305,49 +1289,68 @@
 
         while (iterator.hasNext()) {
             WorldServer worldserver = (WorldServer) iterator.next();
-
-            worldserver.hasPhysicsEvent =  org.bukkit.event.block.BlockPhysicsEvent.getHandlerList().getRegisteredListeners().length > 0; // Paper
-            TileEntityHopper.skipHopperEvents = worldserver.paperConfig.disableHopperMoveEvents || org.bukkit.event.inventory.InventoryMoveItemEvent.getHandlerList().getRegisteredListeners().length == 0; // Paper
-            if (true || worldserver.worldProvider.getDimensionManager() == DimensionManager.OVERWORLD || this.getAllowNether()) { // CraftBukkit
-                this.methodProfiler.a(() -> {
-                    return worldserver.getWorldData().getName() + " " + IRegistry.DIMENSION_TYPE.getKey(worldserver.worldProvider.getDimensionManager());
-                });
-                /* Drop global time updates
-                if (this.ticks % 20 == 0) {
-                    this.methodProfiler.enter("timeSync");
-                    this.playerList.a((Packet) (new PacketPlayOutUpdateTime(worldserver.getTime(), worldserver.getDayTime(), worldserver.getGameRules().getBoolean(GameRules.DO_DAYLIGHT_CYCLE))), worldserver.worldProvider.getDimensionManager());
-                    this.methodProfiler.exit();
-                }
-                // CraftBukkit end */
-
-                this.methodProfiler.enter("tick");
-
-                try {
-                    midTickLoadChunks(); // Paper
-                    worldserver.timings.doTick.startTiming(); // Spigot
-                    worldserver.doTick(booleansupplier);
-                    worldserver.timings.doTick.stopTiming(); // Spigot
-                    midTickLoadChunks(); // Paper
-                } catch (Throwable throwable) {
-                    // Spigot Start
-                    if (throwable instanceof ThreadDeath) { throw throwable; } // Paper
-                    CrashReport crashreport;
+    
+            Thread worldServerThread = new Thread(() -> {
+                
+                WorldThreadRunnable.worldThreadHeartBeat(worldserver.getWorld(), currentTick); // Chiyogami
+                
+                worldserver.hasPhysicsEvent =  BlockPhysicsEvent.getHandlerList().getRegisteredListeners().length > 0; // Paper
+                TileEntityHopper.skipHopperEvents = worldserver.paperConfig.disableHopperMoveEvents || InventoryMoveItemEvent.getHandlerList().getRegisteredListeners().length == 0; // Paper
+                if (true || worldserver.worldProvider.getDimensionManager() == DimensionManager.OVERWORLD || getAllowNether()) { // CraftBukkit
+                    methodProfiler.a(() -> {
+                        return worldserver.getWorldData().getName() + " " + IRegistry.DIMENSION_TYPE.getKey(worldserver.worldProvider.getDimensionManager());
+                    });
+                    /* Drop global time updates
+                    if (this.ticks % 20 == 0) {
+                        this.methodProfiler.enter("timeSync");
+                        this.playerList.a((Packet) (new PacketPlayOutUpdateTime(worldserver.getTime(), worldserver.getDayTime(), worldserver.getGameRules().getBoolean(GameRules.DO_DAYLIGHT_CYCLE))), worldserver.worldProvider.getDimensionManager());
+                        this.methodProfiler.exit();
+                    }
+                    // CraftBukkit end */
+    
+                    methodProfiler.enter("tick");
+    
+                    
                     try {
-                        crashreport = CrashReport.a(throwable, "Exception ticking world");
-                    } catch (Throwable t) {
-                        throw new RuntimeException("Error generating crash report", t);
+                        worldserver.timings.doTick.startTiming(); // Spigot
+                        worldserver.doTick(booleansupplier);
+                        worldserver.timings.doTick.stopTiming(); // Spigot
+                    } catch (Throwable throwable) {
+                        throwable.printStackTrace();
+                        // Spigot Start
+                        if (throwable instanceof ThreadDeath) { throw throwable; } // Paper
+                        CrashReport crashreport;
+                        try {
+                            crashreport = CrashReport.a(throwable, "Exception ticking world");
+                        } catch (Throwable t) {
+                            throw new RuntimeException("Error generating crash report", t);
+                        }
+                        // Spigot End
+        
+                        worldserver.a(crashreport);
+                        throw new ReportedException(crashreport);
                     }
-                    // Spigot End
-
-                    worldserver.a(crashreport);
-                    throw new ReportedException(crashreport);
+    
+                    methodProfiler.exit();
+                    methodProfiler.exit();
+                    worldserver.explosionDensityCache.clear(); // Paper - Optimize explosions
                 }
-
-                this.methodProfiler.exit();
-                this.methodProfiler.exit();
-                worldserver.explosionDensityCache.clear(); // Paper - Optimize explosions
+            });
+    
+            worldServerThread.setDaemon(true);
+            this.worldServerThreads.put(worldserver.getWorld(), worldServerThread);
+            worldServerThread.start();
+        }
+        
+        
+        for(Thread thread : worldServerThreads.values()){
+            try {
+                thread.join();
+            } catch (InterruptedException e) {
+                e.printStackTrace();
             }
         }
+        worldServerThreads.clear();
 
         this.methodProfiler.exitEnter("connection");
         MinecraftTimings.connectionTimer.startTiming(); // Spigot
@@ -1571,7 +1574,7 @@
     }
 
     public String getServerModName() {
-        return "Paper"; //Paper - Paper > // Spigot - Spigot > // CraftBukkit - cb > vanilla!
+        return "Chiyogami"; //Paper - Paper > // Spigot - Spigot > // CraftBukkit - cb > vanilla! // Chiyogami
     }
 
     public CrashReport b(CrashReport crashreport) {
@@ -1964,7 +1967,7 @@
     }
 
     public void reload() {
-        if (!this.isMainThread()) {
+        if (AsyncCatcher.isAsync()) {
             this.execute(this::reload);
         } else {
             this.getPlayerList().savePlayers();
@@ -2333,7 +2336,8 @@
     // CraftBukkit start
     @Override
     public boolean isMainThread() {
-        return super.isMainThread() /*|| this.isStopped()*/; // CraftBukkit - MC-142590 // Paper - causes issues elsewhere
+        //return super.isMainThread() /*|| this.isStopped()*/; // CraftBukkit - MC-142590 // Paper - causes issues elsewhere
+        return !AsyncCatcher.isAsync();
     }
 
     @Deprecated
diff --strip-trailing-cr -urN Original/Paper-Server/src/main/java/net/minecraft/server/PlayerChunkMap.java Paper-Server/src/main/java/net/minecraft/server/PlayerChunkMap.java
--- Original/Paper-Server/src/main/java/net/minecraft/server/PlayerChunkMap.java	2021-08-21 15:30:49.104150400 +0900
+++ Paper-Server/src/main/java/net/minecraft/server/PlayerChunkMap.java	2021-08-31 21:32:06.126706900 +0900
@@ -32,11 +32,8 @@
 import java.util.Optional;
 import java.util.Queue;
 import java.util.Set;
-import java.util.concurrent.CancellationException;
+import java.util.concurrent.*;
 import java.util.UUID; // Paper
-import java.util.concurrent.CompletableFuture;
-import java.util.concurrent.CompletionException;
-import java.util.concurrent.Executor;
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.function.BooleanSupplier;
 import java.util.function.Consumer;
@@ -83,7 +80,7 @@
     // Paper end
     public final com.destroystokyo.paper.util.map.Long2ObjectLinkedOpenHashMapFastCopy<PlayerChunk> pendingVisibleChunks = new com.destroystokyo.paper.util.map.Long2ObjectLinkedOpenHashMapFastCopy<PlayerChunk>(); // Paper - this is used if the visible chunks is updated while iterating only
     public transient com.destroystokyo.paper.util.map.Long2ObjectLinkedOpenHashMapFastCopy<PlayerChunk> visibleChunksClone; // Paper - used for async access of visible chunks, clone and cache only when needed
-    private final Long2ObjectLinkedOpenHashMap<PlayerChunk> pendingUnload;
+    private final Map<Long, PlayerChunk> pendingUnload;
     final LongSet loadedChunks; // Paper - private -> package
     public final WorldServer world;
     private final LightEngineThreaded lightEngine;
@@ -109,7 +106,7 @@
     public final DefinedStructureManager definedStructureManager; // Paper - private -> public
     private final File w;
     private final PlayerMap playerMap;
-    public final Int2ObjectMap<PlayerChunkMap.EntityTracker> trackedEntities;
+    public final Map<Integer, PlayerChunkMap.EntityTracker> trackedEntities;
     private final Queue<Runnable> z;
     int viewDistance; // Paper - private -> package private
     public final com.destroystokyo.paper.util.PlayerMobDistanceMap playerMobDistanceMap; // Paper
@@ -274,12 +271,12 @@
     public PlayerChunkMap(WorldServer worldserver, File file, DataFixer datafixer, DefinedStructureManager definedstructuremanager, Executor executor, IAsyncTaskHandler<Runnable> iasynctaskhandler, ILightAccess ilightaccess, ChunkGenerator<?> chunkgenerator, WorldLoadListener worldloadlistener, Supplier<WorldPersistentData> supplier, int i) {
         super(new File(worldserver.getWorldProvider().getDimensionManager().a(file), "region"), datafixer);
         //this.visibleChunks = this.updatingChunks.clone(); // Paper - no more cloning
-        this.pendingUnload = new Long2ObjectLinkedOpenHashMap();
+        this.pendingUnload = new ConcurrentHashMap<>();
         this.loadedChunks = new LongOpenHashSet();
         this.unloadQueue = new LongOpenHashSet();
         this.u = new AtomicInteger();
         this.playerMap = new PlayerMap();
-        this.trackedEntities = new Int2ObjectOpenHashMap();
+        this.trackedEntities = new ConcurrentHashMap<>();
         this.z = new com.destroystokyo.paper.utils.CachedSizeConcurrentLinkedQueue<>(); // Paper
         this.definedStructureManager = definedstructuremanager;
         this.w = worldserver.getWorldProvider().getDimensionManager().a(file);
@@ -629,7 +626,7 @@
         }
     }
     public Long2ObjectLinkedOpenHashMap<PlayerChunk> getVisibleChunks() {
-        if (Thread.currentThread() == this.world.serverThread) {
+        if (!AsyncCatcher.isAsync()) {
             return this.visibleChunks;
         } else {
             synchronized (this.visibleChunks) {
@@ -646,7 +643,7 @@
     @Nullable
     public PlayerChunk getVisibleChunk(long i) { // Paper - protected -> public
         // Paper start - mt safe get
-        if (Thread.currentThread() != this.world.serverThread) {
+        if (AsyncCatcher.isAsync()) {
             synchronized (this.visibleChunks) {
                 return (PlayerChunk) (this.hasPendingVisibleUpdate ? this.pendingVisibleChunks.get(i) : ((ProtectedVisibleChunksMap)this.visibleChunks).safeGet(i));
             }
@@ -1955,7 +1952,7 @@
                         EntityPlayer entityplayer = (EntityPlayer) entity;
 
                         this.a(entityplayer, true);
-                        ObjectIterator objectiterator = this.trackedEntities.values().iterator();
+                        Iterator objectiterator = this.trackedEntities.values().iterator();
 
                         while (objectiterator.hasNext()) {
                             PlayerChunkMap.EntityTracker playerchunkmap_entitytracker1 = (PlayerChunkMap.EntityTracker) objectiterator.next();
@@ -1977,7 +1974,7 @@
             EntityPlayer entityplayer = (EntityPlayer) entity;
 
             this.a(entityplayer, false);
-            ObjectIterator objectiterator = this.trackedEntities.values().iterator();
+            Iterator objectiterator = this.trackedEntities.values().iterator();
 
             while (objectiterator.hasNext()) {
                 PlayerChunkMap.EntityTracker playerchunkmap_entitytracker = (PlayerChunkMap.EntityTracker) objectiterator.next();
@@ -2029,7 +2026,7 @@
         List<EntityPlayer> list1 = this.world.getPlayers();
 
         PlayerChunkMap.EntityTracker playerchunkmap_entitytracker;
-        ObjectIterator objectiterator;
+        Iterator objectiterator;
         world.timings.tracker1.startTiming(); // Paper
 
         for (objectiterator = this.trackedEntities.values().iterator(); objectiterator.hasNext(); playerchunkmap_entitytracker.trackerEntry.a()) {
@@ -2262,7 +2259,7 @@
         // Paper start
         // Replace trackedPlayers Set with a Map. The value is true until the player receives
         // their first update (which is forced to have absolute coordinates), false afterward.
-        public java.util.Map<EntityPlayer, Boolean> trackedPlayerMap = new java.util.HashMap<>();
+        public java.util.Map<EntityPlayer, Boolean> trackedPlayerMap = new ConcurrentHashMap<>();
         public Set<EntityPlayer> trackedPlayers = trackedPlayerMap.keySet();
 
         public EntityTracker(Entity entity, int i, int j, boolean flag) {
diff --strip-trailing-cr -urN Original/Paper-Server/src/main/java/net/minecraft/server/PlayerConnectionUtils.java Paper-Server/src/main/java/net/minecraft/server/PlayerConnectionUtils.java
--- Original/Paper-Server/src/main/java/net/minecraft/server/PlayerConnectionUtils.java	2021-08-21 15:30:49.966330500 +0900
+++ Paper-Server/src/main/java/net/minecraft/server/PlayerConnectionUtils.java	2021-08-21 15:33:35.357357900 +0900
@@ -4,6 +4,7 @@
 import org.apache.logging.log4j.Logger;
 import co.aikar.timings.MinecraftTimings; // Paper
 import co.aikar.timings.Timing; // Paper
+import org.spigotmc.AsyncCatcher;
 
 public class PlayerConnectionUtils {
 
@@ -14,7 +15,7 @@
     }
 
     public static <T extends PacketListener> void ensureMainThread(Packet<T> packet, T t0, IAsyncTaskHandler<?> iasynctaskhandler) throws CancelledPacketHandleException {
-        if (!iasynctaskhandler.isMainThread()) {
+        if (AsyncCatcher.isAsync()) {
             Timing timing = MinecraftTimings.getPacketTiming(packet); // Paper - timings
             iasynctaskhandler.execute(() -> {
                 if (MinecraftServer.getServer().hasStopped() || (t0 instanceof PlayerConnection && ((PlayerConnection) t0).processedDisconnect)) return; // CraftBukkit, MC-142590
diff --strip-trailing-cr -urN Original/Paper-Server/src/main/java/net/minecraft/server/World.java Paper-Server/src/main/java/net/minecraft/server/World.java
--- Original/Paper-Server/src/main/java/net/minecraft/server/World.java	2021-08-21 15:30:47.734729200 +0900
+++ Paper-Server/src/main/java/net/minecraft/server/World.java	2021-08-21 15:33:35.367352200 +0900
@@ -32,6 +32,7 @@
 import org.bukkit.craftbukkit.block.CraftBlockState;
 import org.bukkit.craftbukkit.block.data.CraftBlockData;
 import org.bukkit.event.block.BlockPhysicsEvent;
+import org.spigotmc.AsyncCatcher;
 // CraftBukkit end
 
 public abstract class World implements GeneratorAccess, AutoCloseable {
@@ -267,7 +268,7 @@
     @Override
     public Chunk getChunkAt(int i, int j) {
         // Paper start - optimise this for loaded chunks
-        if (Thread.currentThread() == this.serverThread) {
+        if (!AsyncCatcher.isAsync()) {
             Chunk ifLoaded = ((WorldServer) this).getChunkProvider().getChunkAtIfLoadedMainThread(i, j);
             if (ifLoaded != null) {
                 return ifLoaded;
@@ -1050,7 +1051,7 @@
         // CraftBukkit end
         if (isOutsideWorld(blockposition)) {
             return null;
-        } else if (!this.isClientSide && Thread.currentThread() != this.serverThread) {
+        } else if (!this.isClientSide && AsyncCatcher.isAsync()) {
             return null;
         } else {
             // CraftBukkit start
diff --strip-trailing-cr -urN Original/Paper-Server/src/main/java/net/minecraft/server/WorldServer.java Paper-Server/src/main/java/net/minecraft/server/WorldServer.java
--- Original/Paper-Server/src/main/java/net/minecraft/server/WorldServer.java	2021-08-21 15:30:49.110146700 +0900
+++ Paper-Server/src/main/java/net/minecraft/server/WorldServer.java	2021-09-01 23:58:32.500264500 +0900
@@ -22,15 +22,10 @@
 import java.io.IOException;
 import java.io.Writer;
 import java.nio.file.Files;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Map;
-import java.util.Objects;
-import java.util.Optional;
-import java.util.Queue;
-import java.util.Random;
-import java.util.Set;
-import java.util.UUID;
+import java.util.*;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ConcurrentLinkedDeque;
+import java.util.concurrent.CopyOnWriteArrayList;
 import java.util.concurrent.Executor;
 import java.util.function.BooleanSupplier;
 import java.util.function.Predicate;
@@ -49,16 +44,17 @@
 import org.bukkit.event.server.MapInitializeEvent;
 import org.bukkit.event.weather.LightningStrikeEvent;
 import org.bukkit.event.world.TimeSkipEvent;
+import org.spigotmc.AsyncCatcher;
 // CraftBukkit end
 
 public class WorldServer extends World {
 
     private static final Logger LOGGER = LogManager.getLogger();
-    private final List<Entity> globalEntityList = Lists.newArrayList();
-    public final Int2ObjectMap<Entity> entitiesById = new Int2ObjectLinkedOpenHashMap();
-    private final Map<UUID, Entity> entitiesByUUID = Maps.newHashMap();
-    private final Queue<Entity> entitiesToAdd = Queues.newArrayDeque();
-    public final List<EntityPlayer> players = Lists.newArrayList(); // Paper - private -> public
+    private final List<Entity> globalEntityList = new CopyOnWriteArrayList<>();
+    public final Map<Integer, Entity> entitiesById = new ConcurrentHashMap<>();
+    private final Map<UUID, Entity> entitiesByUUID = new ConcurrentHashMap<>();
+    private final Queue<Entity> entitiesToAdd = new ConcurrentLinkedDeque<>();
+    public final List<EntityPlayer> players = new CopyOnWriteArrayList<>(); // Paper - private -> public
     boolean tickingEntities;
     // Paper start
     List<java.lang.Runnable> afterEntityTickingTasks = Lists.newArrayList();
@@ -228,7 +224,7 @@
             }, IRegistry.FLUID::getKey, IRegistry.FLUID::get, this::a, "Fluids"); // Paper - Timings
         }
 
-        this.navigators = Sets.newHashSet();
+        this.navigators = ConcurrentHashMap.newKeySet();
         this.I = new ObjectLinkedOpenHashSet();
         this.dataManager = worldnbtstorage;
         this.server = minecraftserver;
@@ -253,7 +249,7 @@
     @Override
     protected TileEntity getTileEntity(BlockPosition pos, boolean validate) {
         TileEntity result = super.getTileEntity(pos, validate);
-        if (!validate || Thread.currentThread() != this.serverThread) {
+        if (!validate || AsyncCatcher.isAsync()) {
             // SPIGOT-5378: avoid deadlock, this can be called in loading logic (i.e lighting) but getType() will block on chunk load
             return result;
         }
@@ -493,13 +489,14 @@
 
             gameprofilerfiller.exitEnter("regular");
             this.tickingEntities = true;
-            ObjectIterator objectiterator = this.entitiesById.int2ObjectEntrySet().iterator();
+            Iterator objectiterator = new HashMap<>(this.entitiesById).entrySet().iterator();
 
             org.spigotmc.ActivationRange.activateEntities(this); // Spigot
             timings.entityTick.startTiming(); // Spigot
             TimingHistory.entityTicks += this.globalEntityList.size(); // Paper
+            Set<Integer> removeSet = new HashSet<>();
             while (objectiterator.hasNext()) {
-                Entry<Entity> entry = (Entry) objectiterator.next();
+                Map.Entry<Integer, Entity> entry = (Map.Entry) objectiterator.next();
                 Entity entity1 = (Entity) entry.getValue();
                 Entity entity2 = entity1.getVehicle();
 
@@ -536,12 +533,13 @@
                 gameprofilerfiller.enter("remove");
                 if (entity1.dead) {
                     this.removeEntityFromChunk(entity1);
-                    objectiterator.remove();
+                    removeSet.add(entry.getKey());
                     this.unregisterEntity(entity1);
                 }
 
                 gameprofilerfiller.exit();
             }
+            removeSet.forEach(entitiesById::remove);
             timings.entityTick.stopTiming(); // Spigot
 
             this.tickingEntities = false;
@@ -1063,7 +1061,7 @@
     public List<Entity> a(@Nullable EntityTypes<?> entitytypes, Predicate<? super Entity> predicate) {
         List<Entity> list = Lists.newArrayList();
         ChunkProviderServer chunkproviderserver = this.getChunkProvider();
-        ObjectIterator objectiterator = this.entitiesById.values().iterator();
+        Iterator objectiterator = this.entitiesById.values().iterator();
 
         while (objectiterator.hasNext()) {
             Entity entity = (Entity) objectiterator.next();
@@ -1078,7 +1076,7 @@
 
     public List<EntityEnderDragon> j() {
         List<EntityEnderDragon> list = Lists.newArrayList();
-        ObjectIterator objectiterator = this.entitiesById.values().iterator();
+        Iterator objectiterator = this.entitiesById.values().iterator();
 
         while (objectiterator.hasNext()) {
             Entity entity = (Entity) objectiterator.next();
@@ -1128,7 +1126,7 @@
     public int[] countMobs(boolean updatePlayerCounts) {
         int[] ret = new int[EntityPlayer.ENUMCREATURETYPE_TOTAL_ENUMS];
         // Paper end
-        ObjectIterator objectiterator = this.entitiesById.values().iterator();
+        Iterator objectiterator = this.entitiesById.values().iterator();
 
         while (objectiterator.hasNext()) {
             Entity entity = (Entity) objectiterator.next();
@@ -1334,7 +1332,7 @@
         java.util.List<Entity> toMoveChunks = new java.util.ArrayList<>(); // Paper
         for (int j = 0; j < i; ++j) {
             List<Entity> entityslice = aentityslice[j]; // Spigot
-            Iterator iterator = entityslice.iterator();
+            Iterator iterator = new ArrayList<>(entityslice).iterator(); // Chiyogami
 
             while (iterator.hasNext()) {
                 Entity entity = (Entity) iterator.next();
diff --strip-trailing-cr -urN Original/Paper-Server/src/main/java/org/bukkit/craftbukkit/CraftServer.java Paper-Server/src/main/java/org/bukkit/craftbukkit/CraftServer.java
--- Original/Paper-Server/src/main/java/org/bukkit/craftbukkit/CraftServer.java	2021-08-21 15:30:49.242046300 +0900
+++ Paper-Server/src/main/java/org/bukkit/craftbukkit/CraftServer.java	2021-08-21 15:33:35.407329600 +0900
@@ -195,6 +195,7 @@
 import org.bukkit.scheduler.BukkitWorker;
 import org.bukkit.util.StringUtil;
 import org.bukkit.util.permissions.DefaultPermissions;
+import org.spigotmc.AsyncCatcher;
 import org.yaml.snakeyaml.Yaml;
 import org.yaml.snakeyaml.constructor.SafeConstructor;
 import org.yaml.snakeyaml.error.MarkedYAMLException;
@@ -205,7 +206,7 @@
 import javax.annotation.Nonnull; // Paper
 
 public final class CraftServer implements Server {
-    private final String serverName = "Paper"; // Paper
+    private final String serverName = "Chiyogami"; // Paper
     private final String serverVersion;
     private final String bukkitVersion = Versioning.getBukkitVersion();
     private final Logger logger = Logger.getLogger("Minecraft");
@@ -256,7 +257,7 @@
                 return player.getBukkitEntity();
             }
         }));
-        this.serverVersion = CraftServer.class.getPackage().getImplementationVersion();
+        this.serverVersion = "Chiyogami (" + CraftServer.class.getPackage().getImplementationVersion() + ")";
 
         Bukkit.setServer(this);
 
@@ -1747,7 +1748,7 @@
 
     @Override
     public boolean isPrimaryThread() {
-        return Thread.currentThread().equals(console.serverThread) || Thread.currentThread().equals(net.minecraft.server.MinecraftServer.getServer().shutdownThread); // Paper - Fix issues with detecting main thread properly, the only time Watchdog will be used is during a crash shutdown which is a "try our best" scenario
+        return Thread.currentThread().equals(console.serverThread) || Thread.currentThread().equals(net.minecraft.server.MinecraftServer.getServer().shutdownThread) || !AsyncCatcher.isAsync(); // Paper - Fix issues with detecting main thread properly, the only time Watchdog will be used is during a crash shutdown which is a "try our best" scenario
     }
 
     @Override
diff --strip-trailing-cr -urN Original/Paper-Server/src/main/java/org/bukkit/craftbukkit/CraftWorld.java Paper-Server/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
--- Original/Paper-Server/src/main/java/org/bukkit/craftbukkit/CraftWorld.java	2021-08-21 15:30:49.246124200 +0900
+++ Paper-Server/src/main/java/org/bukkit/craftbukkit/CraftWorld.java	2021-09-01 01:08:03.156825000 +0900
@@ -265,6 +265,7 @@
 import org.bukkit.util.Consumer;
 import org.bukkit.util.RayTraceResult;
 import org.bukkit.util.Vector;
+import org.spigotmc.AsyncCatcher;
 
 public class CraftWorld implements World {
     public static final int CUSTOM_DIMENSION_OFFSET = 10;
@@ -453,7 +454,7 @@
     @Override
     public Chunk[] getLoadedChunks() {
         // Paper start
-        if (Thread.currentThread() != world.getMinecraftWorld().serverThread) {
+        if (AsyncCatcher.isAsync()) {
             synchronized (world.getChunkProvider().playerChunkMap.visibleChunks) {
                 Long2ObjectLinkedOpenHashMap<PlayerChunk> chunks = world.getChunkProvider().playerChunkMap.visibleChunks;
                 return chunks.values().stream().map(PlayerChunk::getFullChunk).filter(Objects::nonNull).map(net.minecraft.server.Chunk::getBukkitChunk).toArray(Chunk[]::new);
@@ -1245,7 +1246,7 @@
 
     @Override
     public Collection<Entity> getNearbyEntities(BoundingBox boundingBox, Predicate<Entity> filter) {
-        org.spigotmc.AsyncCatcher.catchOp("getNearbyEntities"); // Spigot
+        
         Validate.notNull(boundingBox, "Bounding box is null!");
 
         AxisAlignedBB bb = new AxisAlignedBB(boundingBox.getMinX(), boundingBox.getMinY(), boundingBox.getMinZ(), boundingBox.getMaxX(), boundingBox.getMaxY(), boundingBox.getMaxZ());
diff --strip-trailing-cr -urN Original/Paper-Server/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java Paper-Server/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
--- Original/Paper-Server/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java	2021-08-21 15:30:48.504575200 +0900
+++ Paper-Server/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java	2021-08-30 04:27:49.574637000 +0900
@@ -26,6 +26,7 @@
 import java.util.Set;
 import java.util.UUID;
 import java.util.WeakHashMap;
+import java.util.concurrent.CompletableFuture;
 import java.util.logging.Level;
 import java.util.logging.Logger;
 import javax.annotation.Nullable;
@@ -73,20 +74,7 @@
 import net.minecraft.server.WorldServer;
 import org.apache.commons.lang.NotImplementedException;
 import org.apache.commons.lang.Validate;
-import org.bukkit.BanList;
-import org.bukkit.Bukkit;
-import org.bukkit.DyeColor;
-import org.bukkit.Effect;
-import org.bukkit.GameMode;
-import org.bukkit.Instrument;
-import org.bukkit.Location;
-import org.bukkit.Material;
-import org.bukkit.Note;
-import org.bukkit.OfflinePlayer;
-import org.bukkit.Particle;
-import org.bukkit.Sound;
-import org.bukkit.Statistic;
-import org.bukkit.WeatherType;
+import org.bukkit.*;
 import org.bukkit.block.data.BlockData;
 import org.bukkit.configuration.serialization.DelegateDeserialization;
 import org.bukkit.conversations.Conversation;
@@ -124,6 +112,7 @@
 import org.bukkit.scoreboard.Scoreboard;
 
 import net.md_5.bungee.api.chat.BaseComponent; // Spigot
+import world.chiyogami.chiyogamilib.scheduler.WorldThreadRunnable;
 
 @DelegateDeserialization(CraftOfflinePlayer.class)
 public class CraftPlayer extends CraftHumanEntity implements Player {
@@ -1961,7 +1950,7 @@
     public void resetCooldown() {
         getHandle().resetCooldown();
     }
-
+    
     @Override
     public void remove() {
         if (this.getHandle().getClass().equals(EntityPlayer.class)) { // special case for NMS plugins inheriting
diff --strip-trailing-cr -urN Original/Paper-Server/src/main/java/org/spigotmc/AsyncCatcher.java Paper-Server/src/main/java/org/spigotmc/AsyncCatcher.java
--- Original/Paper-Server/src/main/java/org/spigotmc/AsyncCatcher.java	2021-08-21 15:30:18.217822700 +0900
+++ Paper-Server/src/main/java/org/spigotmc/AsyncCatcher.java	2021-08-30 00:48:33.377072800 +0900
@@ -10,9 +10,16 @@
 
     public static void catchOp(String reason)
     {
-        if ( enabled && Thread.currentThread() != MinecraftServer.getServer().serverThread )
+        if ( enabled && Thread.currentThread() != MinecraftServer.getServer().serverThread
+            && !MinecraftServer.getServer().worldServerThreads.containsValue(Thread.currentThread())) // Chiyogami
         {
             throw new IllegalStateException( "Asynchronous " + reason + "!" );
         }
     }
+    
+    // Chiyogami
+    public static boolean isAsync(){
+        return Thread.currentThread() != MinecraftServer.getServer().serverThread
+            && !MinecraftServer.getServer().worldServerThreads.containsValue(Thread.currentThread());
+    }
 }
