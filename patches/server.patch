diff --strip-trailing-cr -urN Original/Paper-Server/src/main/java/net/minecraft/server/level/ChunkMap.java Chiyogami/Paper-Server/src/main/java/net/minecraft/server/level/ChunkMap.java
--- Original/Paper-Server/src/main/java/net/minecraft/server/level/ChunkMap.java	2021-08-22 21:29:59.783266700 +0900
+++ Chiyogami/Paper-Server/src/main/java/net/minecraft/server/level/ChunkMap.java	2021-09-05 18:33:34.816156100 +0900
@@ -34,13 +34,10 @@
 import java.util.Optional;
 import java.util.Queue;
 import java.util.Set;
-import java.util.concurrent.CancellationException;
+import java.util.concurrent.*;
 import java.util.UUID; // Paper
-import java.util.concurrent.CompletableFuture;
-import java.util.concurrent.CompletionException;
-import java.util.concurrent.CompletionStage;
-import java.util.concurrent.Executor;
 import java.util.concurrent.atomic.AtomicInteger;
+import java.util.concurrent.locks.ReentrantLock;
 import java.util.function.BooleanSupplier;
 import java.util.function.Consumer;
 import java.util.function.IntFunction;
@@ -104,6 +101,7 @@
 import org.apache.logging.log4j.Logger;
 
 import org.bukkit.entity.Player; // CraftBukkit
+import org.spigotmc.AsyncCatcher;
 
 public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider {
 
@@ -145,7 +143,7 @@
     public static final int FORCED_TICKET_LEVEL = 31;
     // public final Long2ObjectLinkedOpenHashMap<ChunkHolder> updatingChunkMap = new Long2ObjectLinkedOpenHashMap(); // Paper - moved up
     // public volatile Long2ObjectLinkedOpenHashMap<ChunkHolder> visibleChunkMap; // Paper - moved up
-    private final Long2ObjectLinkedOpenHashMap<ChunkHolder> pendingUnloads;
+    private final Map<Long, ChunkHolder> pendingUnloads;
     public final LongSet entitiesInLevel;
     public final ServerLevel level;
     private final ThreadedLevelLightEngine lightEngine;
@@ -172,7 +170,7 @@
     public final StructureManager structureManager;
     private final String storageName;
     private final PlayerMap playerMap;
-    public final Int2ObjectMap<ChunkMap.TrackedEntity> entityMap;
+    public final Map<Integer, ChunkMap.TrackedEntity> entityMap;
     private final Long2ByteMap chunkTypeCache;
     private final Queue<Runnable> unloadQueue;
     int viewDistance;
@@ -186,26 +184,37 @@
         // it's possible to schedule multiple tasks currently, so it's vital we change this impl
         // If we recurse into the executor again, we will append to another queue, ensuring task order consistency
         private java.util.Queue<Runnable> queue = new java.util.ArrayDeque<>(); // Paper - remove final
+        private final ReentrantLock LOCK = new ReentrantLock(true);
 
         @Override
         public void execute(Runnable runnable) {
-            if (this.queue == null) {
-                this.queue = new java.util.ArrayDeque<>();
+            try {
+                LOCK.lock();
+                if (this.queue == null) {
+                    this.queue = new java.util.ArrayDeque<>();
+                }
+                this.queue.add(runnable);
+            } finally {
+                LOCK.unlock();
             }
-            this.queue.add(runnable);
         }
 
         @Override
         public void run() {
-            if (this.queue == null) {
-                return;
-            }
-            java.util.Queue<Runnable> queue = this.queue;
-            this.queue = null;
-            // Paper end
-            Runnable task;
-            while ((task = queue.poll()) != null) { // Paper
-                task.run();
+            try {
+                LOCK.lock();
+                if (this.queue == null) {
+                    return;
+                }
+                java.util.Queue<Runnable> queue = this.queue;
+                this.queue = null;
+                // Paper end
+                Runnable task;
+                while ((task = queue.poll()) != null) { // Paper
+                    task.run();
+                }
+            } finally {
+                LOCK.unlock();
             }
         }
     };
@@ -341,12 +350,12 @@
     public ChunkMap(ServerLevel world, LevelStorageSource.LevelStorageAccess session, DataFixer dataFixer, StructureManager structureManager, Executor executor, BlockableEventLoop<Runnable> mainThreadExecutor, LightChunkGetter chunkProvider, ChunkGenerator chunkGenerator, ChunkProgressListener worldGenerationProgressListener, ChunkStatusUpdateListener chunkStatusChangeListener, Supplier<DimensionDataStorage> persistentStateManagerFactory, int viewDistance, boolean dsync) {
         super(new File(session.getDimensionPath(world.dimension()), "region"), dataFixer, dsync);
         //this.visibleChunks = this.updatingChunks.clone(); // Paper - no more cloning
-        this.pendingUnloads = new Long2ObjectLinkedOpenHashMap();
+        this.pendingUnloads = new ConcurrentHashMap<>();
         this.entitiesInLevel = new LongOpenHashSet();
         this.toDrop = new LongOpenHashSet();
         this.tickingGenerated = new AtomicInteger();
         this.playerMap = new PlayerMap();
-        this.entityMap = new Int2ObjectOpenHashMap();
+        this.entityMap = new ConcurrentHashMap<>();
         this.chunkTypeCache = new Long2ByteOpenHashMap();
         this.unloadQueue = new com.destroystokyo.paper.utils.CachedSizeConcurrentLinkedQueue<>(); // Paper - need constant-time size()
         this.structureManager = structureManager;
@@ -591,7 +600,7 @@
         }
     }
     public Long2ObjectLinkedOpenHashMap<ChunkHolder> getVisibleChunks() {
-        if (Thread.currentThread() == this.level.thread) {
+        if (!AsyncCatcher.isAsync()) {
             return this.visibleChunkMap;
         } else {
             synchronized (this.visibleChunkMap) {
@@ -608,7 +617,7 @@
     @Nullable
     public ChunkHolder getVisibleChunkIfPresent(long pos) {
         // Paper start - mt safe get
-        if (Thread.currentThread() != this.level.thread) {
+        if (AsyncCatcher.isAsync()) {
             synchronized (this.visibleChunkMap) {
                 return (ChunkHolder) (this.hasPendingVisibleUpdate ? this.pendingVisibleChunks.get(pos) : ((ProtectedVisibleChunksMap)this.visibleChunkMap).safeGet(pos));
             }
@@ -1866,7 +1875,7 @@
                         ServerPlayer entityplayer = (ServerPlayer) entity;
 
                         this.updatePlayerStatus(entityplayer, true);
-                        ObjectIterator objectiterator = this.entityMap.values().iterator();
+                        Iterator objectiterator = this.entityMap.values().iterator();
 
                         while (objectiterator.hasNext()) {
                             ChunkMap.TrackedEntity playerchunkmap_entitytracker1 = (ChunkMap.TrackedEntity) objectiterator.next();
@@ -1888,7 +1897,7 @@
             ServerPlayer entityplayer = (ServerPlayer) entity;
 
             this.updatePlayerStatus(entityplayer, false);
-            ObjectIterator objectiterator = this.entityMap.values().iterator();
+            Iterator objectiterator = this.entityMap.values().iterator();
 
             while (objectiterator.hasNext()) {
                 ChunkMap.TrackedEntity playerchunkmap_entitytracker = (ChunkMap.TrackedEntity) objectiterator.next();
@@ -1940,7 +1949,7 @@
         List<ServerPlayer> list1 = this.level.players();
 
         ChunkMap.TrackedEntity playerchunkmap_entitytracker;
-        ObjectIterator objectiterator;
+        Iterator objectiterator;
         level.timings.tracker1.startTiming(); // Paper
 
         for (objectiterator = this.entityMap.values().iterator(); objectiterator.hasNext(); playerchunkmap_entitytracker.serverEntity.sendChanges()) {
diff --strip-trailing-cr -urN Original/Paper-Server/src/main/java/net/minecraft/server/level/DistanceManager.java Chiyogami/Paper-Server/src/main/java/net/minecraft/server/level/DistanceManager.java
--- Original/Paper-Server/src/main/java/net/minecraft/server/level/DistanceManager.java	2021-08-22 21:29:46.003662900 +0900
+++ Chiyogami/Paper-Server/src/main/java/net/minecraft/server/level/DistanceManager.java	2021-09-05 20:29:05.680316900 +0900
@@ -26,6 +26,7 @@
 import java.util.Set;
 import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.Executor;
+import java.util.concurrent.locks.ReentrantLock;
 import javax.annotation.Nullable;
 import net.minecraft.core.SectionPos;
 import net.minecraft.util.SortedArraySet;
@@ -376,6 +377,8 @@
     // CraftBukkit end
 
     private class ChunkTicketTracker extends ChunkTracker {
+        
+        private final ReentrantLock LOCK = new ReentrantLock(true);
 
         public ChunkTicketTracker() {
             super(ChunkMap.MAX_CHUNK_DISTANCE + 2, 16, 256);
@@ -383,40 +386,60 @@
 
         @Override
         protected int getLevelFromSource(long id) {
-            SortedArraySet<Ticket<?>> arraysetsorted = (SortedArraySet) DistanceManager.this.tickets.get(id);
-
-            return arraysetsorted == null ? Integer.MAX_VALUE : (arraysetsorted.isEmpty() ? Integer.MAX_VALUE : ((Ticket) arraysetsorted.first()).getTicketLevel());
+            try {
+                LOCK.lock();
+                SortedArraySet<Ticket<?>> arraysetsorted = (SortedArraySet) DistanceManager.this.tickets.get(id);
+    
+                return arraysetsorted == null ? Integer.MAX_VALUE : (arraysetsorted.isEmpty() ? Integer.MAX_VALUE : ((Ticket) arraysetsorted.first()).getTicketLevel());
+            } finally {
+                LOCK.unlock();
+            }
         }
 
         @Override
         protected int getLevel(long id) {
-            if (!DistanceManager.this.isChunkToRemove(id)) {
-                ChunkHolder playerchunk = DistanceManager.this.getChunk(id);
-
-                if (playerchunk != null) {
-                    return playerchunk.getTicketLevel();
+            try {
+                LOCK.lock();
+                if (!DistanceManager.this.isChunkToRemove(id)) {
+                    ChunkHolder playerchunk = DistanceManager.this.getChunk(id);
+        
+                    if (playerchunk != null) {
+                        return playerchunk.getTicketLevel();
+                    }
                 }
+    
+                return ChunkMap.MAX_CHUNK_DISTANCE + 1;
+            } finally {
+                LOCK.unlock();
             }
-
-            return ChunkMap.MAX_CHUNK_DISTANCE + 1;
         }
 
         @Override
         protected void setLevel(long id, int level) {
-            ChunkHolder playerchunk = DistanceManager.this.getChunk(id);
-            int k = playerchunk == null ? ChunkMap.MAX_CHUNK_DISTANCE + 1 : playerchunk.getTicketLevel();
-
-            if (k != level) {
-                playerchunk = DistanceManager.this.updateChunkScheduling(id, level, playerchunk, k);
-                if (playerchunk != null) {
-                    DistanceManager.this.pendingChunkUpdates.add(playerchunk);
+            try {
+                LOCK.lock();
+                ChunkHolder playerchunk = DistanceManager.this.getChunk(id);
+                int k = playerchunk == null ? ChunkMap.MAX_CHUNK_DISTANCE + 1 : playerchunk.getTicketLevel();
+    
+                if (k != level) {
+                    playerchunk = DistanceManager.this.updateChunkScheduling(id, level, playerchunk, k);
+                    if (playerchunk != null) {
+                        DistanceManager.this.pendingChunkUpdates.add(playerchunk);
+                    }
+        
                 }
-
+            } finally {
+                LOCK.unlock();
             }
         }
 
         public int runDistanceUpdates(int distance) {
-            return this.runUpdates(distance);
+            try {
+                LOCK.lock();
+                return this.runUpdates(distance);
+            } finally {
+                LOCK.unlock();
+            }
         }
     }
 
@@ -424,6 +447,8 @@
 
         protected final Long2ByteMap chunks = new Long2ByteOpenHashMap();
         protected final int maxDistance;
+        
+        protected ReentrantLock LOCK = new ReentrantLock(true);
 
         protected FixedPlayerDistanceChunkTracker(int i) {
             super(i + 2, 16, 256);
@@ -433,68 +458,97 @@
 
         @Override
         protected int getLevel(long id) {
-            return this.chunks.get(id);
+            try {
+                LOCK.lock();
+                return this.chunks.get(id);
+            } finally {
+                LOCK.unlock();
+            }
         }
 
         @Override
         protected void setLevel(long id, int level) {
-            byte b0;
-
-            if (level > this.maxDistance) {
-                b0 = this.chunks.remove(id);
-            } else {
-                b0 = this.chunks.put(id, (byte) level);
+            try {
+                LOCK.lock();
+                byte b0;
+    
+                if (level > this.maxDistance) {
+                    b0 = this.chunks.remove(id);
+                } else {
+                    b0 = this.chunks.put(id, (byte) level);
+                }
+    
+                this.onLevelChange(id, b0, level);
+            } finally {
+                LOCK.unlock();
             }
-
-            this.onLevelChange(id, b0, level);
         }
 
         protected void onLevelChange(long pos, int oldDistance, int distance) {}
 
         @Override
         protected int getLevelFromSource(long id) {
-            return this.havePlayer(id) ? 0 : Integer.MAX_VALUE;
+            try {
+                LOCK.lock();
+                return this.havePlayer(id) ? 0 : Integer.MAX_VALUE;
+            } finally {
+                LOCK.unlock();
+            }
         }
 
         private boolean havePlayer(long chunkPos) {
-            ObjectSet<ServerPlayer> objectset = (ObjectSet) DistanceManager.this.playersPerChunk.get(chunkPos);
-
-            return objectset != null && !objectset.isEmpty();
+            try {
+                LOCK.lock();
+                ObjectSet<ServerPlayer> objectset = (ObjectSet) DistanceManager.this.playersPerChunk.get(chunkPos);
+    
+                return objectset != null && !objectset.isEmpty();
+            } finally {
+                LOCK.unlock();
+            }
         }
 
         public void runAllUpdates() {
-            this.runUpdates(Integer.MAX_VALUE);
+            try {
+                LOCK.lock();
+                this.runUpdates(Integer.MAX_VALUE);
+            } finally {
+                LOCK.unlock();
+            }
         }
 
         private void dumpChunks(String s) {
             try {
-                FileOutputStream fileoutputstream = new FileOutputStream(new File(s));
-
+                LOCK.lock();
                 try {
-                    ObjectIterator objectiterator = this.chunks.long2ByteEntrySet().iterator();
-
-                    while (objectiterator.hasNext()) {
-                        it.unimi.dsi.fastutil.longs.Long2ByteMap.Entry it_unimi_dsi_fastutil_longs_long2bytemap_entry = (it.unimi.dsi.fastutil.longs.Long2ByteMap.Entry) objectiterator.next();
-                        ChunkPos chunkcoordintpair = new ChunkPos(it_unimi_dsi_fastutil_longs_long2bytemap_entry.getLongKey());
-                        String s1 = Byte.toString(it_unimi_dsi_fastutil_longs_long2bytemap_entry.getByteValue());
-
-                        fileoutputstream.write((chunkcoordintpair.x + "\t" + chunkcoordintpair.z + "\t" + s1 + "\n").getBytes(StandardCharsets.UTF_8));
-                    }
-                } catch (Throwable throwable) {
+                    FileOutputStream fileoutputstream = new FileOutputStream(new File(s));
+        
                     try {
-                        fileoutputstream.close();
-                    } catch (Throwable throwable1) {
-                        throwable.addSuppressed(throwable1);
+                        ObjectIterator objectiterator = this.chunks.long2ByteEntrySet().iterator();
+            
+                        while (objectiterator.hasNext()) {
+                            it.unimi.dsi.fastutil.longs.Long2ByteMap.Entry it_unimi_dsi_fastutil_longs_long2bytemap_entry = (it.unimi.dsi.fastutil.longs.Long2ByteMap.Entry) objectiterator.next();
+                            ChunkPos chunkcoordintpair = new ChunkPos(it_unimi_dsi_fastutil_longs_long2bytemap_entry.getLongKey());
+                            String s1 = Byte.toString(it_unimi_dsi_fastutil_longs_long2bytemap_entry.getByteValue());
+                
+                            fileoutputstream.write((chunkcoordintpair.x + "\t" + chunkcoordintpair.z + "\t" + s1 + "\n").getBytes(StandardCharsets.UTF_8));
+                        }
+                    } catch (Throwable throwable) {
+                        try {
+                            fileoutputstream.close();
+                        } catch (Throwable throwable1) {
+                            throwable.addSuppressed(throwable1);
+                        }
+            
+                        throw throwable;
                     }
-
-                    throw throwable;
+        
+                    fileoutputstream.close();
+                } catch (IOException ioexception) {
+                    DistanceManager.LOGGER.error(ioexception);
                 }
-
-                fileoutputstream.close();
-            } catch (IOException ioexception) {
-                DistanceManager.LOGGER.error(ioexception);
+            } finally {
+                LOCK.unlock();
             }
-
         }
     }
 
@@ -511,86 +565,109 @@
 
         @Override
         protected void onLevelChange(long pos, int oldDistance, int distance) {
-            this.toUpdate.add(pos);
+            try {
+                LOCK.lock();
+                this.toUpdate.add(pos);
+            } finally {
+                LOCK.unlock();
+            }
         }
 
         public void updateViewDistance(int watchDistance) {
-            ObjectIterator objectiterator = this.chunks.long2ByteEntrySet().iterator();
-
-            while (objectiterator.hasNext()) {
-                it.unimi.dsi.fastutil.longs.Long2ByteMap.Entry it_unimi_dsi_fastutil_longs_long2bytemap_entry = (it.unimi.dsi.fastutil.longs.Long2ByteMap.Entry) objectiterator.next();
-                byte b0 = it_unimi_dsi_fastutil_longs_long2bytemap_entry.getByteValue();
-                long j = it_unimi_dsi_fastutil_longs_long2bytemap_entry.getLongKey();
-
-                this.onLevelChange(j, b0, this.haveTicketFor(b0), b0 <= watchDistance - 2);
+            try {
+                LOCK.lock();
+                ObjectIterator objectiterator = this.chunks.long2ByteEntrySet().iterator();
+    
+                while (objectiterator.hasNext()) {
+                    it.unimi.dsi.fastutil.longs.Long2ByteMap.Entry it_unimi_dsi_fastutil_longs_long2bytemap_entry = (it.unimi.dsi.fastutil.longs.Long2ByteMap.Entry) objectiterator.next();
+                    byte b0 = it_unimi_dsi_fastutil_longs_long2bytemap_entry.getByteValue();
+                    long j = it_unimi_dsi_fastutil_longs_long2bytemap_entry.getLongKey();
+        
+                    this.onLevelChange(j, b0, this.haveTicketFor(b0), b0 <= watchDistance - 2);
+                }
+    
+                this.viewDistance = watchDistance;
+            } finally {
+                LOCK.unlock();
             }
-
-            this.viewDistance = watchDistance;
         }
 
         private void onLevelChange(long pos, int distance, boolean oldWithinViewDistance, boolean withinViewDistance) {
-            if (oldWithinViewDistance != withinViewDistance) {
-                Ticket<?> ticket = new Ticket<>(TicketType.PLAYER, 33, new ChunkPos(pos)); // Paper - no-tick view distance
-
-                if (withinViewDistance) {
-                    DistanceManager.this.ticketThrottlerInput.tell(ChunkTaskPriorityQueueSorter.message(() -> {
-                        DistanceManager.this.mainThreadExecutor.execute(() -> {
-                            if (this.haveTicketFor(this.getLevel(pos))) {
-                                DistanceManager.this.addTicket(pos, ticket);
-                                DistanceManager.this.ticketsToRelease.add(pos);
-                            } else {
-                                DistanceManager.this.ticketThrottlerReleaser.tell(ChunkTaskPriorityQueueSorter.release(() -> {
-                                }, pos, false));
-                            }
-
-                        });
-                    }, pos, () -> {
-                        return distance;
-                    }));
-                } else {
-                    DistanceManager.this.ticketThrottlerReleaser.tell(ChunkTaskPriorityQueueSorter.release(() -> {
-                        DistanceManager.this.mainThreadExecutor.execute(() -> {
-                            DistanceManager.this.removeTicket(pos, ticket);
-                        });
-                    }, pos, true));
+            try {
+                LOCK.lock();
+                if (oldWithinViewDistance != withinViewDistance) {
+                    Ticket<?> ticket = new Ticket<>(TicketType.PLAYER, 33, new ChunkPos(pos)); // Paper - no-tick view distance
+        
+                    if (withinViewDistance) {
+                        DistanceManager.this.ticketThrottlerInput.tell(ChunkTaskPriorityQueueSorter.message(() -> {
+                            DistanceManager.this.mainThreadExecutor.execute(() -> {
+                                if (this.haveTicketFor(this.getLevel(pos))) {
+                                    DistanceManager.this.addTicket(pos, ticket);
+                                    DistanceManager.this.ticketsToRelease.add(pos);
+                                } else {
+                                    DistanceManager.this.ticketThrottlerReleaser.tell(ChunkTaskPriorityQueueSorter.release(() -> {
+                                    }, pos, false));
+                                }
+                    
+                            });
+                        }, pos, () -> {
+                            return distance;
+                        }));
+                    } else {
+                        DistanceManager.this.ticketThrottlerReleaser.tell(ChunkTaskPriorityQueueSorter.release(() -> {
+                            DistanceManager.this.mainThreadExecutor.execute(() -> {
+                                DistanceManager.this.removeTicket(pos, ticket);
+                            });
+                        }, pos, true));
+                    }
                 }
+            } finally {
+                LOCK.unlock();
             }
-
         }
 
         @Override
         public void runAllUpdates() {
-            super.runAllUpdates();
-            if (!this.toUpdate.isEmpty()) {
-                LongIterator longiterator = this.toUpdate.iterator();
-
-                while (longiterator.hasNext()) {
-                    long i = longiterator.nextLong();
-                    int j = this.queueLevels.get(i);
-                    int k = this.getLevel(i);
-
-                    if (j != k) {
-                        DistanceManager.this.ticketThrottler.onLevelChange(new ChunkPos(i), () -> {
-                            return this.queueLevels.get(i);
-                        }, k, (l) -> {
-                            if (l >= this.queueLevels.defaultReturnValue()) {
-                                this.queueLevels.remove(i);
-                            } else {
-                                this.queueLevels.put(i, l);
-                            }
-
-                        });
-                        this.onLevelChange(i, k, this.haveTicketFor(j), this.haveTicketFor(k));
+            try {
+                LOCK.lock();
+                super.runAllUpdates();
+                if (!this.toUpdate.isEmpty()) {
+                    LongIterator longiterator = this.toUpdate.iterator();
+        
+                    while (longiterator.hasNext()) {
+                        long i = longiterator.nextLong();
+                        int j = this.queueLevels.get(i);
+                        int k = this.getLevel(i);
+            
+                        if (j != k) {
+                            DistanceManager.this.ticketThrottler.onLevelChange(new ChunkPos(i), () -> {
+                                return this.queueLevels.get(i);
+                            }, k, (l) -> {
+                                if (l >= this.queueLevels.defaultReturnValue()) {
+                                    this.queueLevels.remove(i);
+                                } else {
+                                    this.queueLevels.put(i, l);
+                                }
+                    
+                            });
+                            this.onLevelChange(i, k, this.haveTicketFor(j), this.haveTicketFor(k));
+                        }
                     }
+        
+                    this.toUpdate.clear();
                 }
-
-                this.toUpdate.clear();
+            } finally {
+                LOCK.unlock();
             }
-
         }
 
         private boolean haveTicketFor(int distance) {
-            return distance <= this.viewDistance - 2;
+            try {
+                LOCK.lock();
+                return distance <= this.viewDistance - 2;
+            } finally {
+                LOCK.unlock();
+            }
         }
     }
 }
diff --strip-trailing-cr -urN Original/Paper-Server/src/main/java/net/minecraft/server/level/ServerChunkCache.java Chiyogami/Paper-Server/src/main/java/net/minecraft/server/level/ServerChunkCache.java
--- Original/Paper-Server/src/main/java/net/minecraft/server/level/ServerChunkCache.java	2021-08-22 21:29:53.475034400 +0900
+++ Chiyogami/Paper-Server/src/main/java/net/minecraft/server/level/ServerChunkCache.java	2021-08-22 22:05:38.100173900 +0900
@@ -45,6 +45,7 @@
 import net.minecraft.world.level.storage.LevelData;
 import net.minecraft.world.level.storage.LevelStorageSource;
 import it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap; // Paper
+import org.spigotmc.AsyncCatcher;
 
 public class ServerChunkCache extends ChunkSource {
 
@@ -141,7 +142,7 @@
     private long chunkFutureAwaitCounter;
 
     public void getEntityTickingChunkAsync(int x, int z, java.util.function.Consumer<LevelChunk> onLoad) {
-        if (Thread.currentThread() != this.mainThread) {
+        if (AsyncCatcher.isAsync()) {
             this.mainThreadProcessor.execute(() -> {
                 ServerChunkCache.this.getEntityTickingChunkAsync(x, z, onLoad);
             });
@@ -151,7 +152,7 @@
     }
 
     public void getTickingChunkAsync(int x, int z, java.util.function.Consumer<LevelChunk> onLoad) {
-        if (Thread.currentThread() != this.mainThread) {
+        if (AsyncCatcher.isAsync()) {
             this.mainThreadProcessor.execute(() -> {
                 ServerChunkCache.this.getTickingChunkAsync(x, z, onLoad);
             });
@@ -161,7 +162,7 @@
     }
 
     public void getFullChunkAsync(int x, int z, java.util.function.Consumer<LevelChunk> onLoad) {
-        if (Thread.currentThread() != this.mainThread) {
+        if (AsyncCatcher.isAsync()) {
             this.mainThreadProcessor.execute(() -> {
                 ServerChunkCache.this.getFullChunkAsync(x, z, onLoad);
             });
@@ -171,7 +172,7 @@
     }
 
     private void getChunkFutureAsynchronously(int x, int z, int ticketLevel, Function<ChunkHolder, CompletableFuture<Either<LevelChunk, ChunkHolder.ChunkLoadingFailure>>> futureGet, java.util.function.Consumer<LevelChunk> onLoad) {
-        if (Thread.currentThread() != this.mainThread) {
+        if (AsyncCatcher.isAsync()) {
             throw new IllegalStateException();
         }
         ChunkPos chunkPos = new ChunkPos(x, z);
@@ -312,7 +313,7 @@
     public LevelChunk getChunkAtIfLoadedImmediately(int x, int z) {
         long k = ChunkPos.asLong(x, z);
 
-        if (Thread.currentThread() == this.mainThread) {
+        if (!AsyncCatcher.isAsync()) {
             return this.getChunkAtIfLoadedMainThread(x, z);
         }
 
@@ -348,7 +349,7 @@
     private long asyncLoadSeqCounter;
 
     public CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> getChunkAtAsynchronously(int x, int z, boolean gen, boolean isUrgent) {
-        if (Thread.currentThread() != this.mainThread) {
+        if (AsyncCatcher.isAsync()) {
             CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> future = new CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>>();
             this.mainThreadProcessor.execute(() -> {
                 this.getChunkAtAsynchronously(x, z, gen, isUrgent).whenComplete((chunk, ex) -> {
@@ -457,7 +458,7 @@
     @Override
     public ChunkAccess getChunk(int x, int z, ChunkStatus leastStatus, boolean create) {
         final int x1 = x; final int z1 = z; // Paper - conflict on variable change
-        if (Thread.currentThread() != this.mainThread) {
+        if (AsyncCatcher.isAsync()) {
             return (ChunkAccess) CompletableFuture.supplyAsync(() -> {
                 return this.getChunk(x, z, leastStatus, create);
             }, this.mainThreadProcessor).join();
@@ -517,7 +518,7 @@
     @Nullable
     @Override
     public LevelChunk getChunkNow(int chunkX, int chunkZ) {
-        if (Thread.currentThread() != this.mainThread) {
+        if (AsyncCatcher.isAsync()) {
             return null;
         } else {
             return this.getChunkAtIfLoadedMainThread(chunkX, chunkZ); // Paper - optimise for loaded chunks
@@ -531,7 +532,7 @@
     }
 
     public CompletableFuture<Either<ChunkAccess, ChunkHolder.ChunkLoadingFailure>> getChunkFuture(int chunkX, int chunkZ, ChunkStatus leastStatus, boolean create) {
-        boolean flag1 = Thread.currentThread() == this.mainThread;
+        boolean flag1 = !AsyncCatcher.isAsync();
         CompletableFuture completablefuture;
 
         if (flag1) {
diff --strip-trailing-cr -urN Original/Paper-Server/src/main/java/net/minecraft/server/level/ServerLevel.java Chiyogami/Paper-Server/src/main/java/net/minecraft/server/level/ServerLevel.java
--- Original/Paper-Server/src/main/java/net/minecraft/server/level/ServerLevel.java	2021-08-22 21:29:58.407897400 +0900
+++ Chiyogami/Paper-Server/src/main/java/net/minecraft/server/level/ServerLevel.java	2021-09-05 16:39:48.000085900 +0900
@@ -19,13 +19,9 @@
 import java.io.Writer;
 import java.nio.file.Files;
 import java.nio.file.Path;
-import java.util.Comparator;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Objects;
-import java.util.Optional;
-import java.util.Set;
-import java.util.UUID;
+import java.util.*;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.CopyOnWriteArrayList;
 import java.util.concurrent.Executor;
 import java.util.function.BooleanSupplier;
 import java.util.function.Function;
@@ -186,7 +182,7 @@
     private final List<CustomSpawner> customSpawners;
     @Nullable
     private final EndDragonFight dragonFight;
-    final Int2ObjectMap<EnderDragonPart> dragonParts;
+    final Map<Integer, EnderDragonPart> dragonParts;
     private final StructureFeatureManager structureFeatureManager;
     private final boolean tickTime;
 
@@ -309,7 +305,7 @@
         this.convertable = convertable_conversionsession;
         this.uuid = WorldUUID.getUUID(convertable_conversionsession.levelPath.toFile());
         // CraftBukkit end
-        this.players = Lists.newArrayList();
+        this.players = new CopyOnWriteArrayList<>();
         this.entityTickList = new EntityTickList();
         Predicate<Block> predicate = (block) -> { // CraftBukkit - decompile eror
             return block == null || block.defaultBlockState().isAir();
@@ -330,9 +326,9 @@
             this.blockTicks = new ServerTickList<>(this, predicate, Registry.BLOCK::getKey, this::tickBlock, "Blocks"); // CraftBukkit - decompile error // Paper - Timings & copied from above
         this.liquidTicks = new ServerTickList<>(this, predicate2, Registry.FLUID::getKey, this::tickLiquid, "Fluids"); // CraftBukkit - decompile error // Paper - Timings
         }
-        this.navigatingMobs = new ObjectOpenHashSet();
+        this.navigatingMobs = ConcurrentHashMap.newKeySet();
         this.blockEvents = new ObjectLinkedOpenHashSet();
-        this.dragonParts = new Int2ObjectOpenHashMap();
+        this.dragonParts = new ConcurrentHashMap<>();
         this.tickTime = flag1;
         this.server = minecraftserver;
         this.customSpawners = list;
diff --strip-trailing-cr -urN Original/Paper-Server/src/main/java/net/minecraft/server/MCUtil.java Chiyogami/Paper-Server/src/main/java/net/minecraft/server/MCUtil.java
--- Original/Paper-Server/src/main/java/net/minecraft/server/MCUtil.java	2021-08-22 21:29:43.175229700 +0900
+++ Chiyogami/Paper-Server/src/main/java/net/minecraft/server/MCUtil.java	2021-08-22 22:05:38.168134200 +0900
@@ -320,7 +320,7 @@
      * @return
      */
     public static void ensureMain(String reason, Runnable run) {
-        if (AsyncCatcher.enabled && Thread.currentThread() != MinecraftServer.getServer().serverThread) {
+        if (AsyncCatcher.enabled && AsyncCatcher.isAsync()) {
             if (reason != null) {
                 new IllegalStateException("Asynchronous " + reason + "!").printStackTrace();
             }
@@ -345,7 +345,7 @@
      * @return
      */
     public static <T> T ensureMain(String reason, Supplier<T> run) {
-        if (AsyncCatcher.enabled && Thread.currentThread() != MinecraftServer.getServer().serverThread) {
+        if (AsyncCatcher.enabled && AsyncCatcher.isAsync()) {
             if (reason != null) {
                 new IllegalStateException("Asynchronous " + reason + "! Blocking thread until it returns ").printStackTrace();
             }
diff --strip-trailing-cr -urN Original/Paper-Server/src/main/java/net/minecraft/server/MinecraftServer.java Chiyogami/Paper-Server/src/main/java/net/minecraft/server/MinecraftServer.java
--- Original/Paper-Server/src/main/java/net/minecraft/server/MinecraftServer.java	2021-08-22 21:29:57.318730900 +0900
+++ Chiyogami/Paper-Server/src/main/java/net/minecraft/server/MinecraftServer.java	2021-09-09 23:32:03.171295900 +0900
@@ -31,21 +31,8 @@
 import java.nio.file.Path;
 import java.security.KeyPair;
 import java.text.SimpleDateFormat;
-import java.util.Arrays;
-import java.util.Base64;
-import java.util.Collection;
-import java.util.Collections;
-import java.util.Comparator;
-import java.util.Date;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Map;
+import java.util.*;
 import java.util.Map.Entry;
-import java.util.Objects;
-import java.util.Optional;
-import java.util.Random;
-import java.util.Set;
-import java.util.UUID;
 import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.Executor;
 import java.util.concurrent.atomic.AtomicReference;
@@ -185,7 +172,9 @@
 // CraftBukkit end
 
 import co.aikar.timings.MinecraftTimings; // Paper
+import org.spigotmc.AsyncCatcher;
 import org.spigotmc.SlackActivityAccountant; // Spigot
+import world.chiyogami.chiyogamilib.scheduler.WorldThreadRunnable;
 
 public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTask> implements SnooperPopulator, CommandSource, AutoCloseable {
 
@@ -306,6 +295,8 @@
     public final double[] recentTps = new double[ 3 ];
     public final SlackActivityAccountant slackActivityAccountant = new SlackActivityAccountant();
     // Spigot end
+    
+    public final Map<org.bukkit.World, Thread> worldServerThreads = new HashMap<>(); // Chiyogami
 
     public volatile Thread shutdownThread; // Paper
     public volatile boolean abnormalExit = false; // Paper
@@ -1287,7 +1278,7 @@
     public int midTickChunksTasksRan = 0;
     private long midTickLastRan = 0;
     public void midTickLoadChunks() {
-        if (!isSameThread() || System.nanoTime() - midTickLastRan < 1000000) {
+        if (Thread.currentThread() != this.serverThread || System.nanoTime() - midTickLastRan < 1000000) {
             // only check once per 0.25ms incase this code is called in a hot method
             return;
         }
@@ -1530,13 +1521,18 @@
 
         while (iterator.hasNext()) {
             ServerLevel worldserver = (ServerLevel) iterator.next();
-            worldserver.hasPhysicsEvent =  org.bukkit.event.block.BlockPhysicsEvent.getHandlerList().getRegisteredListeners().length > 0; // Paper
-            worldserver.hasEntityMoveEvent =  io.papermc.paper.event.entity.EntityMoveEvent.getHandlerList().getRegisteredListeners().length > 0; // Paper
-            net.minecraft.world.level.block.entity.HopperBlockEntity.skipHopperEvents = worldserver.paperConfig.disableHopperMoveEvents || org.bukkit.event.inventory.InventoryMoveItemEvent.getHandlerList().getRegisteredListeners().length == 0; // Paper
-
-            this.profiler.push(() -> {
-                return worldserver + " " + worldserver.dimension().location();
-            });
+            
+            Thread worldServerThread = new Thread(() -> {
+    
+                WorldThreadRunnable.worldThreadHeartBeat(worldserver.getWorld(), currentTick);
+                
+                worldserver.hasPhysicsEvent =  org.bukkit.event.block.BlockPhysicsEvent.getHandlerList().getRegisteredListeners().length > 0; // Paper
+                worldserver.hasEntityMoveEvent =  io.papermc.paper.event.entity.EntityMoveEvent.getHandlerList().getRegisteredListeners().length > 0; // Paper
+                net.minecraft.world.level.block.entity.HopperBlockEntity.skipHopperEvents = worldserver.paperConfig.disableHopperMoveEvents || org.bukkit.event.inventory.InventoryMoveItemEvent.getHandlerList().getRegisteredListeners().length == 0; // Paper
+    
+                this.profiler.push(() -> {
+                    return worldserver + " " + worldserver.dimension().location();
+                });
             /* Drop global time updates
             if (this.tickCount % 20 == 0) {
                 this.profiler.enter("timeSync");
@@ -1544,34 +1540,49 @@
                 this.profiler.exit();
             }
             // CraftBukkit end */
-
-            this.profiler.push("tick");
-
-            try {
-                midTickLoadChunks(); // Paper
-                worldserver.timings.doTick.startTiming(); // Spigot
-                worldserver.tick(shouldKeepTicking);
-                worldserver.timings.doTick.stopTiming(); // Spigot
-                midTickLoadChunks(); // Paper
-            } catch (Throwable throwable) {
-                // Spigot Start
-                CrashReport crashreport;
+    
+                this.profiler.push("tick");
+    
                 try {
-                    crashreport = CrashReport.forThrowable(throwable, "Exception ticking world");
-                } catch (Throwable t) {
-                    if (throwable instanceof ThreadDeath) { throw (ThreadDeath)throwable; } // Paper
-                    throw new RuntimeException("Error generating crash report", t);
+                    midTickLoadChunks(); // Paper
+                    worldserver.timings.doTick.startTiming(); // Spigot
+                    worldserver.tick(shouldKeepTicking);
+                    worldserver.timings.doTick.stopTiming(); // Spigot
+                    midTickLoadChunks(); // Paper
+                } catch (Throwable throwable) {
+                    // Spigot Start
+                    CrashReport crashreport;
+                    try {
+                        crashreport = CrashReport.forThrowable(throwable, "Exception ticking world");
+                    } catch (Throwable t) {
+                        if (throwable instanceof ThreadDeath) { throw (ThreadDeath)throwable; } // Paper
+                        throw new RuntimeException("Error generating crash report", t);
+                    }
+                    // Spigot End
+        
+                    worldserver.fillReportDetails(crashreport);
+                    throw new ReportedException(crashreport);
                 }
-                // Spigot End
-
-                worldserver.fillReportDetails(crashreport);
-                throw new ReportedException(crashreport);
+    
+                this.profiler.pop();
+                this.profiler.pop();
+                worldserver.explosionDensityCache.clear(); // Paper - Optimize explosions
+            });
+    
+            worldServerThread.setDaemon(true);
+            this.worldServerThreads.put(worldserver.getWorld(), worldServerThread);
+            worldServerThread.start();
+        }
+    
+    
+        for(Thread thread : worldServerThreads.values()){
+            try {
+                thread.join();
+            } catch (InterruptedException e) {
+                e.printStackTrace();
             }
-
-            this.profiler.pop();
-            this.profiler.pop();
-            worldserver.explosionDensityCache.clear(); // Paper - Optimize explosions
         }
+        worldServerThreads.clear();
 
         this.profiler.popPush("connection");
         MinecraftTimings.connectionTimer.startTiming(); // Spigot
@@ -1651,7 +1662,7 @@
 
     @DontObfuscate
     public String getServerModName() {
-        return "Paper"; //Paper - Paper > // Spigot - Spigot > // CraftBukkit - cb > vanilla!
+        return "Chiyogami"; //Paper - Paper > // Spigot - Spigot > // CraftBukkit - cb > vanilla! // Chiyogami
     }
 
     public SystemReport fillSystemReport(SystemReport details) {
@@ -2047,7 +2058,7 @@
             this.worldData.setDataPackConfig(MinecraftServer.getSelectedPacks(this.packRepository));
             datapackresources.updateGlobals();
             new io.papermc.paper.event.server.ServerResourcesReloadedEvent(cause).callEvent(); // Paper
-            if (Thread.currentThread() != this.serverThread) return; // Paper
+            if (AsyncCatcher.isAsync()) return; // Paper
             //this.getPlayerList().savePlayers(); // Paper - we don't need to do this
             this.getPlayerList().reloadResources();
             this.functionManager.replaceLibrary(this.resources.getFunctionLibrary());
@@ -2394,7 +2405,8 @@
     // CraftBukkit start
     @Override
     public boolean isSameThread() {
-        return super.isSameThread() /*|| this.isStopped()*/; // CraftBukkit - MC-142590 // Paper - causes issues elsewhere
+        //return super.isSameThread() /*|| this.isStopped()*/; // CraftBukkit - MC-142590 // Paper - causes issues elsewhere
+        return !AsyncCatcher.isAsync(); // Chiyogami
     }
 
     public boolean isDebugging() {
diff --strip-trailing-cr -urN Original/Paper-Server/src/main/java/net/minecraft/util/thread/BlockableEventLoop.java Chiyogami/Paper-Server/src/main/java/net/minecraft/util/thread/BlockableEventLoop.java
--- Original/Paper-Server/src/main/java/net/minecraft/util/thread/BlockableEventLoop.java	2021-08-22 21:29:43.609981400 +0900
+++ Chiyogami/Paper-Server/src/main/java/net/minecraft/util/thread/BlockableEventLoop.java	2021-08-22 22:05:38.161138900 +0900
@@ -15,6 +15,7 @@
 import net.minecraft.util.profiling.metrics.ProfilerMeasured;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
+import org.spigotmc.AsyncCatcher;
 
 public abstract class BlockableEventLoop<R extends Runnable> implements ProfilerMeasured, ProcessorHandle<R>, Executor {
     private final String name;
@@ -32,7 +33,7 @@
     protected abstract boolean shouldRun(R task);
 
     public boolean isSameThread() {
-        return Thread.currentThread() == this.getRunningThread();
+        return !AsyncCatcher.isAsync();
     }
 
     protected abstract Thread getRunningThread();
diff --strip-trailing-cr -urN Original/Paper-Server/src/main/java/net/minecraft/world/level/entity/EntitySection.java Chiyogami/Paper-Server/src/main/java/net/minecraft/world/level/entity/EntitySection.java
--- Original/Paper-Server/src/main/java/net/minecraft/world/level/entity/EntitySection.java	2021-08-22 21:29:42.032046300 +0900
+++ Chiyogami/Paper-Server/src/main/java/net/minecraft/world/level/entity/EntitySection.java	2021-08-27 01:34:16.944126000 +0900
@@ -1,5 +1,10 @@
 package net.minecraft.world.level.entity;
 
+import java.lang.reflect.Field;
+import java.util.List;
+import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.CopyOnWriteArrayList;
 import java.util.function.Consumer;
 import java.util.function.Predicate;
 import java.util.stream.Stream;
@@ -19,7 +24,29 @@
 
     public EntitySection(Class<T> entityClass, Visibility status) {
         this.chunkStatus = status;
-        this.storage = new ClassInstanceMultiMap<>(entityClass);
+        this.storage = new ClassInstanceMultiMap<T>(entityClass){
+            {
+                Class<ClassInstanceMultiMap> classInstanceMultiMapClass = ClassInstanceMultiMap.class;
+                try {
+                    Field byClass = classInstanceMultiMapClass.getDeclaredField("a");
+                    Map<Class<?>, List<T>> newMap = new ConcurrentHashMap<>();
+                    
+                    Field allInstances = classInstanceMultiMapClass.getDeclaredField("c");
+                    List<T> newList = new CopyOnWriteArrayList<>();
+                    
+                    byClass.setAccessible(true);
+                    allInstances.setAccessible(true);
+                    
+                    newMap.put(entityClass, newList);
+                    
+                    byClass.set(this, newMap);
+                    allInstances.set(this, newList);
+    
+                } catch (Exception e) {
+                    e.printStackTrace();
+                }
+            }
+        };
     }
 
     public void add(T obj) {
diff --strip-trailing-cr -urN Original/Paper-Server/src/main/java/net/minecraft/world/level/Level.java Chiyogami/Paper-Server/src/main/java/net/minecraft/world/level/Level.java
--- Original/Paper-Server/src/main/java/net/minecraft/world/level/Level.java	2021-08-22 21:29:58.418893900 +0900
+++ Chiyogami/Paper-Server/src/main/java/net/minecraft/world/level/Level.java	2021-08-22 22:05:38.109168100 +0900
@@ -98,6 +98,7 @@
 import org.bukkit.craftbukkit.util.CraftNamespacedKey;
 import org.bukkit.event.block.BlockPhysicsEvent;
 import org.bukkit.event.world.GenericGameEvent;
+import org.spigotmc.AsyncCatcher;
 // CraftBukkit end
 
 public abstract class Level implements LevelAccessor, AutoCloseable {
@@ -919,7 +920,7 @@
         }
         // Paper end
         // CraftBukkit end
-        return this.isOutsideBuildHeight(blockposition) ? null : (!this.isClientSide && Thread.currentThread() != this.thread ? null : this.getChunkAt(blockposition).getBlockEntity(blockposition, LevelChunk.EntityCreationType.IMMEDIATE));
+        return this.isOutsideBuildHeight(blockposition) ? null : (!this.isClientSide && AsyncCatcher.isAsync() ? null : this.getChunkAt(blockposition).getBlockEntity(blockposition, LevelChunk.EntityCreationType.IMMEDIATE));
     }
 
     public void setBlockEntity(BlockEntity blockEntity) {
diff --strip-trailing-cr -urN Original/Paper-Server/src/main/java/org/bukkit/craftbukkit/CraftServer.java Chiyogami/Paper-Server/src/main/java/org/bukkit/craftbukkit/CraftServer.java
--- Original/Paper-Server/src/main/java/org/bukkit/craftbukkit/CraftServer.java	2021-08-22 21:29:59.057153000 +0900
+++ Chiyogami/Paper-Server/src/main/java/org/bukkit/craftbukkit/CraftServer.java	2021-08-22 22:05:38.137152600 +0900
@@ -230,6 +230,7 @@
 import org.bukkit.scheduler.BukkitWorker;
 import org.bukkit.util.StringUtil;
 import org.bukkit.util.permissions.DefaultPermissions;
+import org.spigotmc.AsyncCatcher;
 import org.yaml.snakeyaml.Yaml;
 import org.yaml.snakeyaml.constructor.SafeConstructor;
 import org.yaml.snakeyaml.error.MarkedYAMLException;
@@ -240,7 +241,7 @@
 import javax.annotation.Nonnull; // Paper
 
 public final class CraftServer implements Server {
-    private final String serverName = "Paper"; // Paper
+    private final String serverName = "Chiyogami"; // Paper
     private final String serverVersion;
     private final String bukkitVersion = Versioning.getBukkitVersion();
     private final Logger logger = Logger.getLogger("Minecraft");
@@ -2019,7 +2020,7 @@
 
     @Override
     public boolean isPrimaryThread() {
-        return Thread.currentThread().equals(console.serverThread) || Thread.currentThread().equals(net.minecraft.server.MinecraftServer.getServer().shutdownThread); // Paper - Fix issues with detecting main thread properly, the only time Watchdog will be used is during a crash shutdown which is a "try our best" scenario
+        return Thread.currentThread().equals(console.serverThread) || Thread.currentThread().equals(net.minecraft.server.MinecraftServer.getServer().shutdownThread) || !AsyncCatcher.isAsync(); // Paper - Fix issues with detecting main thread properly, the only time Watchdog will be used is during a crash shutdown which is a "try our best" scenario
     }
 
     // Paper start
diff --strip-trailing-cr -urN Original/Paper-Server/src/main/java/org/bukkit/craftbukkit/CraftWorld.java Chiyogami/Paper-Server/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
--- Original/Paper-Server/src/main/java/org/bukkit/craftbukkit/CraftWorld.java	2021-08-22 21:29:57.908182900 +0900
+++ Chiyogami/Paper-Server/src/main/java/org/bukkit/craftbukkit/CraftWorld.java	2021-08-22 22:05:38.155142600 +0900
@@ -257,6 +257,7 @@
 import org.bukkit.util.Consumer;
 import org.bukkit.util.RayTraceResult;
 import org.bukkit.util.Vector;
+import org.spigotmc.AsyncCatcher;
 
 public class CraftWorld implements World {
     public static final int CUSTOM_DIMENSION_OFFSET = 10;
@@ -486,7 +487,7 @@
     @Override
     public Chunk[] getLoadedChunks() {
         // Paper start
-        if (Thread.currentThread() != world.getLevel().thread) {
+        if (AsyncCatcher.isAsync()) {
             synchronized (world.getChunkSource().chunkMap.visibleChunkMap) {
                 Long2ObjectLinkedOpenHashMap<ChunkHolder> chunks = world.getChunkSource().chunkMap.visibleChunkMap;
                 return chunks.values().stream().map(ChunkHolder::getFullChunk).filter(Objects::nonNull).map(net.minecraft.world.level.chunk.LevelChunk::getBukkitChunk).toArray(Chunk[]::new);
diff --strip-trailing-cr -urN Original/Paper-Server/src/main/java/org/spigotmc/AsyncCatcher.java Chiyogami/Paper-Server/src/main/java/org/spigotmc/AsyncCatcher.java
--- Original/Paper-Server/src/main/java/org/spigotmc/AsyncCatcher.java	2021-08-22 21:29:25.658390500 +0900
+++ Chiyogami/Paper-Server/src/main/java/org/spigotmc/AsyncCatcher.java	2021-09-05 16:30:25.378424700 +0900
@@ -10,9 +10,16 @@
 
     public static void catchOp(String reason)
     {
-        if ( AsyncCatcher.enabled && Thread.currentThread() != MinecraftServer.getServer().serverThread )
+        if ( AsyncCatcher.enabled && Thread.currentThread() != MinecraftServer.getServer().serverThread
+            && !MinecraftServer.getServer().worldServerThreads.containsValue(Thread.currentThread())) // Chiyogami
         {
             throw new IllegalStateException( "Asynchronous " + reason + "!" );
         }
     }
+    
+    // Chiyogami
+    public static boolean isAsync(){
+        return Thread.currentThread() != MinecraftServer.getServer().serverThread
+            && !MinecraftServer.getServer().worldServerThreads.containsValue(Thread.currentThread());
+    }
 }
