diff --strip-trailing-cr -urN Original/Tuinity-Server/src/main/java/co/aikar/timings/WorldTimingsHandler.java Chiyogami/Tuinity-Server/src/main/java/co/aikar/timings/WorldTimingsHandler.java
--- Original/Tuinity-Server/src/main/java/co/aikar/timings/WorldTimingsHandler.java	2021-09-27 23:30:53.589081500 +0900
+++ Chiyogami/Tuinity-Server/src/main/java/co/aikar/timings/WorldTimingsHandler.java	2021-09-28 02:56:07.153734400 +0900
@@ -1,8 +1,12 @@
 package co.aikar.timings;
 
+import net.minecraft.server.Entity;
 import net.minecraft.server.World;
 import net.minecraft.server.WorldServer;
 
+import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
+
 /**
  * Set of timers per world, to track world specific timings.
  */
@@ -68,75 +72,85 @@
     public final Timing chunkUnloadPrepareSave;
     public final Timing chunkUnloadPOISerialization;
     public final Timing chunkUnloadDataSave;
+    
+    private final String name;
 
     public WorldTimingsHandler(World server) {
-        String name = server.worldData.getName() +" - ";
+        name = server.worldData.getName() +" - ";
 
-        mobSpawn = Timings.ofSafe(name + "mobSpawn");
-        doChunkUnload = Timings.ofSafe(name + "doChunkUnload");
-        scheduledBlocks = Timings.ofSafe(name + "Scheduled Blocks");
-        scheduledBlocksCleanup = Timings.ofSafe(name + "Scheduled Blocks - Cleanup");
-        scheduledBlocksTicking = Timings.ofSafe(name + "Scheduled Blocks - Ticking");
-        chunkTicks = Timings.ofSafe(name + "Chunk Ticks");
-        lightChunk = Timings.ofSafe(name + "Light Chunk");
-        chunkTicksBlocks = Timings.ofSafe(name + "Chunk Ticks - Blocks");
-        doVillages = Timings.ofSafe(name + "doVillages");
-        doChunkMap = Timings.ofSafe(name + "doChunkMap");
-        doChunkMapUpdate = Timings.ofSafe(name + "doChunkMap - Update");
-        doChunkMapToUpdate = Timings.ofSafe(name + "doChunkMap - To Update");
-        doChunkMapSortMissing = Timings.ofSafe(name + "doChunkMap - Sort Missing");
-        doChunkMapSortSendToPlayers = Timings.ofSafe(name + "doChunkMap - Sort Send To Players");
-        doChunkMapPlayersNeedingChunks = Timings.ofSafe(name + "doChunkMap - Players Needing Chunks");
-        doChunkMapPendingSendToPlayers = Timings.ofSafe(name + "doChunkMap - Pending Send To Players");
-        doChunkMapUnloadChunks = Timings.ofSafe(name + "doChunkMap - Unload Chunks");
-        doSounds = Timings.ofSafe(name + "doSounds");
-        doChunkGC = Timings.ofSafe(name + "doChunkGC");
-        doPortalForcer = Timings.ofSafe(name + "doPortalForcer");
-        entityTick = Timings.ofSafe(name + "entityTick");
-        entityRemoval = Timings.ofSafe(name + "entityRemoval");
-        tileEntityTick = Timings.ofSafe(name + "tileEntityTick");
-        tileEntityPending = Timings.ofSafe(name + "tileEntityPending");
-
-        chunkLoad = Timings.ofSafe(name + "Chunk Load");
-        chunkLoadPopulate = Timings.ofSafe(name + "Chunk Load - Populate");
-        syncChunkLoad = Timings.ofSafe(name + "Sync Chunk Load");
-        chunkLoadLevelTimer = Timings.ofSafe(name + "Chunk Load - Load Level");
-        chunkIO = Timings.ofSafe(name + "Chunk Load - DiskIO");
-        chunkPostLoad = Timings.ofSafe(name + "Chunk Load - Post Load");
-        worldSave = Timings.ofSafe(name + "World Save");
-        worldSaveLevel = Timings.ofSafe(name + "World Save - Level");
-        worldSaveChunks = Timings.ofSafe(name + "World Save - Chunks");
-        chunkSaveData = Timings.ofSafe(name + "Chunk Save - Data");
-
-        tracker1 = Timings.ofSafe(name + "tracker stage 1");
-        tracker2 = Timings.ofSafe(name + "tracker stage 2");
-        doTick = Timings.ofSafe(name + "doTick");
-        tickEntities = Timings.ofSafe(name + "tickEntities");
-
-        chunks = Timings.ofSafe(name + "Chunks");
-        newEntities = Timings.ofSafe(name + "New entity registration");
-        raids = Timings.ofSafe(name + "Raids");
-        chunkProviderTick = Timings.ofSafe(name + "Chunk provider tick");
-        broadcastChunkUpdates = Timings.ofSafe(name + "Broadcast chunk updates");
-        countNaturalMobs = Timings.ofSafe(name + "Count natural mobs");
-
-
-        miscMobSpawning = Timings.ofSafe(name + "Mob spawning - Misc");
-        playerMobDistanceMapUpdate = Timings.ofSafe(name + "Per Player Mob Spawning - Distance Map Update");
-
-        poiUnload = Timings.ofSafe(name + "Chunk unload - POI");
-        chunkUnload = Timings.ofSafe(name + "Chunk unload - Chunk");
-        poiSaveDataSerialization = Timings.ofSafe(name + "Chunk save - POI Data serialization");
-        chunkSave = Timings.ofSafe(name + "Chunk save - Chunk");
-        chunkSaveOverwriteCheck = Timings.ofSafe(name + "Chunk save - Chunk Overwrite Check");
-        chunkSaveDataSerialization = Timings.ofSafe(name + "Chunk save - Chunk Data serialization");
-        chunkSaveIOWait = Timings.ofSafe(name + "Chunk save - Chunk IO Wait");
-        chunkUnloadPrepareSave = Timings.ofSafe(name + "Chunk unload - Async Save Prepare");
-        chunkUnloadPOISerialization = Timings.ofSafe(name + "Chunk unload - POI Data Serialization");
-        chunkUnloadDataSave = Timings.ofSafe(name + "Chunk unload - Data Serialization");
+        mobSpawn = Timings.ofSafeW(name + "mobSpawn");
+        doChunkUnload = Timings.ofSafeW(name + "doChunkUnload");
+        scheduledBlocks = Timings.ofSafeW(name + "Scheduled Blocks");
+        scheduledBlocksCleanup = Timings.ofSafeW(name + "Scheduled Blocks - Cleanup");
+        scheduledBlocksTicking = Timings.ofSafeW(name + "Scheduled Blocks - Ticking");
+        chunkTicks = Timings.ofSafeW(name + "Chunk Ticks");
+        lightChunk = Timings.ofSafeW(name + "Light Chunk");
+        chunkTicksBlocks = Timings.ofSafeW(name + "Chunk Ticks - Blocks");
+        doVillages = Timings.ofSafeW(name + "doVillages");
+        doChunkMap = Timings.ofSafeW(name + "doChunkMap");
+        doChunkMapUpdate = Timings.ofSafeW(name + "doChunkMap - Update");
+        doChunkMapToUpdate = Timings.ofSafeW(name + "doChunkMap - To Update");
+        doChunkMapSortMissing = Timings.ofSafeW(name + "doChunkMap - Sort Missing");
+        doChunkMapSortSendToPlayers = Timings.ofSafeW(name + "doChunkMap - Sort Send To Players");
+        doChunkMapPlayersNeedingChunks = Timings.ofSafeW(name + "doChunkMap - Players Needing Chunks");
+        doChunkMapPendingSendToPlayers = Timings.ofSafeW(name + "doChunkMap - Pending Send To Players");
+        doChunkMapUnloadChunks = Timings.ofSafeW(name + "doChunkMap - Unload Chunks");
+        doSounds = Timings.ofSafeW(name + "doSounds");
+        doChunkGC = Timings.ofSafeW(name + "doChunkGC");
+        doPortalForcer = Timings.ofSafeW(name + "doPortalForcer");
+        entityTick = Timings.ofSafeW(name + "entityTick");
+        entityRemoval = Timings.ofSafeW(name + "entityRemoval");
+        tileEntityTick = Timings.ofSafeW(name + "tileEntityTick");
+        tileEntityPending = Timings.ofSafeW(name + "tileEntityPending");
+
+        chunkLoad = Timings.ofSafeW(name + "Chunk Load");
+        chunkLoadPopulate = Timings.ofSafeW(name + "Chunk Load - Populate");
+        syncChunkLoad = Timings.ofSafeW(name + "Sync Chunk Load");
+        chunkLoadLevelTimer = Timings.ofSafeW(name + "Chunk Load - Load Level");
+        chunkIO = Timings.ofSafeW(name + "Chunk Load - DiskIO");
+        chunkPostLoad = Timings.ofSafeW(name + "Chunk Load - Post Load");
+        worldSave = Timings.ofSafeW(name + "World Save");
+        worldSaveLevel = Timings.ofSafeW(name + "World Save - Level");
+        worldSaveChunks = Timings.ofSafeW(name + "World Save - Chunks");
+        chunkSaveData = Timings.ofSafeW(name + "Chunk Save - Data");
+
+        tracker1 = Timings.ofSafeW(name + "tracker stage 1");
+        tracker2 = Timings.ofSafeW(name + "tracker stage 2");
+        doTick = Timings.ofSafeW(name + "doTick");
+        tickEntities = Timings.ofSafeW(name + "tickEntities");
+
+        chunks = Timings.ofSafeW(name + "Chunks");
+        newEntities = Timings.ofSafeW(name + "New entity registration");
+        raids = Timings.ofSafeW(name + "Raids");
+        chunkProviderTick = Timings.ofSafeW(name + "Chunk provider tick");
+        broadcastChunkUpdates = Timings.ofSafeW(name + "Broadcast chunk updates");
+        countNaturalMobs = Timings.ofSafeW(name + "Count natural mobs");
+
+
+        miscMobSpawning = Timings.ofSafeW(name + "Mob spawning - Misc");
+        playerMobDistanceMapUpdate = Timings.ofSafeW(name + "Per Player Mob Spawning - Distance Map Update");
+
+        poiUnload = Timings.ofSafeW(name + "Chunk unload - POI");
+        chunkUnload = Timings.ofSafeW(name + "Chunk unload - Chunk");
+        poiSaveDataSerialization = Timings.ofSafeW(name + "Chunk save - POI Data serialization");
+        chunkSave = Timings.ofSafeW(name + "Chunk save - Chunk");
+        chunkSaveOverwriteCheck = Timings.ofSafeW(name + "Chunk save - Chunk Overwrite Check");
+        chunkSaveDataSerialization = Timings.ofSafeW(name + "Chunk save - Chunk Data serialization");
+        chunkSaveIOWait = Timings.ofSafeW(name + "Chunk save - Chunk IO Wait");
+        chunkUnloadPrepareSave = Timings.ofSafeW(name + "Chunk unload - Async Save Prepare");
+        chunkUnloadPOISerialization = Timings.ofSafeW(name + "Chunk unload - POI Data Serialization");
+        chunkUnloadDataSave = Timings.ofSafeW(name + "Chunk unload - Data Serialization");
     }
 
     public static Timing getTickList(WorldServer worldserver, String timingsType) {
-        return Timings.ofSafe(worldserver.getWorldData().getName() + " - Scheduled " + timingsType);
+        return Timings.ofSafeW(worldserver.getWorldData().getName() + " - Scheduled " + timingsType);
+    }
+    
+    
+    // Chiyogami - timings
+    private final Map<String, Timing> tickMap = new ConcurrentHashMap<>();
+    
+    public Timing getEntityTickTimer(Entity entity){
+        return tickMap.computeIfAbsent(entity.getClass().getName(), k -> Timings.ofSafeW(name + ": " + k + " - tick"));
     }
 }
diff --strip-trailing-cr -urN Original/Tuinity-Server/src/main/java/com/tuinity/tuinity/util/CachedLists.java Chiyogami/Tuinity-Server/src/main/java/com/tuinity/tuinity/util/CachedLists.java
--- Original/Tuinity-Server/src/main/java/com/tuinity/tuinity/util/CachedLists.java	2021-09-27 23:30:55.905497100 +0900
+++ Chiyogami/Tuinity-Server/src/main/java/com/tuinity/tuinity/util/CachedLists.java	2021-09-28 00:47:53.877161700 +0900
@@ -3,51 +3,174 @@
 import net.minecraft.server.AxisAlignedBB;
 import net.minecraft.server.Entity;
 import org.bukkit.Bukkit;
+import org.bukkit.World;
 import org.bukkit.craftbukkit.util.UnsafeList;
+import world.chiyogami.chiyogamilib.WorldThreads;
+
 import java.util.List;
+import java.util.Set;
+import java.util.concurrent.ConcurrentHashMap;
 
 public class CachedLists {
-
-    static final UnsafeList<AxisAlignedBB> TEMP_COLLISION_LIST = new UnsafeList<>(1024);
-    static boolean tempCollisionListInUse;
-
+    
+    private final World world;
+    
+    private final UnsafeList<AxisAlignedBB> TEMP_COLLISION_LIST = new UnsafeList<>(1024);
+    private boolean tempCollisionListInUse;
+    
+    private final UnsafeList<Entity> TEMP_GET_ENTITIES_LIST = new UnsafeList<>(1024);
+    private boolean tempGetEntitiesListInUse;
+    
+    private CachedLists(World world){
+        this.world = world;
+    }
+    
+    
+    
+    // Paper start - optimise collisions
+    static final Set<CachedLists> cashedListSet = ConcurrentHashMap.newKeySet();
+    
+    public static List<AxisAlignedBB> getTempCollisionList(World world) {
+        
+        for(CachedLists cachedLists : cashedListSet){
+            if(world == cachedLists.world){
+                if (!Bukkit.isPrimaryThread() || cachedLists.tempCollisionListInUse) {
+                    return new UnsafeList<>(16);
+                }
+                
+                cachedLists.tempCollisionListInUse = true;
+                return cachedLists.TEMP_COLLISION_LIST;
+            }
+        }
+        
+        CachedLists cachedLists = new CachedLists(world);
+        cachedLists.tempCollisionListInUse = true;
+        cashedListSet.add(cachedLists);
+        return cachedLists.TEMP_COLLISION_LIST;
+    }
+    
+    
     public static List<AxisAlignedBB> getTempCollisionList() {
-        if (!Bukkit.isPrimaryThread() || tempCollisionListInUse) {
+        
+        for(CachedLists cachedLists : cashedListSet){
+            World world = cachedLists.world;
+            Thread thread = WorldThreads.worldThreadMap.get(world);
+            
+            if(Thread.currentThread() == thread && !cachedLists.tempCollisionListInUse){
+                cachedLists.tempCollisionListInUse = true;
+                return cachedLists.TEMP_COLLISION_LIST;
+            }
+        }
+        
+        if (!Bukkit.isPrimaryThread()) {
             return new UnsafeList<>(16);
         }
-        tempCollisionListInUse = true;
-        return TEMP_COLLISION_LIST;
+        
+        UnsafeList<AxisAlignedBB> allList = new UnsafeList<>(1024);
+        for(CachedLists cachedLists : cashedListSet){
+            allList.addAll(cachedLists.TEMP_COLLISION_LIST);
+        }
+        return allList;
     }
-
+    
+    public static void returnTempCollisionList(List<AxisAlignedBB> list, World world) {
+        for(CachedLists cachedLists : cashedListSet){
+            if(world == cachedLists.world){
+                if (cachedLists.TEMP_COLLISION_LIST != list) {
+                    return;
+                }
+                
+                cachedLists.TEMP_COLLISION_LIST.setSize(0);
+                cachedLists.tempCollisionListInUse = false;
+                return;
+            }
+        }
+    }
+    
     public static void returnTempCollisionList(List<AxisAlignedBB> list) {
-        if (list != TEMP_COLLISION_LIST) {
-            return;
+        for(CachedLists cachedLists : cashedListSet){
+            if(cachedLists.TEMP_COLLISION_LIST == list){
+                cachedLists.TEMP_COLLISION_LIST.setSize(0);
+                cachedLists.tempCollisionListInUse = false;
+                return;
+            }
         }
-        ((UnsafeList)list).setSize(0);
-        tempCollisionListInUse = false;
+        
+        ((UnsafeList<?>)list).setSize(0);
     }
-
-    static final UnsafeList<Entity> TEMP_GET_ENTITIES_LIST = new UnsafeList<>(1024);
-    static boolean tempGetEntitiesListInUse;
-
-    public static List<Entity> getTempGetEntitiesList() {
-        if (!Bukkit.isPrimaryThread() || tempGetEntitiesListInUse) {
+    
+    
+    public static UnsafeList<Entity> getTempGetEntitiesList(World world) {
+        for(CachedLists cachedLists : cashedListSet){
+            if(world == cachedLists.world){
+                if (!Bukkit.isPrimaryThread() || cachedLists.tempGetEntitiesListInUse) {
+                    return new UnsafeList<>(16);
+                }
+                
+                cachedLists.tempGetEntitiesListInUse = true;
+                return cachedLists.TEMP_GET_ENTITIES_LIST;
+            }
+        }
+        
+        CachedLists cachedLists = new CachedLists(world);
+        cachedLists.tempGetEntitiesListInUse = true;
+        cashedListSet.add(cachedLists);
+        return cachedLists.TEMP_GET_ENTITIES_LIST;
+    }
+    
+    public static UnsafeList<Entity> getTempGetEntitiesList() {
+        for(CachedLists cachedLists : cashedListSet){
+            World world = cachedLists.world;
+            Thread thread = WorldThreads.worldThreadMap.get(world);
+            
+            if(Thread.currentThread() == thread && !cachedLists.tempGetEntitiesListInUse){
+                cachedLists.tempGetEntitiesListInUse = true;
+                return cachedLists.TEMP_GET_ENTITIES_LIST;
+            }
+        }
+        
+        if (!Bukkit.isPrimaryThread()) {
             return new UnsafeList<>(16);
         }
-        tempGetEntitiesListInUse = true;
-        return TEMP_GET_ENTITIES_LIST;
+        
+        UnsafeList<Entity> allList = new UnsafeList<>(1024);
+        for(CachedLists cachedLists : cashedListSet){
+            allList.addAll(cachedLists.TEMP_GET_ENTITIES_LIST);
+        }
+        return allList;
     }
-
+    
+    public static void returnTempGetEntitiesList(List<Entity> list, World world) {
+        for(CachedLists cachedLists : cashedListSet){
+            if(world == cachedLists.world){
+                if (cachedLists.TEMP_GET_ENTITIES_LIST != list) {
+                    return;
+                }
+                
+                cachedLists.TEMP_GET_ENTITIES_LIST.setSize(0);
+                cachedLists.tempGetEntitiesListInUse = false;
+                return;
+            }
+        }
+    }
+    
     public static void returnTempGetEntitiesList(List<Entity> list) {
-        if (list != TEMP_GET_ENTITIES_LIST) {
-            return;
+        for(CachedLists cachedLists : cashedListSet){
+            if(cachedLists.TEMP_GET_ENTITIES_LIST == list){
+                cachedLists.TEMP_GET_ENTITIES_LIST.setSize(0);
+                cachedLists.tempGetEntitiesListInUse = false;
+                return;
+            }
         }
-        ((UnsafeList)list).setSize(0);
-        tempGetEntitiesListInUse = false;
+        
+        ((UnsafeList<?>)list).setSize(0);
     }
-
+    
+    
     public static void reset() {
-        TEMP_COLLISION_LIST.completeReset();
-        TEMP_GET_ENTITIES_LIST.completeReset();
+        for(CachedLists cachedLists : cashedListSet){
+            cachedLists.TEMP_COLLISION_LIST.completeReset();
+            cachedLists.TEMP_GET_ENTITIES_LIST.completeReset();
+        }
     }
 }
diff --strip-trailing-cr -urN Original/Tuinity-Server/src/main/java/net/minecraft/server/Chunk.java Chiyogami/Tuinity-Server/src/main/java/net/minecraft/server/Chunk.java
--- Original/Tuinity-Server/src/main/java/net/minecraft/server/Chunk.java	2021-09-27 23:30:56.485164600 +0900
+++ Chiyogami/Tuinity-Server/src/main/java/net/minecraft/server/Chunk.java	2021-09-28 00:41:22.912279500 +0900
@@ -14,6 +14,7 @@
 import java.util.Map;
 import java.util.Set;
 import java.util.Map.Entry;
+import java.util.concurrent.CopyOnWriteArrayList;
 import java.util.function.Consumer;
 import java.util.function.Predicate;
 import java.util.function.Supplier;
@@ -162,7 +163,7 @@
         }
 
         for (int l = 0; l < this.entitySlices.length; ++l) {
-            this.entitySlices[l] = new org.bukkit.craftbukkit.util.UnsafeList(); // Spigot
+            this.entitySlices[l] = new CopyOnWriteArrayList<>(); // Spigot
         }
 
         this.d = biomestorage;
diff --strip-trailing-cr -urN Original/Tuinity-Server/src/main/java/net/minecraft/server/ChunkMapDistance.java Chiyogami/Tuinity-Server/src/main/java/net/minecraft/server/ChunkMapDistance.java
--- Original/Tuinity-Server/src/main/java/net/minecraft/server/ChunkMapDistance.java	2021-09-27 23:30:55.165313600 +0900
+++ Chiyogami/Tuinity-Server/src/main/java/net/minecraft/server/ChunkMapDistance.java	2021-09-28 02:18:02.030403800 +0900
@@ -17,9 +17,14 @@
 import it.unimi.dsi.fastutil.objects.ObjectIterator;
 import it.unimi.dsi.fastutil.objects.ObjectOpenHashSet;
 import it.unimi.dsi.fastutil.objects.ObjectSet;
+
+import java.util.Iterator;
+import java.util.Map;
 import java.util.Set;
 import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.Executor;
+import java.util.concurrent.locks.ReentrantLock;
 import javax.annotation.Nullable;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
@@ -29,8 +34,8 @@
 
     private static final Logger LOGGER = LogManager.getLogger();
     private static final int b = 33 + ChunkStatus.a(ChunkStatus.FULL) - 2;
-    private final Long2ObjectMap<ObjectSet<EntityPlayer>> c = new Long2ObjectOpenHashMap();
-    public final Long2ObjectOpenHashMap<ArraySetSorted<Ticket<?>>> tickets = new Long2ObjectOpenHashMap();
+    private final Map<Long, Set<EntityPlayer>> c = new ConcurrentHashMap<>();
+    public final Map<Long, ArraySetSorted<Ticket<?>>> tickets = new ConcurrentHashMap<>();
     private final ChunkMapDistance.a e = new ChunkMapDistance.a(); final ChunkMapDistance.a getTicketTracker() { return this.e; } // Tuinity - OBFHELPER
     public static final int MOB_SPAWN_RANGE = 8; //private final ChunkMapDistance.b f = new ChunkMapDistance.b(8); // Paper - no longer used
     private final ChunkMapDistance.c g = new ChunkMapDistance.c(33);
@@ -52,23 +57,30 @@
     private long currentTick;
 
     PlayerChunkMap chunkMap; // Paper
+    
+    private final ReentrantLock LOCK = new ReentrantLock(true);
 
     // Tuinity start - delay chunk unloads
     private long nextUnloadId; // delay chunk unloads
     private final Long2ObjectOpenHashMap<Ticket<Long>> delayedChunks = new Long2ObjectOpenHashMap<>();
     public final void removeTickets(long chunk, TicketType<?> type) {
-        ArraySetSorted<Ticket<?>> tickets = this.tickets.get(chunk);
-        if (tickets == null) {
-            return;
-        }
-        if (type == TicketType.DELAYED_UNLOAD) {
-            this.delayedChunks.remove(chunk);
-        }
-        boolean changed = tickets.removeIf((Ticket<?> ticket) -> {
-            return ticket.getTicketType() == type;
-        });
-        if (changed) {
-            this.getTicketTracker().update(chunk, getLowestTicketLevel(tickets), false);
+        try {
+            LOCK.lock();
+            ArraySetSorted<Ticket<?>> tickets = this.tickets.get(chunk);
+            if (tickets == null) {
+                return;
+            }
+            if (type == TicketType.DELAYED_UNLOAD) {
+                this.delayedChunks.remove(chunk);
+            }
+            boolean changed = tickets.removeIf((Ticket<?> ticket) -> {
+                return ticket.getTicketType() == type;
+            });
+            if (changed) {
+                this.getTicketTracker().update(chunk, getLowestTicketLevel(tickets), false);
+            }
+        } finally {
+            LOCK.unlock();
         }
     }
 
@@ -79,18 +91,23 @@
     };
 
     private void computeDelayedTicketFor(long chunk, int removedLevel, ArraySetSorted<Ticket<?>> tickets) {
-        int lowestLevel = getLowestTicketLevel(tickets);
-        if (removedLevel > lowestLevel) {
-            return;
-        }
-        final Ticket<Long> ticket = this.delayedChunks.computeIfAbsent(chunk, this.computeFuntion);
-        if (ticket.getTicketLevel() != -1) {
-            // since we modify data used in sorting, we need to remove before
-            tickets.remove(ticket);
-        }
-        ticket.setCreationTick(this.currentTick);
-        ticket.setTicketLevel(removedLevel);
-        tickets.add(ticket); // re-add with new expire time and ticket level
+        try {
+            LOCK.lock();
+            int lowestLevel = getLowestTicketLevel(tickets);
+            if (removedLevel > lowestLevel) {
+                return;
+            }
+            final Ticket<Long> ticket = this.delayedChunks.computeIfAbsent(chunk, this.computeFuntion);
+            if (ticket.getTicketLevel() != -1) {
+                // since we modify data used in sorting, we need to remove before
+                tickets.remove(ticket);
+            }
+            ticket.setCreationTick(this.currentTick);
+            ticket.setTicketLevel(removedLevel);
+            tickets.add(ticket); // re-add with new expire time and ticket level
+        } finally {
+            LOCK.unlock();
+        }
     }
     // Tuinity end - delay chunk unloads
 
@@ -106,42 +123,46 @@
     }
 
     protected void purgeTickets() {
-        com.tuinity.tuinity.util.TickThread.softEnsureTickThread("Async purge tickets"); // Tuinity
-        ++this.currentTick;
-        ObjectIterator objectiterator = this.tickets.long2ObjectEntrySet().fastIterator();
-
-        int[] tempLevel = new int[] { PlayerChunkMap.GOLDEN_TICKET + 1 }; // Tuinity - delay chunk unloads
-        while (objectiterator.hasNext()) {
-            Entry<ArraySetSorted<Ticket<?>>> entry = (Entry) objectiterator.next();
-
-            if ((entry.getValue()).removeIf((ticket) -> { // CraftBukkit - decompile error
-                // Tuinity start - delay chunk unloads
-                boolean ret = ticket.isExpired(this.currentTick);
-                if (com.tuinity.tuinity.config.TuinityConfig.delayChunkUnloadsBy <= 0) {
+        try {
+            LOCK.lock();
+            com.tuinity.tuinity.util.TickThread.softEnsureTickThread("Async purge tickets"); // Tuinity
+            ++this.currentTick;
+            Iterator objectiterator = this.tickets.entrySet().iterator();
+    
+            int[] tempLevel = new int[]{PlayerChunkMap.GOLDEN_TICKET + 1}; // Tuinity - delay chunk unloads
+            while (objectiterator.hasNext()) {
+                Map.Entry<Long, ArraySetSorted<Ticket<?>>> entry = (Map.Entry) objectiterator.next();
+        
+                if ((entry.getValue()).removeIf((ticket) -> { // CraftBukkit - decompile error
+                    // Tuinity start - delay chunk unloads
+                    boolean ret = ticket.isExpired(this.currentTick);
+                    if (com.tuinity.tuinity.config.TuinityConfig.delayChunkUnloadsBy <= 0) {
+                        return ret;
+                    }
+                    if (ret && ticket.getTicketType() != TicketType.DELAYED_UNLOAD && ticket.getTicketLevel() < tempLevel[0]) {
+                        tempLevel[0] = ticket.getTicketLevel();
+                    }
+                    if (ticket.getTicketType() == TicketType.DELAYED_UNLOAD && ticket.isCached) {
+                        this.delayedChunks.remove(entry.getKey(), ticket); // clean up ticket...
+                    }
                     return ret;
+                    // Tuinity end - delay chunk unloads
+                })) {
+                    // Tuinity start - delay chunk unloads
+                    if (tempLevel[0] < (PlayerChunkMap.GOLDEN_TICKET + 1)) {
+                        this.computeDelayedTicketFor(entry.getKey(), tempLevel[0], entry.getValue());
+                    }
+                    // Tuinity end - delay chunk unloads
+                    this.e.b(entry.getKey(), a((ArraySetSorted) entry.getValue()), false);
                 }
-                if (ret && ticket.getTicketType() != TicketType.DELAYED_UNLOAD && ticket.getTicketLevel() < tempLevel[0]) {
-                    tempLevel[0] = ticket.getTicketLevel();
-                }
-                if (ticket.getTicketType() == TicketType.DELAYED_UNLOAD && ticket.isCached) {
-                    this.delayedChunks.remove(entry.getLongKey(), ticket); // clean up ticket...
-                }
-                return ret;
-                // Tuinity end - delay chunk unloads
-            })) {
-                // Tuinity start - delay chunk unloads
-                if (tempLevel[0] < (PlayerChunkMap.GOLDEN_TICKET + 1)) {
-                    this.computeDelayedTicketFor(entry.getLongKey(), tempLevel[0], entry.getValue());
+        
+                if (((ArraySetSorted) entry.getValue()).isEmpty()) {
+                    objectiterator.remove();
                 }
-                // Tuinity end - delay chunk unloads
-                this.e.b(entry.getLongKey(), a((ArraySetSorted) entry.getValue()), false);
-            }
-
-            if (((ArraySetSorted) entry.getValue()).isEmpty()) {
-                objectiterator.remove();
             }
+        } finally {
+            LOCK.unlock();
         }
-
     }
 
     private static int getLowestTicketLevel(ArraySetSorted<Ticket<?>> arraysetsorted) { return a(arraysetsorted); } // Tuinity - OBFHELPER
@@ -436,8 +457,8 @@
         com.tuinity.tuinity.util.TickThread.softEnsureTickThread("Async player add"); // Tuinity
         long i = sectionposition.u().pair();
 
-        ((ObjectSet) this.c.computeIfAbsent(i, (j) -> {
-            return new ObjectOpenHashSet();
+        ((Set) this.c.computeIfAbsent(i, (j) -> {
+            return ConcurrentHashMap.newKeySet();
         })).add(entityplayer);
         //this.f.b(i, 0, true); // Paper - no longer used
         this.g.b(i, 0, true);
@@ -446,7 +467,7 @@
     public void b(SectionPosition sectionposition, EntityPlayer entityplayer) {
         com.tuinity.tuinity.util.TickThread.softEnsureTickThread("Async player remove"); // Tuinity
         long i = sectionposition.u().pair();
-        ObjectSet<EntityPlayer> objectset = (ObjectSet) this.c.get(i);
+        Set<EntityPlayer> objectset = (Set) this.c.get(i);
 
         if (objectset != null) objectset.remove(entityplayer); // Paper - some state corruption happens here, don't crash, clean up gracefully.
         if (objectset == null || objectset.isEmpty()) { // Paper
@@ -497,12 +518,12 @@
         com.tuinity.tuinity.util.TickThread.softEnsureTickThread("Async ticket remove"); // Tuinity
         Ticket<T> target = new Ticket<>(ticketType, ticketLevel, ticketIdentifier);
 
-        for (java.util.Iterator<Entry<ArraySetSorted<Ticket<?>>>> iterator = this.tickets.long2ObjectEntrySet().fastIterator(); iterator.hasNext();) {
-            Entry<ArraySetSorted<Ticket<?>>> entry = iterator.next();
+        for (java.util.Iterator<Map.Entry<Long, ArraySetSorted<Ticket<?>>>> iterator = this.tickets.entrySet().iterator(); iterator.hasNext();) {
+            Map.Entry<Long, ArraySetSorted<Ticket<?>>> entry = iterator.next();
             ArraySetSorted<Ticket<?>> tickets = entry.getValue();
             if (tickets.remove(target)) {
                 // copied from removeTicket
-                this.e.b(entry.getLongKey(), a(tickets), false); // PAIL ticketLevelTracker // PAIL update // PAIL getLowestTicketLevel
+                this.e.b(entry.getKey(), a(tickets), false); // PAIL ticketLevelTracker // PAIL update // PAIL getLowestTicketLevel
 
                 // can't use entry after it's removed
                 if (tickets.isEmpty()) {
@@ -813,7 +834,7 @@
         }
 
         private boolean d(long i) {
-            ObjectSet<EntityPlayer> objectset = (ObjectSet) ChunkMapDistance.this.c.get(i);
+            Set<EntityPlayer> objectset = (Set) ChunkMapDistance.this.c.get(i);
 
             return objectset != null && !objectset.isEmpty();
         }
diff --strip-trailing-cr -urN Original/Tuinity-Server/src/main/java/net/minecraft/server/ChunkProviderServer.java Chiyogami/Tuinity-Server/src/main/java/net/minecraft/server/ChunkProviderServer.java
--- Original/Tuinity-Server/src/main/java/net/minecraft/server/ChunkProviderServer.java	2021-09-27 23:30:56.603097400 +0900
+++ Chiyogami/Tuinity-Server/src/main/java/net/minecraft/server/ChunkProviderServer.java	2021-09-28 00:28:14.065429700 +0900
@@ -18,6 +18,7 @@
 import com.destroystokyo.paper.exception.ServerInternalException;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
+import org.spigotmc.AsyncCatcher;
 
 public class ChunkProviderServer extends IChunkProvider {
 
@@ -121,7 +122,7 @@
     long chunkFutureAwaitCounter; // Tuinity - private -> package private
 
     public void getEntityTickingChunkAsync(int x, int z, java.util.function.Consumer<Chunk> onLoad) {
-        if (Thread.currentThread() != this.serverThread) {
+        if (AsyncCatcher.isAsync()) {
             this.serverThreadQueue.execute(() -> {
                 ChunkProviderServer.this.getEntityTickingChunkAsync(x, z, onLoad);
             });
@@ -131,7 +132,7 @@
     }
 
     public void getTickingChunkAsync(int x, int z, java.util.function.Consumer<Chunk> onLoad) {
-        if (Thread.currentThread() != this.serverThread) {
+        if (AsyncCatcher.isAsync()) {
             this.serverThreadQueue.execute(() -> {
                 ChunkProviderServer.this.getTickingChunkAsync(x, z, onLoad);
             });
@@ -141,7 +142,7 @@
     }
 
     public void getFullChunkAsync(int x, int z, java.util.function.Consumer<Chunk> onLoad) {
-        if (Thread.currentThread() != this.serverThread) {
+        if (AsyncCatcher.isAsync()) {
             this.serverThreadQueue.execute(() -> {
                 ChunkProviderServer.this.getFullChunkAsync(x, z, onLoad);
             });
@@ -151,7 +152,7 @@
     }
 
     private void getChunkFutureAsynchronously(int x, int z, int ticketLevel, Function<PlayerChunk, CompletableFuture<Either<Chunk, PlayerChunk.Failure>>> futureGet, java.util.function.Consumer<Chunk> onLoad) {
-        if (Thread.currentThread() != this.serverThread) {
+        if (AsyncCatcher.isAsync()) {
             throw new IllegalStateException();
         }
         ChunkCoordIntPair chunkPos = new ChunkCoordIntPair(x, z);
@@ -250,7 +251,7 @@
     void getChunkAtAsynchronously(int chunkX, int chunkZ, int ticketLevel,
                                           java.util.function.Function<PlayerChunk, CompletableFuture<Either<IChunkAccess, PlayerChunk.Failure>>> function,
                                           java.util.function.Consumer<IChunkAccess> consumer) {
-        if (Thread.currentThread() != this.serverThread) {
+        if (AsyncCatcher.isAsync()) {
             throw new IllegalStateException();
         }
         ChunkCoordIntPair chunkPos = new ChunkCoordIntPair(chunkX, chunkZ);
@@ -437,7 +438,7 @@
     public Chunk getChunkAtIfLoadedImmediately(int x, int z) {
         long k = ChunkCoordIntPair.pair(x, z);
 
-        if (Thread.currentThread() == this.serverThread) {
+        if (!AsyncCatcher.isAsync()) {
             return this.getChunkAtIfLoadedMainThread(x, z);
         }
 
@@ -477,7 +478,7 @@
     private long asyncLoadSeqCounter;
 
     public CompletableFuture<Either<IChunkAccess, PlayerChunk.Failure>> getChunkAtAsynchronously(int x, int z, boolean gen, boolean isUrgent) {
-        if (Thread.currentThread() != this.serverThread) {
+        if (AsyncCatcher.isAsync()) {
             CompletableFuture<Either<IChunkAccess, PlayerChunk.Failure>> future = new CompletableFuture<Either<IChunkAccess, PlayerChunk.Failure>>();
             this.serverThreadQueue.execute(() -> {
                 this.getChunkAtAsynchronously(x, z, gen, isUrgent).whenComplete((chunk, ex) -> {
@@ -625,7 +626,7 @@
     @Override
     public IChunkAccess getChunkAt(int i, int j, ChunkStatus chunkstatus, boolean flag) {
         final int x = i; final int z = j; // Paper - conflict on variable change
-        if (Thread.currentThread() != this.serverThread) {
+        if (AsyncCatcher.isAsync()) {
             return (IChunkAccess) CompletableFuture.supplyAsync(() -> {
                 return this.getChunkAt(i, j, chunkstatus, flag);
             }, this.serverThreadQueue).join();
@@ -687,7 +688,7 @@
     @Nullable
     @Override
     public Chunk a(int i, int j) {
-        if (Thread.currentThread() != this.serverThread) {
+        if (AsyncCatcher.isAsync()) {
             return null;
         } else {
             return this.getChunkAtIfLoadedMainThread(i, j); // Paper - optimise for loaded chunks
diff --strip-trailing-cr -urN Original/Tuinity-Server/src/main/java/net/minecraft/server/Entity.java Chiyogami/Tuinity-Server/src/main/java/net/minecraft/server/Entity.java
--- Original/Tuinity-Server/src/main/java/net/minecraft/server/Entity.java	2021-09-27 23:30:55.918490200 +0900
+++ Chiyogami/Tuinity-Server/src/main/java/net/minecraft/server/Entity.java	2021-09-28 00:47:53.888155400 +0900
@@ -977,7 +977,7 @@
         WorldServer world = ((WorldServer)this.world);
         AxisAlignedBB currBoundingBox = contractAmount == 0.0 ? this.getBoundingBox() : this.getBoundingBox().grow(-contractAmount);
 
-        List<AxisAlignedBB> potentialCollisions = com.tuinity.tuinity.util.CachedLists.getTempCollisionList();
+        List<AxisAlignedBB> potentialCollisions = com.tuinity.tuinity.util.CachedLists.getTempCollisionList(world.getWorld());
         try {
             // We take a fat guess that we actually need to do the step height checks.
             // So we collect all of the AABB's we would ever need into one list, and use that list
@@ -1021,7 +1021,7 @@
                 return limitedMoveVector;
             }
         } finally {
-            com.tuinity.tuinity.util.CachedLists.returnTempCollisionList(potentialCollisions);
+            com.tuinity.tuinity.util.CachedLists.returnTempCollisionList(potentialCollisions, world.getWorld());
         }
     }
     // Tuinity end - optimise entity movement
diff --strip-trailing-cr -urN Original/Tuinity-Server/src/main/java/net/minecraft/server/EntityLiving.java Chiyogami/Tuinity-Server/src/main/java/net/minecraft/server/EntityLiving.java
--- Original/Tuinity-Server/src/main/java/net/minecraft/server/EntityLiving.java	2021-09-27 23:30:56.008437600 +0900
+++ Chiyogami/Tuinity-Server/src/main/java/net/minecraft/server/EntityLiving.java	2021-09-28 00:47:53.869166000 +0900
@@ -2683,7 +2683,7 @@
         }
         // Paper - end don't run getEntities if we're not going to use its result
         // Tuinity start - reduce memory allocation from collideNearby
-        List<Entity> list = com.tuinity.tuinity.util.CachedLists.getTempGetEntitiesList();
+        List<Entity> list = com.tuinity.tuinity.util.CachedLists.getTempGetEntitiesList(world.getWorld());
         this.world.getEntities(this, this.getBoundingBox(), IEntitySelector.a(this), list);
         try {
         // Tuinity end - reduce memory allocation from collideNearby
@@ -2716,7 +2716,7 @@
             }
         }
         } finally { // Tuinity start - reduce memory allocation from collideNearby
-            com.tuinity.tuinity.util.CachedLists.returnTempGetEntitiesList(list);
+            com.tuinity.tuinity.util.CachedLists.returnTempGetEntitiesList(list, world.getWorld());
         } // Tuinity end - reduce memory allocation from collideNearby
 
     }
diff --strip-trailing-cr -urN Original/Tuinity-Server/src/main/java/net/minecraft/server/IAsyncTaskHandler.java Chiyogami/Tuinity-Server/src/main/java/net/minecraft/server/IAsyncTaskHandler.java
--- Original/Tuinity-Server/src/main/java/net/minecraft/server/IAsyncTaskHandler.java	2021-09-27 23:30:53.830545900 +0900
+++ Chiyogami/Tuinity-Server/src/main/java/net/minecraft/server/IAsyncTaskHandler.java	2021-09-28 00:28:14.046440900 +0900
@@ -8,6 +8,7 @@
 import java.util.function.BooleanSupplier;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
+import org.spigotmc.AsyncCatcher;
 
 public abstract class IAsyncTaskHandler<R extends Runnable> implements Mailbox<R>, Executor {
 
@@ -25,7 +26,7 @@
     protected abstract boolean canExecute(R r0);
 
     public boolean isMainThread() {
-        return Thread.currentThread() == this.getThread();
+        return !AsyncCatcher.isAsync();
     }
 
     protected abstract Thread getThread();
diff --strip-trailing-cr -urN Original/Tuinity-Server/src/main/java/net/minecraft/server/MCUtil.java Chiyogami/Tuinity-Server/src/main/java/net/minecraft/server/MCUtil.java
--- Original/Tuinity-Server/src/main/java/net/minecraft/server/MCUtil.java	2021-09-27 23:30:56.488164200 +0900
+++ Chiyogami/Tuinity-Server/src/main/java/net/minecraft/server/MCUtil.java	2021-09-28 00:28:14.055435600 +0900
@@ -317,7 +317,7 @@
      * @return
      */
     public static void ensureMain(String reason, Runnable run) {
-        if (AsyncCatcher.enabled && Thread.currentThread() != MinecraftServer.getServer().serverThread) {
+        if (AsyncCatcher.enabled && AsyncCatcher.isAsync()) {
             if (reason != null) {
                 new IllegalStateException("Asynchronous " + reason + "!").printStackTrace();
             }
@@ -342,7 +342,7 @@
      * @return
      */
     public static <T> T ensureMain(String reason, Supplier<T> run) {
-        if (AsyncCatcher.enabled && Thread.currentThread() != MinecraftServer.getServer().serverThread) {
+        if (AsyncCatcher.enabled && AsyncCatcher.isAsync()) {
             if (reason != null) {
                 new IllegalStateException("Asynchronous " + reason + "! Blocking thread until it returns ").printStackTrace();
             }
diff --strip-trailing-cr -urN Original/Tuinity-Server/src/main/java/net/minecraft/server/MinecraftServer.java Chiyogami/Tuinity-Server/src/main/java/net/minecraft/server/MinecraftServer.java
--- Original/Tuinity-Server/src/main/java/net/minecraft/server/MinecraftServer.java	2021-09-27 23:30:55.925485100 +0900
+++ Chiyogami/Tuinity-Server/src/main/java/net/minecraft/server/MinecraftServer.java	2021-09-28 01:11:43.675591400 +0900
@@ -1,5 +1,6 @@
 package net.minecraft.server;
 
+import co.aikar.timings.TimingHandler;
 import com.google.common.base.Splitter;
 import co.aikar.timings.Timings;
 import com.destroystokyo.paper.event.server.PaperServerListPingEvent;
@@ -48,6 +49,7 @@
 import java.util.UUID;
 import java.util.Map.Entry;
 import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.Executor;
 import java.util.function.BooleanSupplier;
 import javax.annotation.Nullable;
@@ -68,6 +70,10 @@
 // CraftBukkit end
 import co.aikar.timings.MinecraftTimings; // Paper
 import org.spigotmc.SlackActivityAccountant; // Spigot
+import world.chiyogami.chiyogamilib.WorldThreads;
+import world.chiyogami.chiyogamilib.monitor.PerformanceMonitor;
+import world.chiyogami.chiyogamilib.monitor.WorkMode;
+import world.chiyogami.chiyogamilib.scheduler.WorldThreadRunnable;
 
 public abstract class MinecraftServer extends IAsyncTaskHandlerReentrant<TickTask> implements IMojangStatistics, ICommandListener, AutoCloseable, Runnable {
 
@@ -1082,6 +1088,7 @@
 
     public final void executeMidTickTasks() {
         org.spigotmc.AsyncCatcher.catchOp("mid tick chunk task execution");
+        if(Thread.currentThread() != this.serverThread) return;
         long startTime = System.nanoTime();
         if ((startTime - lastMidTickExecute) <= CHUNK_TASK_QUEUE_BACKOFF_MIN_TIME || (startTime - lastMidTickExecuteFailure) <= TASK_EXECUTION_FAILURE_BACKOFF) {
             // it's shown to be bad to constantly hit the queue (chunk loads slow to a crawl), even if no tasks are executed.
@@ -1222,6 +1229,7 @@
     protected void exit() {}
 
     protected void a(BooleanSupplier booleansupplier) {
+        long fullServerTickNanoTime = System.nanoTime(); // Chiyogami
         co.aikar.timings.TimingsManager.FULL_SERVER_TICK.startTiming(); // Paper
         this.slackActivityAccountant.tickStarted(); // Spigot
         long i = SystemUtils.getMonotonicNanos();
@@ -1317,6 +1325,7 @@
         org.spigotmc.WatchdogThread.tick(); // Spigot
         this.slackActivityAccountant.tickEnded(l); // Spigot
         co.aikar.timings.TimingsManager.FULL_SERVER_TICK.stopTiming(); // Paper
+        PerformanceMonitor.setFullServerTickNanoTime(System.nanoTime() - fullServerTickNanoTime); // Chiyogami
     }
 
     protected void b(BooleanSupplier booleansupplier) {
@@ -1362,16 +1371,27 @@
         }
         // Paper end
         MinecraftTimings.timeUpdateTimer.stopTiming(); // Spigot // Paper
-
+    
+        long worldServerTickNanoTime = System.nanoTime();
+        Map<org.bukkit.World, Long> worldThreadTimeMap = new ConcurrentHashMap<>();
         while (iterator.hasNext()) {
             WorldServer worldserver = (WorldServer) iterator.next();
-
-            worldserver.hasPhysicsEvent =  org.bukkit.event.block.BlockPhysicsEvent.getHandlerList().getRegisteredListeners().length > 0; // Paper
-            TileEntityHopper.skipHopperEvents = worldserver.paperConfig.disableHopperMoveEvents || org.bukkit.event.inventory.InventoryMoveItemEvent.getHandlerList().getRegisteredListeners().length == 0; // Paper
-            if (true || worldserver.worldProvider.getDimensionManager() == DimensionManager.OVERWORLD || this.getAllowNether()) { // CraftBukkit
-                this.methodProfiler.a(() -> {
-                    return worldserver.getWorldData().getName() + " " + IRegistry.DIMENSION_TYPE.getKey(worldserver.worldProvider.getDimensionManager());
-                });
+    
+            Thread worldServerThread = new Thread(() -> {
+    
+                TimingHandler.initializeWorldTiming();
+    
+                long worldServerThreadNanoTime = System.nanoTime();
+    
+                WorldThreadRunnable.worldThreadHeartBeat(worldserver.getWorld(), currentTick); // Chiyogami
+    
+    
+                worldserver.hasPhysicsEvent = org.bukkit.event.block.BlockPhysicsEvent.getHandlerList().getRegisteredListeners().length > 0; // Paper
+                TileEntityHopper.skipHopperEvents = worldserver.paperConfig.disableHopperMoveEvents || org.bukkit.event.inventory.InventoryMoveItemEvent.getHandlerList().getRegisteredListeners().length == 0; // Paper
+                if (true || worldserver.worldProvider.getDimensionManager() == DimensionManager.OVERWORLD || this.getAllowNether()) { // CraftBukkit
+                    this.methodProfiler.a(() -> {
+                        return worldserver.getWorldData().getName() + " " + IRegistry.DIMENSION_TYPE.getKey(worldserver.worldProvider.getDimensionManager());
+                    });
                 /* Drop global time updates
                 if (this.ticks % 20 == 0) {
                     this.methodProfiler.enter("timeSync");
@@ -1379,35 +1399,65 @@
                     this.methodProfiler.exit();
                 }
                 // CraftBukkit end */
-
-                this.methodProfiler.enter("tick");
-
-                try {
-                    // Tuinity - replace logic
-                    worldserver.timings.doTick.startTiming(); // Spigot
-                    worldserver.doTick(booleansupplier);
-                    worldserver.timings.doTick.stopTiming(); // Spigot
-                    // Tuinity - replace logic
-                } catch (Throwable throwable) {
-                    // Spigot Start
-                    if (throwable instanceof ThreadDeath) { throw throwable; } // Paper
-                    CrashReport crashreport;
+        
+                    this.methodProfiler.enter("tick");
+        
                     try {
-                        crashreport = CrashReport.a(throwable, "Exception ticking world");
-                    } catch (Throwable t) {
-                        throw new RuntimeException("Error generating crash report", t);
+                        // Tuinity - replace logic
+                        ((TimingHandler.WorldTiming)worldserver.timings.doTick).startTiming(true); // Spigot
+                        worldserver.doTick(booleansupplier);
+                        worldserver.timings.doTick.stopTiming(); // Spigot
+                        // Tuinity - replace logic
+                    } catch (Throwable throwable) {
+                        // Spigot Start
+                        if (throwable instanceof ThreadDeath) {
+                            throw throwable;
+                        } // Paper
+                        CrashReport crashreport;
+                        try {
+                            crashreport = CrashReport.a(throwable, "Exception ticking world");
+                        } catch (Throwable t) {
+                            throw new RuntimeException("Error generating crash report", t);
+                        }
+                        // Spigot End
+            
+                        worldserver.a(crashreport);
+                        throw new ReportedException(crashreport);
                     }
-                    // Spigot End
-
-                    worldserver.a(crashreport);
-                    throw new ReportedException(crashreport);
+        
+                    this.methodProfiler.exit();
+                    this.methodProfiler.exit();
+                    worldserver.explosionDensityCache.clear(); // Paper - Optimize explosions
+                }
+                worldThreadTimeMap.put(worldserver.getWorld(), System.nanoTime() - worldServerThreadNanoTime);
+            });
+            
+            worldServerThread.setDaemon(true);
+            WorldThreads.worldThreadMap.put(worldserver.getWorld(), worldServerThread);
+            if(WorkMode.MULTI_THREAD_TICK) worldServerThread.start();
+        }
+        if(WorkMode.MULTI_THREAD_TICK) {
+            for (Thread thread : WorldThreads.worldThreadMap.values()) {
+                try {
+                    thread.join();
+                } catch (InterruptedException e) {
+                    e.printStackTrace();
+                }
+            }
+        } else {
+            for (Thread thread : WorldThreads.worldThreadMap.values()) {
+                thread.start();
+                try {
+                    thread.join();
+                } catch (InterruptedException e) {
+                    e.printStackTrace();
                 }
-
-                this.methodProfiler.exit();
-                this.methodProfiler.exit();
-                worldserver.explosionDensityCache.clear(); // Paper - Optimize explosions
             }
         }
+        WorldThreads.worldThreadMap.clear();
+        TimingHandler.clearWorldTimings();
+        PerformanceMonitor.setWorldTickNanoTimeMap(worldThreadTimeMap);
+        PerformanceMonitor.setAllWorldTickNanoTime(System.nanoTime() - worldServerTickNanoTime);
 
         this.methodProfiler.exitEnter("connection");
         MinecraftTimings.connectionTimer.startTiming(); // Spigot
@@ -1631,7 +1681,7 @@
     }
 
     public String getServerModName() {
-        return "Tuinity"; // Tuinity //Paper - Paper > // Spigot - Spigot > // CraftBukkit - cb > vanilla!
+        return "Chiyogami"; // Tuinity //Paper - Paper > // Spigot - Spigot > // CraftBukkit - cb > vanilla!
     }
 
     public CrashReport b(CrashReport crashreport) {
diff --strip-trailing-cr -urN Original/Tuinity-Server/src/main/java/net/minecraft/server/PlayerChunkMap.java Chiyogami/Tuinity-Server/src/main/java/net/minecraft/server/PlayerChunkMap.java
--- Original/Tuinity-Server/src/main/java/net/minecraft/server/PlayerChunkMap.java	2021-09-27 23:30:56.430196500 +0900
+++ Chiyogami/Tuinity-Server/src/main/java/net/minecraft/server/PlayerChunkMap.java	2021-09-28 01:52:28.241781700 +0900
@@ -32,11 +32,8 @@
 import java.util.Optional;
 import java.util.Queue;
 import java.util.Set;
-import java.util.concurrent.CancellationException;
+import java.util.concurrent.*;
 import java.util.UUID; // Paper
-import java.util.concurrent.CompletableFuture;
-import java.util.concurrent.CompletionException;
-import java.util.concurrent.Executor;
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.function.BooleanSupplier;
 import java.util.function.Consumer;
@@ -83,7 +80,7 @@
     // Paper end
     public final com.destroystokyo.paper.util.map.Long2ObjectLinkedOpenHashMapFastCopy<PlayerChunk> pendingVisibleChunks = new com.destroystokyo.paper.util.map.Long2ObjectLinkedOpenHashMapFastCopy<PlayerChunk>(); // Paper - this is used if the visible chunks is updated while iterating only
     public transient com.destroystokyo.paper.util.map.Long2ObjectLinkedOpenHashMapFastCopy<PlayerChunk> visibleChunksClone; // Paper - used for async access of visible chunks, clone and cache only when needed
-    private final Long2ObjectLinkedOpenHashMap<PlayerChunk> pendingUnload;
+    private final Map<Long, PlayerChunk> pendingUnload;
     final LongSet loadedChunks; // Paper - private -> package
     public final WorldServer world;
     private final LightEngineThreaded lightEngine;
@@ -109,7 +106,7 @@
     public final DefinedStructureManager definedStructureManager; // Paper - private -> public
     private final File w;
     private final PlayerMap playerMap;
-    public final Int2ObjectMap<PlayerChunkMap.EntityTracker> trackedEntities;
+    public final Map<Integer, PlayerChunkMap.EntityTracker> trackedEntities;
     private final Queue<Runnable> z;
     int viewDistance; // Paper - private -> package private
     public final com.destroystokyo.paper.util.PlayerMobDistanceMap playerMobDistanceMap; // Paper
@@ -274,12 +271,12 @@
     public PlayerChunkMap(WorldServer worldserver, File file, DataFixer datafixer, DefinedStructureManager definedstructuremanager, Executor executor, IAsyncTaskHandler<Runnable> iasynctaskhandler, ILightAccess ilightaccess, ChunkGenerator<?> chunkgenerator, WorldLoadListener worldloadlistener, Supplier<WorldPersistentData> supplier, int i) {
         super(new File(worldserver.getWorldProvider().getDimensionManager().a(file), "region"), datafixer);
         //this.visibleChunks = this.updatingChunks.clone(); // Paper - no more cloning
-        this.pendingUnload = new Long2ObjectLinkedOpenHashMap();
+        this.pendingUnload = new ConcurrentHashMap<>();
         this.loadedChunks = new LongOpenHashSet();
         this.unloadQueue = new LongOpenHashSet();
         this.u = new AtomicInteger();
         this.playerMap = new PlayerMap();
-        this.trackedEntities = new Int2ObjectOpenHashMap();
+        this.trackedEntities = new ConcurrentHashMap<>();
         this.z = new com.destroystokyo.paper.utils.CachedSizeConcurrentLinkedQueue<>(); // Paper
         this.definedStructureManager = definedstructuremanager;
         this.w = worldserver.getWorldProvider().getDimensionManager().a(file);
@@ -629,7 +626,7 @@
         }
     }
     public Long2ObjectLinkedOpenHashMap<PlayerChunk> getVisibleChunks() {
-        if (Thread.currentThread() == this.world.serverThread) {
+        if (!AsyncCatcher.isAsync()) {
             return this.visibleChunks;
         } else {
             synchronized (this.visibleChunks) {
@@ -646,7 +643,7 @@
     @Nullable
     public PlayerChunk getVisibleChunk(long i) { // Paper - protected -> public
         // Paper start - mt safe get
-        if (Thread.currentThread() != this.world.serverThread) {
+        if (AsyncCatcher.isAsync()) {
             synchronized (this.visibleChunks) {
                 return (PlayerChunk) (this.hasPendingVisibleUpdate ? this.pendingVisibleChunks.get(i) : ((ProtectedVisibleChunksMap)this.visibleChunks).safeGet(i));
             }
@@ -1962,7 +1959,7 @@
                         EntityPlayer entityplayer = (EntityPlayer) entity;
 
                         this.a(entityplayer, true);
-                        ObjectIterator objectiterator = this.trackedEntities.values().iterator();
+                        Iterator objectiterator = this.trackedEntities.values().iterator();
 
                         while (objectiterator.hasNext()) {
                             PlayerChunkMap.EntityTracker playerchunkmap_entitytracker1 = (PlayerChunkMap.EntityTracker) objectiterator.next();
@@ -1984,7 +1981,7 @@
             EntityPlayer entityplayer = (EntityPlayer) entity;
 
             this.a(entityplayer, false);
-            ObjectIterator objectiterator = this.trackedEntities.values().iterator();
+            Iterator objectiterator = this.trackedEntities.values().iterator();
 
             while (objectiterator.hasNext()) {
                 PlayerChunkMap.EntityTracker playerchunkmap_entitytracker = (PlayerChunkMap.EntityTracker) objectiterator.next();
@@ -2033,7 +2030,7 @@
         List<EntityPlayer> list1 = this.world.getPlayers();
 
         PlayerChunkMap.EntityTracker playerchunkmap_entitytracker;
-        ObjectIterator objectiterator;
+        Iterator objectiterator;
         world.timings.tracker1.startTiming(); // Paper
 
         for (objectiterator = this.trackedEntities.values().iterator(); objectiterator.hasNext(); playerchunkmap_entitytracker.trackerEntry.a()) {
@@ -2266,7 +2263,7 @@
         // Paper start
         // Replace trackedPlayers Set with a Map. The value is true until the player receives
         // their first update (which is forced to have absolute coordinates), false afterward.
-        public java.util.Map<EntityPlayer, Boolean> trackedPlayerMap = new java.util.HashMap<>();
+        public java.util.Map<EntityPlayer, Boolean> trackedPlayerMap = new ConcurrentHashMap<>();
         public Set<EntityPlayer> trackedPlayers = trackedPlayerMap.keySet();
 
         public EntityTracker(Entity entity, int i, int j, boolean flag) {
diff --strip-trailing-cr -urN Original/Tuinity-Server/src/main/java/net/minecraft/server/World.java Chiyogami/Tuinity-Server/src/main/java/net/minecraft/server/World.java
--- Original/Tuinity-Server/src/main/java/net/minecraft/server/World.java	2021-09-27 23:30:56.517146600 +0900
+++ Chiyogami/Tuinity-Server/src/main/java/net/minecraft/server/World.java	2021-09-28 00:31:52.774339100 +0900
@@ -32,6 +32,7 @@
 import org.bukkit.craftbukkit.block.CraftBlockState;
 import org.bukkit.craftbukkit.block.data.CraftBlockData;
 import org.bukkit.event.block.BlockPhysicsEvent;
+import org.spigotmc.AsyncCatcher;
 // CraftBukkit end
 
 public abstract class World implements GeneratorAccess, AutoCloseable {
@@ -270,7 +271,7 @@
     @Override
     public Chunk getChunkAt(int i, int j) {
         // Paper start - optimise this for loaded chunks
-        if (Thread.currentThread() == this.serverThread) {
+        if (!AsyncCatcher.isAsync()) {
             Chunk ifLoaded = ((WorldServer) this).getChunkProvider().getChunkAtIfLoadedMainThread(i, j);
             if (ifLoaded != null) {
                 return ifLoaded;
@@ -1075,7 +1076,7 @@
         // CraftBukkit end
         if (isOutsideWorld(blockposition)) {
             return null;
-        } else if (!this.isClientSide && Thread.currentThread() != this.serverThread) {
+        } else if (!this.isClientSide && AsyncCatcher.isAsync()) {
             return null;
         } else {
             // CraftBukkit start
diff --strip-trailing-cr -urN Original/Tuinity-Server/src/main/java/net/minecraft/server/WorldServer.java Chiyogami/Tuinity-Server/src/main/java/net/minecraft/server/WorldServer.java
--- Original/Tuinity-Server/src/main/java/net/minecraft/server/WorldServer.java	2021-09-27 23:30:56.563120200 +0900
+++ Chiyogami/Tuinity-Server/src/main/java/net/minecraft/server/WorldServer.java	2021-09-28 02:56:07.166726700 +0900
@@ -1,5 +1,6 @@
 package net.minecraft.server;
 
+import co.aikar.timings.Timing;
 import com.google.common.annotations.VisibleForTesting;
 import co.aikar.timings.TimingHistory; // Paper
 import co.aikar.timings.Timings; // Paper
@@ -22,15 +23,9 @@
 import java.io.IOException;
 import java.io.Writer;
 import java.nio.file.Files;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Map;
-import java.util.Objects;
-import java.util.Optional;
-import java.util.Queue;
-import java.util.Random;
-import java.util.Set;
-import java.util.UUID;
+import java.util.*;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.CopyOnWriteArrayList;
 import java.util.concurrent.Executor;
 import java.util.function.BooleanSupplier;
 import java.util.function.Predicate;
@@ -49,16 +44,17 @@
 import org.bukkit.event.server.MapInitializeEvent;
 import org.bukkit.event.weather.LightningStrikeEvent;
 import org.bukkit.event.world.TimeSkipEvent;
+import org.spigotmc.AsyncCatcher;
 // CraftBukkit end
 
 public class WorldServer extends World {
 
     private static final Logger LOGGER = LogManager.getLogger();
-    private final List<Entity> globalEntityList = Lists.newArrayList();
-    public final Int2ObjectMap<Entity> entitiesById = new Int2ObjectLinkedOpenHashMap(); final com.tuinity.tuinity.util.maplist.IteratorSafeOrderedReferenceSet<Entity> entitiesForIteration = new com.tuinity.tuinity.util.maplist.IteratorSafeOrderedReferenceSet<>(2048, 0.5f, 2048, 0.2); // Tuinity - make removing entities while ticking safe
-    private final Map<UUID, Entity> entitiesByUUID = Maps.newHashMap();
+    private final List<Entity> globalEntityList = new CopyOnWriteArrayList<>();
+    public final Map<Integer, Entity> entitiesById = new ConcurrentHashMap<>(); final com.tuinity.tuinity.util.maplist.IteratorSafeOrderedReferenceSet<Entity> entitiesForIteration = new com.tuinity.tuinity.util.maplist.IteratorSafeOrderedReferenceSet<>(2048, 0.5f, 2048, 0.2); // Tuinity - make removing entities while ticking safe
+    private final Map<UUID, Entity> entitiesByUUID = new ConcurrentHashMap<>();
     private final Queue<Entity> entitiesToAdd = Queues.newArrayDeque();
-    public final List<EntityPlayer> players = Lists.newArrayList(); // Paper - private -> public
+    public final List<EntityPlayer> players = new CopyOnWriteArrayList<>(); // Paper - private -> public
     boolean tickingEntities;
     // Paper start
     List<java.lang.Runnable> afterEntityTickingTasks = Lists.newArrayList();
@@ -222,7 +218,7 @@
 
     public final void loadChunksForMoveAsync(AxisAlignedBB axisalignedbb, double toX, double toZ,
                                              java.util.function.Consumer<List<IChunkAccess>> onLoad) {
-        if (Thread.currentThread() != this.serverThread) {
+        if (AsyncCatcher.isAsync()) {
             this.getChunkProvider().serverThreadQueue.execute(() -> {
                 this.loadChunksForMoveAsync(axisalignedbb, toX, toZ, onLoad);
             });
@@ -322,7 +318,7 @@
             }, IRegistry.FLUID::getKey, IRegistry.FLUID::get, this::a, "Fluids"); // Paper - Timings
         }
 
-        this.navigators = Sets.newHashSet();
+        this.navigators = ConcurrentHashMap.newKeySet();
         this.I = new ObjectLinkedOpenHashSet();
         this.dataManager = worldnbtstorage;
         this.server = minecraftserver;
@@ -629,7 +625,7 @@
             return;
         }
         AxisAlignedBB axisalignedbb1 = axisalignedbb.grow(1.0E-7D, 1.0E-7D, 1.0E-7D);
-        List<Entity> entities = com.tuinity.tuinity.util.CachedLists.getTempGetEntitiesList();
+        List<Entity> entities = com.tuinity.tuinity.util.CachedLists.getTempGetEntitiesList(this.getWorld());
         try {
             if (entity != null && entity.hardCollides()) {
                 this.getEntities(entity, axisalignedbb, IEntitySelector.notSpectator(), entities);
@@ -661,7 +657,7 @@
                 }
             }
         } finally {
-            com.tuinity.tuinity.util.CachedLists.returnTempGetEntitiesList(entities);
+            com.tuinity.tuinity.util.CachedLists.returnTempGetEntitiesList(entities, this.getWorld());
         }
     }
 
@@ -690,7 +686,7 @@
     @Override
     protected TileEntity getTileEntity(BlockPosition pos, boolean validate) {
         TileEntity result = super.getTileEntity(pos, validate);
-        if (!validate || Thread.currentThread() != this.serverThread) {
+        if (!validate || AsyncCatcher.isAsync()) {
             // SPIGOT-5378: avoid deadlock, this can be called in loading logic (i.e lighting) but getType() will block on chunk load
             return result;
         }
@@ -1248,7 +1244,7 @@
             // Spigot end
 
             TimingHistory.activatedEntityTicks++; // Paper - timings
-            entity.tickTimer.startTiming(); // Spigot
+            Timing timing = this.timings.getEntityTickTimer(entity).startTiming(); // Spigot
             try { // Paper - timings
             entity.f(entity.locX(), entity.locY(), entity.locZ());
             entity.lastYaw = entity.yaw;
@@ -1277,7 +1273,7 @@
                 }
             }
             } finally { // Paper - timings
-            entity.tickTimer.stopTiming(); // Spigot
+            timing.stopTiming(); // Spigot
             } // Paper - timings
 
         }
@@ -1524,7 +1520,7 @@
     public List<Entity> a(@Nullable EntityTypes<?> entitytypes, Predicate<? super Entity> predicate) {
         List<Entity> list = Lists.newArrayList();
         ChunkProviderServer chunkproviderserver = this.getChunkProvider();
-        ObjectIterator objectiterator = this.entitiesById.values().iterator();
+        Iterator objectiterator = this.entitiesById.values().iterator();
 
         while (objectiterator.hasNext()) {
             Entity entity = (Entity) objectiterator.next();
@@ -1539,7 +1535,7 @@
 
     public List<EntityEnderDragon> j() {
         List<EntityEnderDragon> list = Lists.newArrayList();
-        ObjectIterator objectiterator = this.entitiesById.values().iterator();
+        Iterator objectiterator = this.entitiesById.values().iterator();
 
         while (objectiterator.hasNext()) {
             Entity entity = (Entity) objectiterator.next();
@@ -1589,7 +1585,7 @@
     public int[] countMobs(boolean updatePlayerCounts) {
         int[] ret = new int[EntityPlayer.ENUMCREATURETYPE_TOTAL_ENUMS];
         // Paper end
-        ObjectIterator objectiterator = this.entitiesById.values().iterator();
+        Iterator objectiterator = this.entitiesById.values().iterator();
 
         while (objectiterator.hasNext()) {
             Entity entity = (Entity) objectiterator.next();
@@ -1795,6 +1791,7 @@
         java.util.List<Entity> toMoveChunks = new java.util.ArrayList<>(); // Paper
         for (int j = 0; j < i; ++j) {
             List<Entity> entityslice = aentityslice[j]; // Spigot
+            Set<Entity> removeEntities = new HashSet<>();
             Iterator iterator = entityslice.iterator();
 
             while (iterator.hasNext()) {
@@ -1815,9 +1812,10 @@
                     this.entitiesById.remove(entity.getId());
                     this.unregisterEntity(entity);
 
-                    if (entity.dead) iterator.remove(); // Paper - don't save dead entities during unload
+                    if (entity.dead) removeEntities.add(entity); // Paper - don't save dead entities during unload
                 }
             }
+            entityslice.removeAll(removeEntities);
         }
         // Paper start - move out entities that shouldn't be in this chunk before it unloads
         for (Entity entity : toMoveChunks) {
diff --strip-trailing-cr -urN Original/Tuinity-Server/src/main/java/org/bukkit/craftbukkit/CraftServer.java Chiyogami/Tuinity-Server/src/main/java/org/bukkit/craftbukkit/CraftServer.java
--- Original/Tuinity-Server/src/main/java/org/bukkit/craftbukkit/CraftServer.java	2021-09-27 23:30:55.011401300 +0900
+++ Chiyogami/Tuinity-Server/src/main/java/org/bukkit/craftbukkit/CraftServer.java	2021-09-28 00:24:06.327484300 +0900
@@ -200,12 +200,13 @@
 import org.yaml.snakeyaml.error.MarkedYAMLException;
 
 import net.md_5.bungee.api.chat.BaseComponent; // Spigot
+import world.chiyogami.chiyogamilib.WorldThreads;
 
 import javax.annotation.Nullable; // Paper
 import javax.annotation.Nonnull; // Paper
 
 public final class CraftServer implements Server {
-    private final String serverName = "Tuinity"; // Paper // Tuinity
+    private final String serverName = "Chiyogami"; // Paper // Tuinity
     private final String serverVersion;
     private final String bukkitVersion = Versioning.getBukkitVersion();
     private final Logger logger = Logger.getLogger("Minecraft");
@@ -1751,7 +1752,7 @@
     public boolean isPrimaryThread() {
         // Tuinity start
         final Thread currThread = Thread.currentThread();
-        return currThread == console.serverThread || currThread instanceof com.tuinity.tuinity.util.TickThread || currThread.equals(net.minecraft.server.MinecraftServer.getServer().shutdownThread); // Paper - Fix issues with detecting main thread properly, the only time Watchdog will be used is during a crash shutdown which is a "try our best" scenario
+        return currThread == console.serverThread || currThread instanceof com.tuinity.tuinity.util.TickThread || currThread.equals(net.minecraft.server.MinecraftServer.getServer().shutdownThread) || WorldThreads.worldThreadMap.containsValue(Thread.currentThread()); // Paper - Fix issues with detecting main thread properly, the only time Watchdog will be used is during a crash shutdown which is a "try our best" scenario
         // Tuinity End
     }
 
diff --strip-trailing-cr -urN Original/Tuinity-Server/src/main/java/org/bukkit/craftbukkit/CraftWorld.java Chiyogami/Tuinity-Server/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
--- Original/Tuinity-Server/src/main/java/org/bukkit/craftbukkit/CraftWorld.java	2021-09-27 23:30:56.387222000 +0900
+++ Chiyogami/Tuinity-Server/src/main/java/org/bukkit/craftbukkit/CraftWorld.java	2021-09-28 02:13:20.882159100 +0900
@@ -265,6 +265,7 @@
 import org.bukkit.util.Consumer;
 import org.bukkit.util.RayTraceResult;
 import org.bukkit.util.Vector;
+import org.spigotmc.AsyncCatcher;
 
 public class CraftWorld implements World {
     public static final int CUSTOM_DIMENSION_OFFSET = 10;
@@ -453,7 +454,7 @@
     @Override
     public Chunk[] getLoadedChunks() {
         // Paper start
-        if (Thread.currentThread() != world.getMinecraftWorld().serverThread) {
+        if (AsyncCatcher.isAsync()) {
             synchronized (world.getChunkProvider().playerChunkMap.visibleChunks) {
                 Long2ObjectLinkedOpenHashMap<PlayerChunk> chunks = world.getChunkProvider().playerChunkMap.visibleChunks;
                 return chunks.values().stream().map(PlayerChunk::getFullChunk).filter(Objects::nonNull).map(net.minecraft.server.Chunk::getBukkitChunk).toArray(Chunk[]::new);
@@ -682,8 +683,8 @@
         Map<Plugin, ImmutableList.Builder<Chunk>> ret = new HashMap<>();
         ChunkMapDistance chunkDistanceManager = this.world.getChunkProvider().playerChunkMap.chunkDistanceManager;
 
-        for (Long2ObjectMap.Entry<ArraySetSorted<Ticket<?>>> chunkTickets : chunkDistanceManager.tickets.long2ObjectEntrySet()) {
-            long chunkKey = chunkTickets.getLongKey();
+        for (Map.Entry<Long, ArraySetSorted<Ticket<?>>> chunkTickets : chunkDistanceManager.tickets.entrySet()) {
+            long chunkKey = chunkTickets.getKey();
             ArraySetSorted<Ticket<?>> tickets = chunkTickets.getValue();
 
             Chunk chunk = null;
diff --strip-trailing-cr -urN Original/Tuinity-Server/src/main/java/org/spigotmc/AsyncCatcher.java Chiyogami/Tuinity-Server/src/main/java/org/spigotmc/AsyncCatcher.java
--- Original/Tuinity-Server/src/main/java/org/spigotmc/AsyncCatcher.java	2021-09-27 23:30:55.096352700 +0900
+++ Chiyogami/Tuinity-Server/src/main/java/org/spigotmc/AsyncCatcher.java	2021-09-28 00:22:47.451447500 +0900
@@ -15,4 +15,8 @@
             throw new IllegalStateException( "Asynchronous " + reason + "!" );
         }
     }
+    
+    public static boolean isAsync(){
+        return !org.bukkit.Bukkit.isPrimaryThread();
+    }
 }
