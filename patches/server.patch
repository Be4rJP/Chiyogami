diff --strip-trailing-cr -urN Original/Tuinity-Server/src/main/java/co/aikar/timings/WorldTimingsHandler.java Chiyogami/Chiyogami-Server/src/main/java/co/aikar/timings/WorldTimingsHandler.java
--- Original/Tuinity-Server/src/main/java/co/aikar/timings/WorldTimingsHandler.java	2021-09-27 23:30:53.589081500 +0900
+++ Chiyogami/Chiyogami-Server/src/main/java/co/aikar/timings/WorldTimingsHandler.java	2021-10-26 04:21:26.040753600 +0900
@@ -1,8 +1,12 @@
 package co.aikar.timings;
 
+import net.minecraft.server.Entity;
 import net.minecraft.server.World;
 import net.minecraft.server.WorldServer;
 
+import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
+
 /**
  * Set of timers per world, to track world specific timings.
  */
@@ -68,75 +72,85 @@
     public final Timing chunkUnloadPrepareSave;
     public final Timing chunkUnloadPOISerialization;
     public final Timing chunkUnloadDataSave;
+    
+    private final String name;
 
     public WorldTimingsHandler(World server) {
-        String name = server.worldData.getName() +" - ";
+        name = server.worldData.getName() +" - ";
 
-        mobSpawn = Timings.ofSafe(name + "mobSpawn");
-        doChunkUnload = Timings.ofSafe(name + "doChunkUnload");
-        scheduledBlocks = Timings.ofSafe(name + "Scheduled Blocks");
-        scheduledBlocksCleanup = Timings.ofSafe(name + "Scheduled Blocks - Cleanup");
-        scheduledBlocksTicking = Timings.ofSafe(name + "Scheduled Blocks - Ticking");
-        chunkTicks = Timings.ofSafe(name + "Chunk Ticks");
-        lightChunk = Timings.ofSafe(name + "Light Chunk");
-        chunkTicksBlocks = Timings.ofSafe(name + "Chunk Ticks - Blocks");
-        doVillages = Timings.ofSafe(name + "doVillages");
-        doChunkMap = Timings.ofSafe(name + "doChunkMap");
-        doChunkMapUpdate = Timings.ofSafe(name + "doChunkMap - Update");
-        doChunkMapToUpdate = Timings.ofSafe(name + "doChunkMap - To Update");
-        doChunkMapSortMissing = Timings.ofSafe(name + "doChunkMap - Sort Missing");
-        doChunkMapSortSendToPlayers = Timings.ofSafe(name + "doChunkMap - Sort Send To Players");
-        doChunkMapPlayersNeedingChunks = Timings.ofSafe(name + "doChunkMap - Players Needing Chunks");
-        doChunkMapPendingSendToPlayers = Timings.ofSafe(name + "doChunkMap - Pending Send To Players");
-        doChunkMapUnloadChunks = Timings.ofSafe(name + "doChunkMap - Unload Chunks");
-        doSounds = Timings.ofSafe(name + "doSounds");
-        doChunkGC = Timings.ofSafe(name + "doChunkGC");
-        doPortalForcer = Timings.ofSafe(name + "doPortalForcer");
-        entityTick = Timings.ofSafe(name + "entityTick");
-        entityRemoval = Timings.ofSafe(name + "entityRemoval");
-        tileEntityTick = Timings.ofSafe(name + "tileEntityTick");
-        tileEntityPending = Timings.ofSafe(name + "tileEntityPending");
-
-        chunkLoad = Timings.ofSafe(name + "Chunk Load");
-        chunkLoadPopulate = Timings.ofSafe(name + "Chunk Load - Populate");
-        syncChunkLoad = Timings.ofSafe(name + "Sync Chunk Load");
-        chunkLoadLevelTimer = Timings.ofSafe(name + "Chunk Load - Load Level");
-        chunkIO = Timings.ofSafe(name + "Chunk Load - DiskIO");
-        chunkPostLoad = Timings.ofSafe(name + "Chunk Load - Post Load");
-        worldSave = Timings.ofSafe(name + "World Save");
-        worldSaveLevel = Timings.ofSafe(name + "World Save - Level");
-        worldSaveChunks = Timings.ofSafe(name + "World Save - Chunks");
-        chunkSaveData = Timings.ofSafe(name + "Chunk Save - Data");
-
-        tracker1 = Timings.ofSafe(name + "tracker stage 1");
-        tracker2 = Timings.ofSafe(name + "tracker stage 2");
-        doTick = Timings.ofSafe(name + "doTick");
-        tickEntities = Timings.ofSafe(name + "tickEntities");
-
-        chunks = Timings.ofSafe(name + "Chunks");
-        newEntities = Timings.ofSafe(name + "New entity registration");
-        raids = Timings.ofSafe(name + "Raids");
-        chunkProviderTick = Timings.ofSafe(name + "Chunk provider tick");
-        broadcastChunkUpdates = Timings.ofSafe(name + "Broadcast chunk updates");
-        countNaturalMobs = Timings.ofSafe(name + "Count natural mobs");
-
-
-        miscMobSpawning = Timings.ofSafe(name + "Mob spawning - Misc");
-        playerMobDistanceMapUpdate = Timings.ofSafe(name + "Per Player Mob Spawning - Distance Map Update");
-
-        poiUnload = Timings.ofSafe(name + "Chunk unload - POI");
-        chunkUnload = Timings.ofSafe(name + "Chunk unload - Chunk");
-        poiSaveDataSerialization = Timings.ofSafe(name + "Chunk save - POI Data serialization");
-        chunkSave = Timings.ofSafe(name + "Chunk save - Chunk");
-        chunkSaveOverwriteCheck = Timings.ofSafe(name + "Chunk save - Chunk Overwrite Check");
-        chunkSaveDataSerialization = Timings.ofSafe(name + "Chunk save - Chunk Data serialization");
-        chunkSaveIOWait = Timings.ofSafe(name + "Chunk save - Chunk IO Wait");
-        chunkUnloadPrepareSave = Timings.ofSafe(name + "Chunk unload - Async Save Prepare");
-        chunkUnloadPOISerialization = Timings.ofSafe(name + "Chunk unload - POI Data Serialization");
-        chunkUnloadDataSave = Timings.ofSafe(name + "Chunk unload - Data Serialization");
+        mobSpawn = Timings.ofSafeW(name + "mobSpawn");
+        doChunkUnload = Timings.ofSafeW(name + "doChunkUnload");
+        scheduledBlocks = Timings.ofSafeW(name + "Scheduled Blocks");
+        scheduledBlocksCleanup = Timings.ofSafeW(name + "Scheduled Blocks - Cleanup");
+        scheduledBlocksTicking = Timings.ofSafeW(name + "Scheduled Blocks - Ticking");
+        chunkTicks = Timings.ofSafeW(name + "Chunk Ticks");
+        lightChunk = Timings.ofSafeW(name + "Light Chunk");
+        chunkTicksBlocks = Timings.ofSafeW(name + "Chunk Ticks - Blocks");
+        doVillages = Timings.ofSafeW(name + "doVillages");
+        doChunkMap = Timings.ofSafeW(name + "doChunkMap");
+        doChunkMapUpdate = Timings.ofSafeW(name + "doChunkMap - Update");
+        doChunkMapToUpdate = Timings.ofSafeW(name + "doChunkMap - To Update");
+        doChunkMapSortMissing = Timings.ofSafeW(name + "doChunkMap - Sort Missing");
+        doChunkMapSortSendToPlayers = Timings.ofSafeW(name + "doChunkMap - Sort Send To Players");
+        doChunkMapPlayersNeedingChunks = Timings.ofSafeW(name + "doChunkMap - Players Needing Chunks");
+        doChunkMapPendingSendToPlayers = Timings.ofSafeW(name + "doChunkMap - Pending Send To Players");
+        doChunkMapUnloadChunks = Timings.ofSafeW(name + "doChunkMap - Unload Chunks");
+        doSounds = Timings.ofSafeW(name + "doSounds");
+        doChunkGC = Timings.ofSafeW(name + "doChunkGC");
+        doPortalForcer = Timings.ofSafeW(name + "doPortalForcer");
+        entityTick = Timings.ofSafeW(name + "entityTick");
+        entityRemoval = Timings.ofSafeW(name + "entityRemoval");
+        tileEntityTick = Timings.ofSafeW(name + "tileEntityTick");
+        tileEntityPending = Timings.ofSafeW(name + "tileEntityPending");
+
+        chunkLoad = Timings.ofSafeW(name + "Chunk Load");
+        chunkLoadPopulate = Timings.ofSafeW(name + "Chunk Load - Populate");
+        syncChunkLoad = Timings.ofSafeW(name + "Sync Chunk Load");
+        chunkLoadLevelTimer = Timings.ofSafeW(name + "Chunk Load - Load Level");
+        chunkIO = Timings.ofSafeW(name + "Chunk Load - DiskIO");
+        chunkPostLoad = Timings.ofSafeW(name + "Chunk Load - Post Load");
+        worldSave = Timings.ofSafeW(name + "World Save");
+        worldSaveLevel = Timings.ofSafeW(name + "World Save - Level");
+        worldSaveChunks = Timings.ofSafeW(name + "World Save - Chunks");
+        chunkSaveData = Timings.ofSafeW(name + "Chunk Save - Data");
+
+        tracker1 = Timings.ofSafeW(name + "tracker stage 1");
+        tracker2 = Timings.ofSafeW(name + "tracker stage 2");
+        doTick = Timings.ofSafeW(name + "doTick");
+        tickEntities = Timings.ofSafeW(name + "tickEntities");
+
+        chunks = Timings.ofSafeW(name + "Chunks");
+        newEntities = Timings.ofSafeW(name + "New entity registration");
+        raids = Timings.ofSafeW(name + "Raids");
+        chunkProviderTick = Timings.ofSafeW(name + "Chunk provider tick");
+        broadcastChunkUpdates = Timings.ofSafeW(name + "Broadcast chunk updates");
+        countNaturalMobs = Timings.ofSafeW(name + "Count natural mobs");
+
+
+        miscMobSpawning = Timings.ofSafeW(name + "Mob spawning - Misc");
+        playerMobDistanceMapUpdate = Timings.ofSafeW(name + "Per Player Mob Spawning - Distance Map Update");
+
+        poiUnload = Timings.ofSafeW(name + "Chunk unload - POI");
+        chunkUnload = Timings.ofSafeW(name + "Chunk unload - Chunk");
+        poiSaveDataSerialization = Timings.ofSafeW(name + "Chunk save - POI Data serialization");
+        chunkSave = Timings.ofSafeW(name + "Chunk save - Chunk");
+        chunkSaveOverwriteCheck = Timings.ofSafeW(name + "Chunk save - Chunk Overwrite Check");
+        chunkSaveDataSerialization = Timings.ofSafeW(name + "Chunk save - Chunk Data serialization");
+        chunkSaveIOWait = Timings.ofSafeW(name + "Chunk save - Chunk IO Wait");
+        chunkUnloadPrepareSave = Timings.ofSafeW(name + "Chunk unload - Async Save Prepare");
+        chunkUnloadPOISerialization = Timings.ofSafeW(name + "Chunk unload - POI Data Serialization");
+        chunkUnloadDataSave = Timings.ofSafeW(name + "Chunk unload - Data Serialization");
     }
 
     public static Timing getTickList(WorldServer worldserver, String timingsType) {
-        return Timings.ofSafe(worldserver.getWorldData().getName() + " - Scheduled " + timingsType);
+        return Timings.ofSafeW(worldserver.getWorldData().getName() + " - Scheduled " + timingsType);
+    }
+    
+    
+    // Chiyogami - timings
+    private final Map<String, Timing> tickMap = new ConcurrentHashMap<>();
+    
+    public Timing getEntityTickTimer(Entity entity){
+        return tickMap.computeIfAbsent(entity.getClass().getName(), k -> Timings.ofSafeW(name + ": " + k + " - tick"));
     }
 }
diff --strip-trailing-cr -urN Original/Tuinity-Server/src/main/java/com/tuinity/tuinity/util/CachedLists.java Chiyogami/Chiyogami-Server/src/main/java/com/tuinity/tuinity/util/CachedLists.java
--- Original/Tuinity-Server/src/main/java/com/tuinity/tuinity/util/CachedLists.java	2021-09-27 23:30:55.905497100 +0900
+++ Chiyogami/Chiyogami-Server/src/main/java/com/tuinity/tuinity/util/CachedLists.java	2021-10-26 04:21:26.041753000 +0900
@@ -3,51 +3,174 @@
 import net.minecraft.server.AxisAlignedBB;
 import net.minecraft.server.Entity;
 import org.bukkit.Bukkit;
+import org.bukkit.World;
 import org.bukkit.craftbukkit.util.UnsafeList;
+import world.chiyogami.chiyogamilib.WorldThreads;
+
 import java.util.List;
+import java.util.Set;
+import java.util.concurrent.ConcurrentHashMap;
 
 public class CachedLists {
-
-    static final UnsafeList<AxisAlignedBB> TEMP_COLLISION_LIST = new UnsafeList<>(1024);
-    static boolean tempCollisionListInUse;
-
+    
+    private final World world;
+    
+    private final UnsafeList<AxisAlignedBB> TEMP_COLLISION_LIST = new UnsafeList<>(1024);
+    private boolean tempCollisionListInUse;
+    
+    private final UnsafeList<Entity> TEMP_GET_ENTITIES_LIST = new UnsafeList<>(1024);
+    private boolean tempGetEntitiesListInUse;
+    
+    private CachedLists(World world){
+        this.world = world;
+    }
+    
+    
+    
+    // Paper start - optimise collisions
+    static final Set<CachedLists> cashedListSet = ConcurrentHashMap.newKeySet();
+    
+    public static List<AxisAlignedBB> getTempCollisionList(World world) {
+        
+        for(CachedLists cachedLists : cashedListSet){
+            if(world == cachedLists.world){
+                if (!Bukkit.isPrimaryThread() || cachedLists.tempCollisionListInUse) {
+                    return new UnsafeList<>(16);
+                }
+                
+                cachedLists.tempCollisionListInUse = true;
+                return cachedLists.TEMP_COLLISION_LIST;
+            }
+        }
+        
+        CachedLists cachedLists = new CachedLists(world);
+        cachedLists.tempCollisionListInUse = true;
+        cashedListSet.add(cachedLists);
+        return cachedLists.TEMP_COLLISION_LIST;
+    }
+    
+    
     public static List<AxisAlignedBB> getTempCollisionList() {
-        if (!Bukkit.isPrimaryThread() || tempCollisionListInUse) {
+        
+        for(CachedLists cachedLists : cashedListSet){
+            World world = cachedLists.world;
+            Thread thread = WorldThreads.worldThreadMap.get(world);
+            
+            if(Thread.currentThread() == thread && !cachedLists.tempCollisionListInUse){
+                cachedLists.tempCollisionListInUse = true;
+                return cachedLists.TEMP_COLLISION_LIST;
+            }
+        }
+        
+        if (!Bukkit.isPrimaryThread()) {
             return new UnsafeList<>(16);
         }
-        tempCollisionListInUse = true;
-        return TEMP_COLLISION_LIST;
+        
+        UnsafeList<AxisAlignedBB> allList = new UnsafeList<>(1024);
+        for(CachedLists cachedLists : cashedListSet){
+            allList.addAll(cachedLists.TEMP_COLLISION_LIST);
+        }
+        return allList;
     }
-
+    
+    public static void returnTempCollisionList(List<AxisAlignedBB> list, World world) {
+        for(CachedLists cachedLists : cashedListSet){
+            if(world == cachedLists.world){
+                if (cachedLists.TEMP_COLLISION_LIST != list) {
+                    return;
+                }
+                
+                cachedLists.TEMP_COLLISION_LIST.setSize(0);
+                cachedLists.tempCollisionListInUse = false;
+                return;
+            }
+        }
+    }
+    
     public static void returnTempCollisionList(List<AxisAlignedBB> list) {
-        if (list != TEMP_COLLISION_LIST) {
-            return;
+        for(CachedLists cachedLists : cashedListSet){
+            if(cachedLists.TEMP_COLLISION_LIST == list){
+                cachedLists.TEMP_COLLISION_LIST.setSize(0);
+                cachedLists.tempCollisionListInUse = false;
+                return;
+            }
         }
-        ((UnsafeList)list).setSize(0);
-        tempCollisionListInUse = false;
+        
+        ((UnsafeList<?>)list).setSize(0);
     }
-
-    static final UnsafeList<Entity> TEMP_GET_ENTITIES_LIST = new UnsafeList<>(1024);
-    static boolean tempGetEntitiesListInUse;
-
-    public static List<Entity> getTempGetEntitiesList() {
-        if (!Bukkit.isPrimaryThread() || tempGetEntitiesListInUse) {
+    
+    
+    public static UnsafeList<Entity> getTempGetEntitiesList(World world) {
+        for(CachedLists cachedLists : cashedListSet){
+            if(world == cachedLists.world){
+                if (!Bukkit.isPrimaryThread() || cachedLists.tempGetEntitiesListInUse) {
+                    return new UnsafeList<>(16);
+                }
+                
+                cachedLists.tempGetEntitiesListInUse = true;
+                return cachedLists.TEMP_GET_ENTITIES_LIST;
+            }
+        }
+        
+        CachedLists cachedLists = new CachedLists(world);
+        cachedLists.tempGetEntitiesListInUse = true;
+        cashedListSet.add(cachedLists);
+        return cachedLists.TEMP_GET_ENTITIES_LIST;
+    }
+    
+    public static UnsafeList<Entity> getTempGetEntitiesList() {
+        for(CachedLists cachedLists : cashedListSet){
+            World world = cachedLists.world;
+            Thread thread = WorldThreads.worldThreadMap.get(world);
+            
+            if(Thread.currentThread() == thread && !cachedLists.tempGetEntitiesListInUse){
+                cachedLists.tempGetEntitiesListInUse = true;
+                return cachedLists.TEMP_GET_ENTITIES_LIST;
+            }
+        }
+        
+        if (!Bukkit.isPrimaryThread()) {
             return new UnsafeList<>(16);
         }
-        tempGetEntitiesListInUse = true;
-        return TEMP_GET_ENTITIES_LIST;
+        
+        UnsafeList<Entity> allList = new UnsafeList<>(1024);
+        for(CachedLists cachedLists : cashedListSet){
+            allList.addAll(cachedLists.TEMP_GET_ENTITIES_LIST);
+        }
+        return allList;
     }
-
+    
+    public static void returnTempGetEntitiesList(List<Entity> list, World world) {
+        for(CachedLists cachedLists : cashedListSet){
+            if(world == cachedLists.world){
+                if (cachedLists.TEMP_GET_ENTITIES_LIST != list) {
+                    return;
+                }
+                
+                cachedLists.TEMP_GET_ENTITIES_LIST.setSize(0);
+                cachedLists.tempGetEntitiesListInUse = false;
+                return;
+            }
+        }
+    }
+    
     public static void returnTempGetEntitiesList(List<Entity> list) {
-        if (list != TEMP_GET_ENTITIES_LIST) {
-            return;
+        for(CachedLists cachedLists : cashedListSet){
+            if(cachedLists.TEMP_GET_ENTITIES_LIST == list){
+                cachedLists.TEMP_GET_ENTITIES_LIST.setSize(0);
+                cachedLists.tempGetEntitiesListInUse = false;
+                return;
+            }
         }
-        ((UnsafeList)list).setSize(0);
-        tempGetEntitiesListInUse = false;
+        
+        ((UnsafeList<?>)list).setSize(0);
     }
-
+    
+    
     public static void reset() {
-        TEMP_COLLISION_LIST.completeReset();
-        TEMP_GET_ENTITIES_LIST.completeReset();
+        for(CachedLists cachedLists : cashedListSet){
+            cachedLists.TEMP_COLLISION_LIST.completeReset();
+            cachedLists.TEMP_GET_ENTITIES_LIST.completeReset();
+        }
     }
 }
diff --strip-trailing-cr -urN Original/Tuinity-Server/src/main/java/net/minecraft/server/Chunk.java Chiyogami/Chiyogami-Server/src/main/java/net/minecraft/server/Chunk.java
--- Original/Tuinity-Server/src/main/java/net/minecraft/server/Chunk.java	2021-09-27 23:30:56.485164600 +0900
+++ Chiyogami/Chiyogami-Server/src/main/java/net/minecraft/server/Chunk.java	2021-10-26 04:21:26.042752600 +0900
@@ -14,6 +14,7 @@
 import java.util.Map;
 import java.util.Set;
 import java.util.Map.Entry;
+import java.util.concurrent.CopyOnWriteArrayList;
 import java.util.function.Consumer;
 import java.util.function.Predicate;
 import java.util.function.Supplier;
@@ -162,7 +163,7 @@
         }
 
         for (int l = 0; l < this.entitySlices.length; ++l) {
-            this.entitySlices[l] = new org.bukkit.craftbukkit.util.UnsafeList(); // Spigot
+            this.entitySlices[l] = new CopyOnWriteArrayList<>(); // Spigot
         }
 
         this.d = biomestorage;
diff --strip-trailing-cr -urN Original/Tuinity-Server/src/main/java/net/minecraft/server/ChunkMapDistance.java Chiyogami/Chiyogami-Server/src/main/java/net/minecraft/server/ChunkMapDistance.java
--- Original/Tuinity-Server/src/main/java/net/minecraft/server/ChunkMapDistance.java	2021-09-27 23:30:55.165313600 +0900
+++ Chiyogami/Chiyogami-Server/src/main/java/net/minecraft/server/ChunkMapDistance.java	2021-10-26 04:21:26.159242500 +0900
@@ -17,9 +17,16 @@
 import it.unimi.dsi.fastutil.objects.ObjectIterator;
 import it.unimi.dsi.fastutil.objects.ObjectOpenHashSet;
 import it.unimi.dsi.fastutil.objects.ObjectSet;
+
+import java.util.ArrayDeque;
+import java.util.Iterator;
+import java.util.Map;
 import java.util.Set;
 import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ConcurrentLinkedDeque;
 import java.util.concurrent.Executor;
+import java.util.concurrent.locks.ReentrantLock;
 import javax.annotation.Nullable;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
@@ -35,7 +42,7 @@
     public static final int MOB_SPAWN_RANGE = 8; //private final ChunkMapDistance.b f = new ChunkMapDistance.b(8); // Paper - no longer used
     private final ChunkMapDistance.c g = new ChunkMapDistance.c(33);
     // Paper start use a queue, but still keep unique requirement
-    public final java.util.Queue<PlayerChunk> pendingChunkUpdates = new java.util.ArrayDeque<PlayerChunk>() {
+    public final java.util.Queue<PlayerChunk> pendingChunkUpdates = new ArrayDeque<PlayerChunk>() {
         @Override
         public boolean add(PlayerChunk o) {
             if (o.isUpdateQueued) return true;
@@ -52,23 +59,30 @@
     private long currentTick;
 
     PlayerChunkMap chunkMap; // Paper
+    
+    //private final ReentrantLock LOCK = new ReentrantLock(true);
 
     // Tuinity start - delay chunk unloads
     private long nextUnloadId; // delay chunk unloads
     private final Long2ObjectOpenHashMap<Ticket<Long>> delayedChunks = new Long2ObjectOpenHashMap<>();
     public final void removeTickets(long chunk, TicketType<?> type) {
-        ArraySetSorted<Ticket<?>> tickets = this.tickets.get(chunk);
-        if (tickets == null) {
-            return;
-        }
-        if (type == TicketType.DELAYED_UNLOAD) {
-            this.delayedChunks.remove(chunk);
-        }
-        boolean changed = tickets.removeIf((Ticket<?> ticket) -> {
-            return ticket.getTicketType() == type;
-        });
-        if (changed) {
-            this.getTicketTracker().update(chunk, getLowestTicketLevel(tickets), false);
+        try {
+            //LOCK.lock();
+            ArraySetSorted<Ticket<?>> tickets = this.tickets.get(chunk);
+            if (tickets == null) {
+                return;
+            }
+            if (type == TicketType.DELAYED_UNLOAD) {
+                this.delayedChunks.remove(chunk);
+            }
+            boolean changed = tickets.removeIf((Ticket<?> ticket) -> {
+                return ticket.getTicketType() == type;
+            });
+            if (changed) {
+                this.getTicketTracker().update(chunk, getLowestTicketLevel(tickets), false);
+            }
+        } finally {
+            //LOCK.unlock();
         }
     }
 
@@ -79,18 +93,23 @@
     };
 
     private void computeDelayedTicketFor(long chunk, int removedLevel, ArraySetSorted<Ticket<?>> tickets) {
-        int lowestLevel = getLowestTicketLevel(tickets);
-        if (removedLevel > lowestLevel) {
-            return;
-        }
-        final Ticket<Long> ticket = this.delayedChunks.computeIfAbsent(chunk, this.computeFuntion);
-        if (ticket.getTicketLevel() != -1) {
-            // since we modify data used in sorting, we need to remove before
-            tickets.remove(ticket);
-        }
-        ticket.setCreationTick(this.currentTick);
-        ticket.setTicketLevel(removedLevel);
-        tickets.add(ticket); // re-add with new expire time and ticket level
+        try {
+            //LOCK.lock();
+            int lowestLevel = getLowestTicketLevel(tickets);
+            if (removedLevel > lowestLevel) {
+                return;
+            }
+            final Ticket<Long> ticket = this.delayedChunks.computeIfAbsent(chunk, this.computeFuntion);
+            if (ticket.getTicketLevel() != -1) {
+                // since we modify data used in sorting, we need to remove before
+                tickets.remove(ticket);
+            }
+            ticket.setCreationTick(this.currentTick);
+            ticket.setTicketLevel(removedLevel);
+            tickets.add(ticket); // re-add with new expire time and ticket level
+        } finally {
+            //LOCK.unlock();
+        }
     }
     // Tuinity end - delay chunk unloads
 
@@ -106,42 +125,46 @@
     }
 
     protected void purgeTickets() {
-        com.tuinity.tuinity.util.TickThread.softEnsureTickThread("Async purge tickets"); // Tuinity
-        ++this.currentTick;
-        ObjectIterator objectiterator = this.tickets.long2ObjectEntrySet().fastIterator();
-
-        int[] tempLevel = new int[] { PlayerChunkMap.GOLDEN_TICKET + 1 }; // Tuinity - delay chunk unloads
-        while (objectiterator.hasNext()) {
-            Entry<ArraySetSorted<Ticket<?>>> entry = (Entry) objectiterator.next();
-
-            if ((entry.getValue()).removeIf((ticket) -> { // CraftBukkit - decompile error
-                // Tuinity start - delay chunk unloads
-                boolean ret = ticket.isExpired(this.currentTick);
-                if (com.tuinity.tuinity.config.TuinityConfig.delayChunkUnloadsBy <= 0) {
+        try {
+            //LOCK.lock();
+            com.tuinity.tuinity.util.TickThread.softEnsureTickThread("Async purge tickets"); // Tuinity
+            ++this.currentTick;
+            ObjectIterator objectiterator = this.tickets.entrySet().iterator();
+    
+            int[] tempLevel = new int[]{PlayerChunkMap.GOLDEN_TICKET + 1}; // Tuinity - delay chunk unloads
+            while (objectiterator.hasNext()) {
+                Map.Entry<Long, ArraySetSorted<Ticket<?>>> entry = (Map.Entry) objectiterator.next();
+        
+                if ((entry.getValue()).removeIf((ticket) -> { // CraftBukkit - decompile error
+                    // Tuinity start - delay chunk unloads
+                    boolean ret = ticket.isExpired(this.currentTick);
+                    if (com.tuinity.tuinity.config.TuinityConfig.delayChunkUnloadsBy <= 0) {
+                        return ret;
+                    }
+                    if (ret && ticket.getTicketType() != TicketType.DELAYED_UNLOAD && ticket.getTicketLevel() < tempLevel[0]) {
+                        tempLevel[0] = ticket.getTicketLevel();
+                    }
+                    if (ticket.getTicketType() == TicketType.DELAYED_UNLOAD && ticket.isCached) {
+                        this.delayedChunks.remove(entry.getKey(), ticket); // clean up ticket...
+                    }
                     return ret;
+                    // Tuinity end - delay chunk unloads
+                })) {
+                    // Tuinity start - delay chunk unloads
+                    if (tempLevel[0] < (PlayerChunkMap.GOLDEN_TICKET + 1)) {
+                        this.computeDelayedTicketFor(entry.getKey(), tempLevel[0], entry.getValue());
+                    }
+                    // Tuinity end - delay chunk unloads
+                    this.e.b(entry.getKey(), a((ArraySetSorted) entry.getValue()), false);
                 }
-                if (ret && ticket.getTicketType() != TicketType.DELAYED_UNLOAD && ticket.getTicketLevel() < tempLevel[0]) {
-                    tempLevel[0] = ticket.getTicketLevel();
-                }
-                if (ticket.getTicketType() == TicketType.DELAYED_UNLOAD && ticket.isCached) {
-                    this.delayedChunks.remove(entry.getLongKey(), ticket); // clean up ticket...
-                }
-                return ret;
-                // Tuinity end - delay chunk unloads
-            })) {
-                // Tuinity start - delay chunk unloads
-                if (tempLevel[0] < (PlayerChunkMap.GOLDEN_TICKET + 1)) {
-                    this.computeDelayedTicketFor(entry.getLongKey(), tempLevel[0], entry.getValue());
+        
+                if (((ArraySetSorted) entry.getValue()).isEmpty()) {
+                    objectiterator.remove();
                 }
-                // Tuinity end - delay chunk unloads
-                this.e.b(entry.getLongKey(), a((ArraySetSorted) entry.getValue()), false);
-            }
-
-            if (((ArraySetSorted) entry.getValue()).isEmpty()) {
-                objectiterator.remove();
             }
+        } finally {
+            //LOCK.unlock();
         }
-
     }
 
     private static int getLowestTicketLevel(ArraySetSorted<Ticket<?>> arraysetsorted) { return a(arraysetsorted); } // Tuinity - OBFHELPER
@@ -158,6 +181,8 @@
     @Nullable
     protected abstract PlayerChunk a(long i, int j, @Nullable PlayerChunk playerchunk, int k);
 
+    public final ReentrantLock CHUNK_UPDATE_LOCK = new ReentrantLock(true);
+    
     public boolean a(PlayerChunkMap playerchunkmap) {
         com.tuinity.tuinity.util.TickThread.softEnsureTickThread("Cannot tick ChunkMapDistance off of the main-thread");// Tuinity
         //this.f.a(); // Paper - no longer used
@@ -171,6 +196,7 @@
         }
 
         // Paper start
+        CHUNK_UPDATE_LOCK.lock(); try{
         if (!this.pendingChunkUpdates.isEmpty()) {
             this.pollingPendingChunkUpdates = true; try {
             while(!this.pendingChunkUpdates.isEmpty()) {
@@ -213,6 +239,9 @@
 
             return flag;
         }
+        } finally {
+            CHUNK_UPDATE_LOCK.unlock();
+        }
     }
     boolean pollingPendingChunkUpdates = false; // Paper
 
@@ -435,7 +464,7 @@
     public void a(SectionPosition sectionposition, EntityPlayer entityplayer) {
         com.tuinity.tuinity.util.TickThread.softEnsureTickThread("Async player add"); // Tuinity
         long i = sectionposition.u().pair();
-
+    
         ((ObjectSet) this.c.computeIfAbsent(i, (j) -> {
             return new ObjectOpenHashSet();
         })).add(entityplayer);
@@ -446,7 +475,7 @@
     public void b(SectionPosition sectionposition, EntityPlayer entityplayer) {
         com.tuinity.tuinity.util.TickThread.softEnsureTickThread("Async player remove"); // Tuinity
         long i = sectionposition.u().pair();
-        ObjectSet<EntityPlayer> objectset = (ObjectSet) this.c.get(i);
+        Set<EntityPlayer> objectset = (Set) this.c.get(i);
 
         if (objectset != null) objectset.remove(entityplayer); // Paper - some state corruption happens here, don't crash, clean up gracefully.
         if (objectset == null || objectset.isEmpty()) { // Paper
@@ -496,13 +525,13 @@
     public <T> void removeAllTicketsFor(TicketType<T> ticketType, int ticketLevel, T ticketIdentifier) {
         com.tuinity.tuinity.util.TickThread.softEnsureTickThread("Async ticket remove"); // Tuinity
         Ticket<T> target = new Ticket<>(ticketType, ticketLevel, ticketIdentifier);
-
+    
         for (java.util.Iterator<Entry<ArraySetSorted<Ticket<?>>>> iterator = this.tickets.long2ObjectEntrySet().fastIterator(); iterator.hasNext();) {
             Entry<ArraySetSorted<Ticket<?>>> entry = iterator.next();
             ArraySetSorted<Ticket<?>> tickets = entry.getValue();
             if (tickets.remove(target)) {
                 // copied from removeTicket
-                this.e.b(entry.getLongKey(), a(tickets), false); // PAIL ticketLevelTracker // PAIL update // PAIL getLowestTicketLevel
+                this.e.b(entry.getKey(), a(tickets), false); // PAIL ticketLevelTracker // PAIL update // PAIL getLowestTicketLevel
 
                 // can't use entry after it's removed
                 if (tickets.isEmpty()) {
@@ -541,15 +570,20 @@
 
         @Override
         protected void a(long i, int j) {
-            PlayerChunk playerchunk = ChunkMapDistance.this.b(i);
-            int k = playerchunk == null ? PlayerChunkMap.GOLDEN_TICKET + 1 : playerchunk.getTicketLevel();
-
-            if (k != j) {
-                playerchunk = ChunkMapDistance.this.a(i, j, playerchunk, k);
-                if (playerchunk != null) {
-                    ChunkMapDistance.this.pendingChunkUpdates.add(playerchunk);
+            ChunkMapDistance.this.CHUNK_UPDATE_LOCK.lock();
+            try{
+                PlayerChunk playerchunk = ChunkMapDistance.this.b(i);
+                int k = playerchunk == null ? PlayerChunkMap.GOLDEN_TICKET + 1 : playerchunk.getTicketLevel();
+        
+                if (k != j) {
+                    playerchunk = ChunkMapDistance.this.a(i, j, playerchunk, k);
+                    if (playerchunk != null) {
+                        ChunkMapDistance.this.pendingChunkUpdates.add(playerchunk);
+                    }
+        
                 }
-
+            } finally {
+                ChunkMapDistance.this.CHUNK_UPDATE_LOCK.unlock();
             }
         }
 
@@ -813,7 +847,7 @@
         }
 
         private boolean d(long i) {
-            ObjectSet<EntityPlayer> objectset = (ObjectSet) ChunkMapDistance.this.c.get(i);
+            Set<EntityPlayer> objectset = (Set) ChunkMapDistance.this.c.get(i);
 
             return objectset != null && !objectset.isEmpty();
         }
diff --strip-trailing-cr -urN Original/Tuinity-Server/src/main/java/net/minecraft/server/ChunkProviderServer.java Chiyogami/Chiyogami-Server/src/main/java/net/minecraft/server/ChunkProviderServer.java
--- Original/Tuinity-Server/src/main/java/net/minecraft/server/ChunkProviderServer.java	2021-09-27 23:30:56.603097400 +0900
+++ Chiyogami/Chiyogami-Server/src/main/java/net/minecraft/server/ChunkProviderServer.java	2021-10-26 04:21:26.045750700 +0900
@@ -18,6 +18,7 @@
 import com.destroystokyo.paper.exception.ServerInternalException;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
+import org.spigotmc.AsyncCatcher;
 
 public class ChunkProviderServer extends IChunkProvider {
 
@@ -121,7 +122,7 @@
     long chunkFutureAwaitCounter; // Tuinity - private -> package private
 
     public void getEntityTickingChunkAsync(int x, int z, java.util.function.Consumer<Chunk> onLoad) {
-        if (Thread.currentThread() != this.serverThread) {
+        if (AsyncCatcher.isAsync()) {
             this.serverThreadQueue.execute(() -> {
                 ChunkProviderServer.this.getEntityTickingChunkAsync(x, z, onLoad);
             });
@@ -131,7 +132,7 @@
     }
 
     public void getTickingChunkAsync(int x, int z, java.util.function.Consumer<Chunk> onLoad) {
-        if (Thread.currentThread() != this.serverThread) {
+        if (AsyncCatcher.isAsync()) {
             this.serverThreadQueue.execute(() -> {
                 ChunkProviderServer.this.getTickingChunkAsync(x, z, onLoad);
             });
@@ -141,7 +142,7 @@
     }
 
     public void getFullChunkAsync(int x, int z, java.util.function.Consumer<Chunk> onLoad) {
-        if (Thread.currentThread() != this.serverThread) {
+        if (AsyncCatcher.isAsync()) {
             this.serverThreadQueue.execute(() -> {
                 ChunkProviderServer.this.getFullChunkAsync(x, z, onLoad);
             });
@@ -151,7 +152,7 @@
     }
 
     private void getChunkFutureAsynchronously(int x, int z, int ticketLevel, Function<PlayerChunk, CompletableFuture<Either<Chunk, PlayerChunk.Failure>>> futureGet, java.util.function.Consumer<Chunk> onLoad) {
-        if (Thread.currentThread() != this.serverThread) {
+        if (AsyncCatcher.isAsync()) {
             throw new IllegalStateException();
         }
         ChunkCoordIntPair chunkPos = new ChunkCoordIntPair(x, z);
@@ -250,7 +251,7 @@
     void getChunkAtAsynchronously(int chunkX, int chunkZ, int ticketLevel,
                                           java.util.function.Function<PlayerChunk, CompletableFuture<Either<IChunkAccess, PlayerChunk.Failure>>> function,
                                           java.util.function.Consumer<IChunkAccess> consumer) {
-        if (Thread.currentThread() != this.serverThread) {
+        if (AsyncCatcher.isAsync()) {
             throw new IllegalStateException();
         }
         ChunkCoordIntPair chunkPos = new ChunkCoordIntPair(chunkX, chunkZ);
@@ -437,7 +438,7 @@
     public Chunk getChunkAtIfLoadedImmediately(int x, int z) {
         long k = ChunkCoordIntPair.pair(x, z);
 
-        if (Thread.currentThread() == this.serverThread) {
+        if (!AsyncCatcher.isAsync()) {
             return this.getChunkAtIfLoadedMainThread(x, z);
         }
 
@@ -477,7 +478,7 @@
     private long asyncLoadSeqCounter;
 
     public CompletableFuture<Either<IChunkAccess, PlayerChunk.Failure>> getChunkAtAsynchronously(int x, int z, boolean gen, boolean isUrgent) {
-        if (Thread.currentThread() != this.serverThread) {
+        if (AsyncCatcher.isAsync()) {
             CompletableFuture<Either<IChunkAccess, PlayerChunk.Failure>> future = new CompletableFuture<Either<IChunkAccess, PlayerChunk.Failure>>();
             this.serverThreadQueue.execute(() -> {
                 this.getChunkAtAsynchronously(x, z, gen, isUrgent).whenComplete((chunk, ex) -> {
@@ -625,7 +626,7 @@
     @Override
     public IChunkAccess getChunkAt(int i, int j, ChunkStatus chunkstatus, boolean flag) {
         final int x = i; final int z = j; // Paper - conflict on variable change
-        if (Thread.currentThread() != this.serverThread) {
+        if (AsyncCatcher.isAsync()) {
             return (IChunkAccess) CompletableFuture.supplyAsync(() -> {
                 return this.getChunkAt(i, j, chunkstatus, flag);
             }, this.serverThreadQueue).join();
@@ -687,7 +688,7 @@
     @Nullable
     @Override
     public Chunk a(int i, int j) {
-        if (Thread.currentThread() != this.serverThread) {
+        if (AsyncCatcher.isAsync()) {
             return null;
         } else {
             return this.getChunkAtIfLoadedMainThread(i, j); // Paper - optimise for loaded chunks
diff --strip-trailing-cr -urN Original/Tuinity-Server/src/main/java/net/minecraft/server/DedicatedServer.java Chiyogami/Chiyogami-Server/src/main/java/net/minecraft/server/DedicatedServer.java
--- Original/Tuinity-Server/src/main/java/net/minecraft/server/DedicatedServer.java	2021-09-27 23:30:54.890470400 +0900
+++ Chiyogami/Chiyogami-Server/src/main/java/net/minecraft/server/DedicatedServer.java	2021-10-26 04:21:26.046750300 +0900
@@ -195,6 +195,7 @@
         com.destroystokyo.paper.VersionHistoryManager.INSTANCE.getClass(); // load version history now
         // Paper end
         com.tuinity.tuinity.config.TuinityConfig.init((File) options.valueOf("tuinity-settings")); // Tuinity - Server Config
+        world.chiyogami.ChiyogamiConfig.load();
 
         this.setSpawnAnimals(dedicatedserverproperties.spawnAnimals);
         this.setSpawnNPCs(dedicatedserverproperties.spawnNpcs);
diff --strip-trailing-cr -urN Original/Tuinity-Server/src/main/java/net/minecraft/server/Entity.java Chiyogami/Chiyogami-Server/src/main/java/net/minecraft/server/Entity.java
--- Original/Tuinity-Server/src/main/java/net/minecraft/server/Entity.java	2021-09-27 23:30:55.918490200 +0900
+++ Chiyogami/Chiyogami-Server/src/main/java/net/minecraft/server/Entity.java	2021-10-26 04:21:26.205134300 +0900
@@ -48,6 +48,7 @@
 import org.bukkit.event.entity.EntityPoseChangeEvent;
 import org.bukkit.event.player.PlayerTeleportEvent;
 import org.bukkit.plugin.PluginManager;
+import world.chiyogami.thread.WorldThreadPool;
 // CraftBukkit end
 
 public abstract class Entity implements INamableTileEntity, ICommandListener, KeyedObject { // Paper
@@ -977,7 +978,7 @@
         WorldServer world = ((WorldServer)this.world);
         AxisAlignedBB currBoundingBox = contractAmount == 0.0 ? this.getBoundingBox() : this.getBoundingBox().grow(-contractAmount);
 
-        List<AxisAlignedBB> potentialCollisions = com.tuinity.tuinity.util.CachedLists.getTempCollisionList();
+        List<AxisAlignedBB> potentialCollisions = com.tuinity.tuinity.util.CachedLists.getTempCollisionList(world.getWorld());
         try {
             // We take a fat guess that we actually need to do the step height checks.
             // So we collect all of the AABB's we would ever need into one list, and use that list
@@ -1021,7 +1022,7 @@
                 return limitedMoveVector;
             }
         } finally {
-            com.tuinity.tuinity.util.CachedLists.returnTempCollisionList(potentialCollisions);
+            com.tuinity.tuinity.util.CachedLists.returnTempCollisionList(potentialCollisions, world.getWorld());
         }
     }
     // Tuinity end - optimise entity movement
@@ -2843,18 +2844,27 @@
             LOGGER.warn("Illegal Entity Teleport " + this + " to " + dimensionmanager + ":" + location, new Throwable());
             return null;
         }
+        WorldThreadPool.catchWrongThread(world.getWorld(), "Entity teleportTo");
+        MinecraftServer minecraftserver = this.getMinecraftServer();
+        WorldServer worldserver1 = minecraftserver.getWorldServer(dimensionmanager);
+        if(!this.world.isClientSide) { // Chiyogami - Thread wait request
+            if(worldserver1 != null) {
+                if (worldserver1 != this.world) {
+                    WorldThreadPool.requestWaitForTask((WorldServer) this.world, worldserver1);
+                }
+            }
+        }
         // Paper end
         if (!this.world.isClientSide && !this.dead) {
             this.world.getMethodProfiler().enter("changeDimension");
-            MinecraftServer minecraftserver = this.getMinecraftServer();
+            //MinecraftServer minecraftserver = this.getMinecraftServer();
             DimensionManager dimensionmanager1 = this.dimension;
             WorldServer worldserver = minecraftserver.getWorldServer(dimensionmanager1);
-            WorldServer worldserver1 = minecraftserver.getWorldServer(dimensionmanager);
+            //WorldServer worldserver1 = minecraftserver.getWorldServer(dimensionmanager);
             // CraftBukkit start
             if (worldserver1 == null){
                 return null;
             }
-
             // this.dimension = dimensionmanager;
             // this.decouple();
             // CraftBukkit end
@@ -2878,6 +2888,13 @@
                 worldserver1 = ((CraftWorld) event.getTo().getWorld()).getHandle();
                 blockposition = new BlockPosition(event.getTo().getX(), event.getTo().getY(), event.getTo().getZ());
                 // CraftBukkit end
+                if(!this.world.isClientSide) { // Chiyogami - Thread wait request
+                    if(worldserver1 != null) {
+                        if (worldserver1 != this.world) {
+                            WorldThreadPool.requestWaitForTask((WorldServer) this.world, worldserver1);
+                        }
+                    }
+                }
             } else if (dimensionmanager.getType() == DimensionManager.THE_END) { // CraftBukkit
                 // CraftBukkit start
                 EntityPortalEvent event = CraftEventFactory.callEntityPortalEvent(this, worldserver1, worldserver1.getDimensionSpawn() != null ? worldserver1.getDimensionSpawn() : worldserver1.getSpawn(), 0);
@@ -2887,6 +2904,13 @@
                 worldserver1 = ((CraftWorld) event.getTo().getWorld()).getHandle();
                 blockposition = new BlockPosition(event.getTo().getX(), event.getTo().getY(), event.getTo().getZ());
                 // CraftBukkit end
+                if(!this.world.isClientSide) { // Chiyogami - Thread wait request
+                    if(worldserver1 != null) {
+                        if (worldserver1 != this.world) {
+                            WorldThreadPool.requestWaitForTask((WorldServer) this.world, worldserver1);
+                        }
+                    }
+                }
             } else {
                 double d0 = this.locX();
                 double d1 = this.locZ();
@@ -2921,6 +2945,13 @@
                 blockposition = new BlockPosition(event.getTo().getX(), event.getTo().getY(), event.getTo().getZ());
                 int searchRadius = event.getSearchRadius();
                 // CraftBukkit end
+                if(!this.world.isClientSide) { // Chiyogami - Thread wait request
+                    if(worldserver1 != null) {
+                        if (worldserver1 != this.world) {
+                            WorldThreadPool.requestWaitForTask((WorldServer) this.world, worldserver1);
+                        }
+                    }
+                }
                 ShapeDetector.Shape shapedetector_shape = worldserver1.getTravelAgent().findPortal(blockposition, vec3d, this.getPortalDirection(), vec3d1.x, vec3d1.y, this instanceof EntityHuman, searchRadius); // CraftBukkit - search radius
 
                 if (shapedetector_shape == null) {
diff --strip-trailing-cr -urN Original/Tuinity-Server/src/main/java/net/minecraft/server/EntityLiving.java Chiyogami/Chiyogami-Server/src/main/java/net/minecraft/server/EntityLiving.java
--- Original/Tuinity-Server/src/main/java/net/minecraft/server/EntityLiving.java	2021-09-27 23:30:56.008437600 +0900
+++ Chiyogami/Chiyogami-Server/src/main/java/net/minecraft/server/EntityLiving.java	2021-10-26 04:21:26.049748700 +0900
@@ -2683,7 +2683,7 @@
         }
         // Paper - end don't run getEntities if we're not going to use its result
         // Tuinity start - reduce memory allocation from collideNearby
-        List<Entity> list = com.tuinity.tuinity.util.CachedLists.getTempGetEntitiesList();
+        List<Entity> list = com.tuinity.tuinity.util.CachedLists.getTempGetEntitiesList(world.getWorld());
         this.world.getEntities(this, this.getBoundingBox(), IEntitySelector.a(this), list);
         try {
         // Tuinity end - reduce memory allocation from collideNearby
@@ -2716,7 +2716,7 @@
             }
         }
         } finally { // Tuinity start - reduce memory allocation from collideNearby
-            com.tuinity.tuinity.util.CachedLists.returnTempGetEntitiesList(list);
+            com.tuinity.tuinity.util.CachedLists.returnTempGetEntitiesList(list, world.getWorld());
         } // Tuinity end - reduce memory allocation from collideNearby
 
     }
diff --strip-trailing-cr -urN Original/Tuinity-Server/src/main/java/net/minecraft/server/EntityPlayer.java Chiyogami/Chiyogami-Server/src/main/java/net/minecraft/server/EntityPlayer.java
--- Original/Tuinity-Server/src/main/java/net/minecraft/server/EntityPlayer.java	2021-09-27 23:30:53.797565000 +0900
+++ Chiyogami/Chiyogami-Server/src/main/java/net/minecraft/server/EntityPlayer.java	2021-10-26 04:21:26.162240700 +0900
@@ -36,6 +36,7 @@
 import org.bukkit.event.player.PlayerTeleportEvent;
 import org.bukkit.event.player.PlayerTeleportEvent.TeleportCause;
 import org.bukkit.inventory.MainHand;
+import world.chiyogami.thread.WorldThreadPool;
 // CraftBukkit end
 
 public class EntityPlayer extends EntityHuman implements ICrafting {
@@ -808,6 +809,12 @@
 
     @Nullable
     public Entity a(DimensionManager dimensionmanager, PlayerTeleportEvent.TeleportCause cause) {
+        WorldServer to = dimensionmanager.world;
+        if(to != null){
+            if(to != this.world && !this.world.isClientSide){
+                WorldThreadPool.requestWaitForTask((WorldServer) this.world, to);
+            }
+        }
         // CraftBukkit end
         if (this.isSleeping()) return this; // CraftBukkit - SPIGOT-3154
         // this.worldChangeInvuln = true; // CraftBukkit - Moved down and into PlayerList#changeDimension
diff --strip-trailing-cr -urN Original/Tuinity-Server/src/main/java/net/minecraft/server/IAsyncTaskHandler.java Chiyogami/Chiyogami-Server/src/main/java/net/minecraft/server/IAsyncTaskHandler.java
--- Original/Tuinity-Server/src/main/java/net/minecraft/server/IAsyncTaskHandler.java	2021-09-27 23:30:53.830545900 +0900
+++ Chiyogami/Chiyogami-Server/src/main/java/net/minecraft/server/IAsyncTaskHandler.java	2021-10-26 04:21:26.050747900 +0900
@@ -8,6 +8,7 @@
 import java.util.function.BooleanSupplier;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
+import org.spigotmc.AsyncCatcher;
 
 public abstract class IAsyncTaskHandler<R extends Runnable> implements Mailbox<R>, Executor {
 
@@ -25,7 +26,7 @@
     protected abstract boolean canExecute(R r0);
 
     public boolean isMainThread() {
-        return Thread.currentThread() == this.getThread();
+        return !AsyncCatcher.isAsync();
     }
 
     protected abstract Thread getThread();
diff --strip-trailing-cr -urN Original/Tuinity-Server/src/main/java/net/minecraft/server/MCUtil.java Chiyogami/Chiyogami-Server/src/main/java/net/minecraft/server/MCUtil.java
--- Original/Tuinity-Server/src/main/java/net/minecraft/server/MCUtil.java	2021-09-27 23:30:56.488164200 +0900
+++ Chiyogami/Chiyogami-Server/src/main/java/net/minecraft/server/MCUtil.java	2021-10-26 04:21:26.051747400 +0900
@@ -317,7 +317,7 @@
      * @return
      */
     public static void ensureMain(String reason, Runnable run) {
-        if (AsyncCatcher.enabled && Thread.currentThread() != MinecraftServer.getServer().serverThread) {
+        if (AsyncCatcher.enabled && AsyncCatcher.isAsync()) {
             if (reason != null) {
                 new IllegalStateException("Asynchronous " + reason + "!").printStackTrace();
             }
@@ -342,7 +342,7 @@
      * @return
      */
     public static <T> T ensureMain(String reason, Supplier<T> run) {
-        if (AsyncCatcher.enabled && Thread.currentThread() != MinecraftServer.getServer().serverThread) {
+        if (AsyncCatcher.enabled && AsyncCatcher.isAsync()) {
             if (reason != null) {
                 new IllegalStateException("Asynchronous " + reason + "! Blocking thread until it returns ").printStackTrace();
             }
diff --strip-trailing-cr -urN Original/Tuinity-Server/src/main/java/net/minecraft/server/MinecraftServer.java Chiyogami/Chiyogami-Server/src/main/java/net/minecraft/server/MinecraftServer.java
--- Original/Tuinity-Server/src/main/java/net/minecraft/server/MinecraftServer.java	2021-09-27 23:30:55.925485100 +0900
+++ Chiyogami/Chiyogami-Server/src/main/java/net/minecraft/server/MinecraftServer.java	2021-10-26 04:21:26.111713400 +0900
@@ -1,5 +1,6 @@
 package net.minecraft.server;
 
+import co.aikar.timings.TimingHandler;
 import com.google.common.base.Splitter;
 import co.aikar.timings.Timings;
 import com.destroystokyo.paper.event.server.PaperServerListPingEvent;
@@ -48,6 +49,7 @@
 import java.util.UUID;
 import java.util.Map.Entry;
 import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.Executor;
 import java.util.function.BooleanSupplier;
 import javax.annotation.Nullable;
@@ -68,6 +70,11 @@
 // CraftBukkit end
 import co.aikar.timings.MinecraftTimings; // Paper
 import org.spigotmc.SlackActivityAccountant; // Spigot
+import world.chiyogami.chiyogamilib.WorldThreads;
+import world.chiyogami.chiyogamilib.monitor.PerformanceMonitor;
+import world.chiyogami.chiyogamilib.monitor.WorkMode;
+import world.chiyogami.chiyogamilib.scheduler.WorldThreadRunnable;
+import world.chiyogami.thread.WorldThreadPool;
 
 public abstract class MinecraftServer extends IAsyncTaskHandlerReentrant<TickTask> implements IMojangStatistics, ICommandListener, AutoCloseable, Runnable {
 
@@ -1082,6 +1089,7 @@
 
     public final void executeMidTickTasks() {
         org.spigotmc.AsyncCatcher.catchOp("mid tick chunk task execution");
+        if(Thread.currentThread() != this.serverThread) return;
         long startTime = System.nanoTime();
         if ((startTime - lastMidTickExecute) <= CHUNK_TASK_QUEUE_BACKOFF_MIN_TIME || (startTime - lastMidTickExecuteFailure) <= TASK_EXECUTION_FAILURE_BACKOFF) {
             // it's shown to be bad to constantly hit the queue (chunk loads slow to a crawl), even if no tasks are executed.
@@ -1222,6 +1230,7 @@
     protected void exit() {}
 
     protected void a(BooleanSupplier booleansupplier) {
+        long fullServerTickNanoTime = System.nanoTime(); // Chiyogami
         co.aikar.timings.TimingsManager.FULL_SERVER_TICK.startTiming(); // Paper
         this.slackActivityAccountant.tickStarted(); // Spigot
         long i = SystemUtils.getMonotonicNanos();
@@ -1317,8 +1326,11 @@
         org.spigotmc.WatchdogThread.tick(); // Spigot
         this.slackActivityAccountant.tickEnded(l); // Spigot
         co.aikar.timings.TimingsManager.FULL_SERVER_TICK.stopTiming(); // Paper
+        PerformanceMonitor.setFullServerTickNanoTime(System.nanoTime() - fullServerTickNanoTime); // Chiyogami
     }
 
+    private static BooleanSupplier staticBooleanSupplier = null;
+    
     protected void b(BooleanSupplier booleansupplier) {
         // Tuinity - replace logic
         MinecraftTimings.bukkitSchedulerTimer.startTiming(); // Spigot // Paper
@@ -1362,16 +1374,32 @@
         }
         // Paper end
         MinecraftTimings.timeUpdateTimer.stopTiming(); // Spigot // Paper
-
+    
+        long worldServerTickNanoTime = System.nanoTime();
+        //Map<org.bukkit.World, Long> worldThreadTimeMap = new ConcurrentHashMap<>();
+        staticBooleanSupplier = booleansupplier;
         while (iterator.hasNext()) {
             WorldServer worldserver = (WorldServer) iterator.next();
-
-            worldserver.hasPhysicsEvent =  org.bukkit.event.block.BlockPhysicsEvent.getHandlerList().getRegisteredListeners().length > 0; // Paper
-            TileEntityHopper.skipHopperEvents = worldserver.paperConfig.disableHopperMoveEvents || org.bukkit.event.inventory.InventoryMoveItemEvent.getHandlerList().getRegisteredListeners().length == 0; // Paper
-            if (true || worldserver.worldProvider.getDimensionManager() == DimensionManager.OVERWORLD || this.getAllowNether()) { // CraftBukkit
-                this.methodProfiler.a(() -> {
-                    return worldserver.getWorldData().getName() + " " + IRegistry.DIMENSION_TYPE.getKey(worldserver.worldProvider.getDimensionManager());
-                });
+    
+            WorldThreadPool.worldServers.add(worldserver);
+            
+            WorldThreadPool.tickRunnableMap.computeIfAbsent(worldserver, k -> () -> {
+    
+                WorldThreads.worldThreadMap.put(worldserver.getWorld(), Thread.currentThread());
+                
+                TimingHandler.initializeWorldTiming();
+    
+                long worldServerThreadNanoTime = System.nanoTime();
+    
+                WorldThreadRunnable.worldThreadHeartBeat(worldserver.getWorld(), currentTick); // Chiyogami
+    
+    
+                worldserver.hasPhysicsEvent = org.bukkit.event.block.BlockPhysicsEvent.getHandlerList().getRegisteredListeners().length > 0; // Paper
+                TileEntityHopper.skipHopperEvents = worldserver.paperConfig.disableHopperMoveEvents || org.bukkit.event.inventory.InventoryMoveItemEvent.getHandlerList().getRegisteredListeners().length == 0; // Paper
+                if (true || worldserver.worldProvider.getDimensionManager() == DimensionManager.OVERWORLD || this.getAllowNether()) { // CraftBukkit
+                    this.methodProfiler.a(() -> {
+                        return worldserver.getWorldData().getName() + " " + IRegistry.DIMENSION_TYPE.getKey(worldserver.worldProvider.getDimensionManager());
+                    });
                 /* Drop global time updates
                 if (this.ticks % 20 == 0) {
                     this.methodProfiler.enter("timeSync");
@@ -1379,35 +1407,46 @@
                     this.methodProfiler.exit();
                 }
                 // CraftBukkit end */
-
-                this.methodProfiler.enter("tick");
-
-                try {
-                    // Tuinity - replace logic
-                    worldserver.timings.doTick.startTiming(); // Spigot
-                    worldserver.doTick(booleansupplier);
-                    worldserver.timings.doTick.stopTiming(); // Spigot
-                    // Tuinity - replace logic
-                } catch (Throwable throwable) {
-                    // Spigot Start
-                    if (throwable instanceof ThreadDeath) { throw throwable; } // Paper
-                    CrashReport crashreport;
+        
+                    this.methodProfiler.enter("tick");
+        
                     try {
-                        crashreport = CrashReport.a(throwable, "Exception ticking world");
-                    } catch (Throwable t) {
-                        throw new RuntimeException("Error generating crash report", t);
+                        // Tuinity - replace logic
+                        ((TimingHandler.WorldTiming)worldserver.timings.doTick).startTiming(true); // Spigot
+                        worldserver.doTick(/*booleansupplier*/staticBooleanSupplier);
+                        worldserver.timings.doTick.stopTiming(); // Spigot
+                        // Tuinity - replace logic
+                    } catch (Throwable throwable) {
+                        // Spigot Start
+                        if (throwable instanceof ThreadDeath) {
+                            throw throwable;
+                        } // Paper
+                        CrashReport crashreport;
+                        try {
+                            crashreport = CrashReport.a(throwable, "Exception ticking world");
+                        } catch (Throwable t) {
+                            throw new RuntimeException("Error generating crash report", t);
+                        }
+                        // Spigot End
+            
+                        worldserver.a(crashreport);
+                        throw new ReportedException(crashreport);
                     }
-                    // Spigot End
-
-                    worldserver.a(crashreport);
-                    throw new ReportedException(crashreport);
+        
+                    this.methodProfiler.exit();
+                    this.methodProfiler.exit();
+                    worldserver.explosionDensityCache.clear(); // Paper - Optimize explosions
                 }
-
-                this.methodProfiler.exit();
-                this.methodProfiler.exit();
-                worldserver.explosionDensityCache.clear(); // Paper - Optimize explosions
-            }
+                PerformanceMonitor.getWorldTickNanoTimeMap().put(worldserver.getWorld(), System.nanoTime() - worldServerThreadNanoTime);
+            });
         }
+        
+        WorldThreadPool.doTick();
+        
+        WorldThreads.worldThreadMap.clear();
+        TimingHandler.clearWorldTimings();
+        //PerformanceMonitor.setWorldTickNanoTimeMap(worldThreadTimeMap);
+        PerformanceMonitor.setAllWorldTickNanoTime(System.nanoTime() - worldServerTickNanoTime);
 
         this.methodProfiler.exitEnter("connection");
         MinecraftTimings.connectionTimer.startTiming(); // Spigot
@@ -1631,7 +1670,7 @@
     }
 
     public String getServerModName() {
-        return "Tuinity"; // Tuinity //Paper - Paper > // Spigot - Spigot > // CraftBukkit - cb > vanilla!
+        return "Chiyogami"; // Tuinity //Paper - Paper > // Spigot - Spigot > // CraftBukkit - cb > vanilla!
     }
 
     public CrashReport b(CrashReport crashreport) {
diff --strip-trailing-cr -urN Original/Tuinity-Server/src/main/java/net/minecraft/server/PlayerChunkMap.java Chiyogami/Chiyogami-Server/src/main/java/net/minecraft/server/PlayerChunkMap.java
--- Original/Tuinity-Server/src/main/java/net/minecraft/server/PlayerChunkMap.java	2021-09-27 23:30:56.430196500 +0900
+++ Chiyogami/Chiyogami-Server/src/main/java/net/minecraft/server/PlayerChunkMap.java	2021-10-26 04:21:26.163239800 +0900
@@ -32,11 +32,8 @@
 import java.util.Optional;
 import java.util.Queue;
 import java.util.Set;
-import java.util.concurrent.CancellationException;
+import java.util.concurrent.*;
 import java.util.UUID; // Paper
-import java.util.concurrent.CompletableFuture;
-import java.util.concurrent.CompletionException;
-import java.util.concurrent.Executor;
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.function.BooleanSupplier;
 import java.util.function.Consumer;
@@ -439,12 +436,17 @@
     // Paper start - Chunk Prioritization
     public void queueHolderUpdate(PlayerChunk playerchunk) {
         Runnable runnable = () -> {
-            if (isUnloading(playerchunk)) {
-                return; // unloaded
-            }
-            chunkDistanceManager.pendingChunkUpdates.add(playerchunk);
-            if (!chunkDistanceManager.pollingPendingChunkUpdates) {
-                world.getChunkProvider().tickDistanceManager();
+            chunkDistanceManager.CHUNK_UPDATE_LOCK.lock();
+            try {
+                if (isUnloading(playerchunk)) {
+                    return; // unloaded
+                }
+                chunkDistanceManager.pendingChunkUpdates.add(playerchunk);
+                if (!chunkDistanceManager.pollingPendingChunkUpdates) {
+                    world.getChunkProvider().tickDistanceManager();
+                }
+            } finally {
+                chunkDistanceManager.CHUNK_UPDATE_LOCK.unlock();
             }
         };
         if (MCUtil.isMainThread()) {
@@ -629,7 +631,7 @@
         }
     }
     public Long2ObjectLinkedOpenHashMap<PlayerChunk> getVisibleChunks() {
-        if (Thread.currentThread() == this.world.serverThread) {
+        if (!AsyncCatcher.isAsync()) {
             return this.visibleChunks;
         } else {
             synchronized (this.visibleChunks) {
@@ -646,7 +648,7 @@
     @Nullable
     public PlayerChunk getVisibleChunk(long i) { // Paper - protected -> public
         // Paper start - mt safe get
-        if (Thread.currentThread() != this.world.serverThread) {
+        if (AsyncCatcher.isAsync()) {
             synchronized (this.visibleChunks) {
                 return (PlayerChunk) (this.hasPendingVisibleUpdate ? this.pendingVisibleChunks.get(i) : ((ProtectedVisibleChunksMap)this.visibleChunks).safeGet(i));
             }
diff --strip-trailing-cr -urN Original/Tuinity-Server/src/main/java/net/minecraft/server/World.java Chiyogami/Chiyogami-Server/src/main/java/net/minecraft/server/World.java
--- Original/Tuinity-Server/src/main/java/net/minecraft/server/World.java	2021-09-27 23:30:56.517146600 +0900
+++ Chiyogami/Chiyogami-Server/src/main/java/net/minecraft/server/World.java	2021-10-26 04:21:26.165238900 +0900
@@ -32,6 +32,7 @@
 import org.bukkit.craftbukkit.block.CraftBlockState;
 import org.bukkit.craftbukkit.block.data.CraftBlockData;
 import org.bukkit.event.block.BlockPhysicsEvent;
+import org.spigotmc.AsyncCatcher;
 // CraftBukkit end
 
 public abstract class World implements GeneratorAccess, AutoCloseable {
@@ -270,7 +271,7 @@
     @Override
     public Chunk getChunkAt(int i, int j) {
         // Paper start - optimise this for loaded chunks
-        if (Thread.currentThread() == this.serverThread) {
+        if (!AsyncCatcher.isAsync()) {
             Chunk ifLoaded = ((WorldServer) this).getChunkProvider().getChunkAtIfLoadedMainThread(i, j);
             if (ifLoaded != null) {
                 return ifLoaded;
@@ -279,6 +280,13 @@
         // Paper end
         return (Chunk) this.getChunkAt(i, j, ChunkStatus.FULL);
     }
+    
+    public Chunk getChunkAtWorldThread(int x, int z, boolean gen){
+        AsyncCatcher.catchOp("get chunk at off world thread");
+    
+        this.getWorld().loadChunk(x, z, gen);
+        return ((ChunkProviderServer) this.chunkProvider).getChunkAtIfLoadedMainThread(x, z);
+    }
 
     // Paper start - if loaded
     @Nullable
@@ -1075,7 +1083,7 @@
         // CraftBukkit end
         if (isOutsideWorld(blockposition)) {
             return null;
-        } else if (!this.isClientSide && Thread.currentThread() != this.serverThread) {
+        } else if (!this.isClientSide && AsyncCatcher.isAsync()) {
             return null;
         } else {
             // CraftBukkit start
diff --strip-trailing-cr -urN Original/Tuinity-Server/src/main/java/net/minecraft/server/WorldServer.java Chiyogami/Chiyogami-Server/src/main/java/net/minecraft/server/WorldServer.java
--- Original/Tuinity-Server/src/main/java/net/minecraft/server/WorldServer.java	2021-09-27 23:30:56.563120200 +0900
+++ Chiyogami/Chiyogami-Server/src/main/java/net/minecraft/server/WorldServer.java	2021-10-26 04:21:26.166238200 +0900
@@ -1,5 +1,6 @@
 package net.minecraft.server;
 
+import co.aikar.timings.Timing;
 import com.google.common.annotations.VisibleForTesting;
 import co.aikar.timings.TimingHistory; // Paper
 import co.aikar.timings.Timings; // Paper
@@ -22,15 +23,9 @@
 import java.io.IOException;
 import java.io.Writer;
 import java.nio.file.Files;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Map;
-import java.util.Objects;
-import java.util.Optional;
-import java.util.Queue;
-import java.util.Random;
-import java.util.Set;
-import java.util.UUID;
+import java.util.*;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.CopyOnWriteArrayList;
 import java.util.concurrent.Executor;
 import java.util.function.BooleanSupplier;
 import java.util.function.Predicate;
@@ -49,6 +44,8 @@
 import org.bukkit.event.server.MapInitializeEvent;
 import org.bukkit.event.weather.LightningStrikeEvent;
 import org.bukkit.event.world.TimeSkipEvent;
+import org.spigotmc.AsyncCatcher;
+import world.chiyogami.chiyogamilib.WorldThreads;
 // CraftBukkit end
 
 public class WorldServer extends World {
@@ -58,7 +55,7 @@
     public final Int2ObjectMap<Entity> entitiesById = new Int2ObjectLinkedOpenHashMap(); final com.tuinity.tuinity.util.maplist.IteratorSafeOrderedReferenceSet<Entity> entitiesForIteration = new com.tuinity.tuinity.util.maplist.IteratorSafeOrderedReferenceSet<>(2048, 0.5f, 2048, 0.2); // Tuinity - make removing entities while ticking safe
     private final Map<UUID, Entity> entitiesByUUID = Maps.newHashMap();
     private final Queue<Entity> entitiesToAdd = Queues.newArrayDeque();
-    public final List<EntityPlayer> players = Lists.newArrayList(); // Paper - private -> public
+    public final List<EntityPlayer> players = new CopyOnWriteArrayList<>(); // Paper - private -> public
     boolean tickingEntities;
     // Paper start
     List<java.lang.Runnable> afterEntityTickingTasks = Lists.newArrayList();
@@ -222,7 +219,7 @@
 
     public final void loadChunksForMoveAsync(AxisAlignedBB axisalignedbb, double toX, double toZ,
                                              java.util.function.Consumer<List<IChunkAccess>> onLoad) {
-        if (Thread.currentThread() != this.serverThread) {
+        if (AsyncCatcher.isAsync()) {
             this.getChunkProvider().serverThreadQueue.execute(() -> {
                 this.loadChunksForMoveAsync(axisalignedbb, toX, toZ, onLoad);
             });
@@ -629,7 +626,7 @@
             return;
         }
         AxisAlignedBB axisalignedbb1 = axisalignedbb.grow(1.0E-7D, 1.0E-7D, 1.0E-7D);
-        List<Entity> entities = com.tuinity.tuinity.util.CachedLists.getTempGetEntitiesList();
+        List<Entity> entities = com.tuinity.tuinity.util.CachedLists.getTempGetEntitiesList(this.getWorld());
         try {
             if (entity != null && entity.hardCollides()) {
                 this.getEntities(entity, axisalignedbb, IEntitySelector.notSpectator(), entities);
@@ -661,7 +658,7 @@
                 }
             }
         } finally {
-            com.tuinity.tuinity.util.CachedLists.returnTempGetEntitiesList(entities);
+            com.tuinity.tuinity.util.CachedLists.returnTempGetEntitiesList(entities, this.getWorld());
         }
     }
 
@@ -690,7 +687,7 @@
     @Override
     protected TileEntity getTileEntity(BlockPosition pos, boolean validate) {
         TileEntity result = super.getTileEntity(pos, validate);
-        if (!validate || Thread.currentThread() != this.serverThread) {
+        if (!validate || AsyncCatcher.isAsync()) {
             // SPIGOT-5378: avoid deadlock, this can be called in loading logic (i.e lighting) but getType() will block on chunk load
             return result;
         }
@@ -1248,7 +1245,7 @@
             // Spigot end
 
             TimingHistory.activatedEntityTicks++; // Paper - timings
-            entity.tickTimer.startTiming(); // Spigot
+            Timing timing = this.timings.getEntityTickTimer(entity).startTiming(); // Spigot
             try { // Paper - timings
             entity.f(entity.locX(), entity.locY(), entity.locZ());
             entity.lastYaw = entity.yaw;
@@ -1277,7 +1274,7 @@
                 }
             }
             } finally { // Paper - timings
-            entity.tickTimer.stopTiming(); // Spigot
+            timing.stopTiming(); // Spigot
             } // Paper - timings
 
         }
@@ -1340,7 +1337,11 @@
             if (!entity.valid && !entity.cc() && !this.isChunkLoaded(i, k)) { // Paper - always load chunks to register valid entities location
                 entity.inChunk = false;
             } else {
-                this.getChunkAt(i, k).a(entity);
+                if(WorldThreads.isWorldThread()){
+                    this.getChunkAtWorldThread(i, k, true).a(entity);
+                }else{
+                    this.getChunkAt(i, k).a(entity);
+                }
             }
         }
 
@@ -1795,6 +1796,7 @@
         java.util.List<Entity> toMoveChunks = new java.util.ArrayList<>(); // Paper
         for (int j = 0; j < i; ++j) {
             List<Entity> entityslice = aentityslice[j]; // Spigot
+            Set<Entity> removeEntities = new HashSet<>();
             Iterator iterator = entityslice.iterator();
 
             while (iterator.hasNext()) {
@@ -1815,9 +1817,10 @@
                     this.entitiesById.remove(entity.getId());
                     this.unregisterEntity(entity);
 
-                    if (entity.dead) iterator.remove(); // Paper - don't save dead entities during unload
+                    if (entity.dead) removeEntities.add(entity); // Paper - don't save dead entities during unload
                 }
             }
+            entityslice.removeAll(removeEntities);
         }
         // Paper start - move out entities that shouldn't be in this chunk before it unloads
         for (Entity entity : toMoveChunks) {
diff --strip-trailing-cr -urN Original/Tuinity-Server/src/main/java/org/bukkit/craftbukkit/CraftServer.java Chiyogami/Chiyogami-Server/src/main/java/org/bukkit/craftbukkit/CraftServer.java
--- Original/Tuinity-Server/src/main/java/org/bukkit/craftbukkit/CraftServer.java	2021-09-27 23:30:55.011401300 +0900
+++ Chiyogami/Chiyogami-Server/src/main/java/org/bukkit/craftbukkit/CraftServer.java	2021-10-26 04:21:26.058743400 +0900
@@ -200,12 +200,13 @@
 import org.yaml.snakeyaml.error.MarkedYAMLException;
 
 import net.md_5.bungee.api.chat.BaseComponent; // Spigot
+import world.chiyogami.chiyogamilib.WorldThreads;
 
 import javax.annotation.Nullable; // Paper
 import javax.annotation.Nonnull; // Paper
 
 public final class CraftServer implements Server {
-    private final String serverName = "Tuinity"; // Paper // Tuinity
+    private final String serverName = "Chiyogami"; // Paper // Tuinity
     private final String serverVersion;
     private final String bukkitVersion = Versioning.getBukkitVersion();
     private final Logger logger = Logger.getLogger("Minecraft");
@@ -1751,7 +1752,7 @@
     public boolean isPrimaryThread() {
         // Tuinity start
         final Thread currThread = Thread.currentThread();
-        return currThread == console.serverThread || currThread instanceof com.tuinity.tuinity.util.TickThread || currThread.equals(net.minecraft.server.MinecraftServer.getServer().shutdownThread); // Paper - Fix issues with detecting main thread properly, the only time Watchdog will be used is during a crash shutdown which is a "try our best" scenario
+        return currThread == console.serverThread || currThread instanceof com.tuinity.tuinity.util.TickThread || currThread.equals(net.minecraft.server.MinecraftServer.getServer().shutdownThread) || WorldThreads.worldThreadMap.containsValue(Thread.currentThread()); // Paper - Fix issues with detecting main thread properly, the only time Watchdog will be used is during a crash shutdown which is a "try our best" scenario
         // Tuinity End
     }
 
diff --strip-trailing-cr -urN Original/Tuinity-Server/src/main/java/org/bukkit/craftbukkit/CraftWorld.java Chiyogami/Chiyogami-Server/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
--- Original/Tuinity-Server/src/main/java/org/bukkit/craftbukkit/CraftWorld.java	2021-09-27 23:30:56.387222000 +0900
+++ Chiyogami/Chiyogami-Server/src/main/java/org/bukkit/craftbukkit/CraftWorld.java	2021-10-26 04:21:26.115710800 +0900
@@ -265,6 +265,7 @@
 import org.bukkit.util.Consumer;
 import org.bukkit.util.RayTraceResult;
 import org.bukkit.util.Vector;
+import org.spigotmc.AsyncCatcher;
 
 public class CraftWorld implements World {
     public static final int CUSTOM_DIMENSION_OFFSET = 10;
@@ -453,7 +454,7 @@
     @Override
     public Chunk[] getLoadedChunks() {
         // Paper start
-        if (Thread.currentThread() != world.getMinecraftWorld().serverThread) {
+        if (AsyncCatcher.isAsync()) {
             synchronized (world.getChunkProvider().playerChunkMap.visibleChunks) {
                 Long2ObjectLinkedOpenHashMap<PlayerChunk> chunks = world.getChunkProvider().playerChunkMap.visibleChunks;
                 return chunks.values().stream().map(PlayerChunk::getFullChunk).filter(Objects::nonNull).map(net.minecraft.server.Chunk::getBukkitChunk).toArray(Chunk[]::new);
@@ -681,7 +682,7 @@
     public Map<Plugin, Collection<Chunk>> getPluginChunkTickets() {
         Map<Plugin, ImmutableList.Builder<Chunk>> ret = new HashMap<>();
         ChunkMapDistance chunkDistanceManager = this.world.getChunkProvider().playerChunkMap.chunkDistanceManager;
-
+    
         for (Long2ObjectMap.Entry<ArraySetSorted<Ticket<?>>> chunkTickets : chunkDistanceManager.tickets.long2ObjectEntrySet()) {
             long chunkKey = chunkTickets.getLongKey();
             ArraySetSorted<Ticket<?>> tickets = chunkTickets.getValue();
diff --strip-trailing-cr -urN Original/Tuinity-Server/src/main/java/org/bukkit/craftbukkit/entity/CraftEntity.java Chiyogami/Chiyogami-Server/src/main/java/org/bukkit/craftbukkit/entity/CraftEntity.java
--- Original/Tuinity-Server/src/main/java/org/bukkit/craftbukkit/entity/CraftEntity.java	2021-09-27 23:30:56.237306500 +0900
+++ Chiyogami/Chiyogami-Server/src/main/java/org/bukkit/craftbukkit/entity/CraftEntity.java	2021-10-26 04:21:26.207133400 +0900
@@ -164,6 +164,7 @@
 import org.bukkit.util.BoundingBox;
 import org.bukkit.util.NumberConversions;
 import org.bukkit.util.Vector;
+import world.chiyogami.thread.WorldThreadPool;
 
 public abstract class CraftEntity implements org.bukkit.entity.Entity {
     private static PermissibleBase perm;
@@ -496,6 +497,7 @@
     public boolean teleport(Location location, TeleportCause cause) {
         Preconditions.checkArgument(location != null, "location");
         location.checkFinite();
+        WorldThreadPool.catchWrongThread(this.getWorld(), "CraftEntity teleport");
 
         if (entity.isVehicle() || entity.dead) {
             return false;
@@ -563,6 +565,7 @@
     @Override
     public List<org.bukkit.entity.Entity> getNearbyEntities(double x, double y, double z) {
         org.spigotmc.AsyncCatcher.catchOp("getNearbyEntities"); // Spigot
+        WorldThreadPool.catchWrongThread(this.getWorld(), "CraftEntity getNearByEntities");
         List<Entity> notchEntityList = entity.world.getEntities(entity, entity.getBoundingBox().grow(x, y, z), null);
         List<org.bukkit.entity.Entity> bukkitEntityList = new java.util.ArrayList<org.bukkit.entity.Entity>(notchEntityList.size());
 
diff --strip-trailing-cr -urN Original/Tuinity-Server/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java Chiyogami/Chiyogami-Server/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
--- Original/Tuinity-Server/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java	2021-09-27 23:30:54.175348800 +0900
+++ Chiyogami/Chiyogami-Server/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java	2021-10-26 04:21:26.208132400 +0900
@@ -124,6 +124,7 @@
 import org.bukkit.scoreboard.Scoreboard;
 
 import net.md_5.bungee.api.chat.BaseComponent; // Spigot
+import world.chiyogami.thread.WorldThreadPool;
 
 @DelegateDeserialization(CraftOfflinePlayer.class)
 public class CraftPlayer extends CraftHumanEntity implements Player {
@@ -751,6 +752,7 @@
         Preconditions.checkArgument(location != null, "location");
         Preconditions.checkArgument(location.getWorld() != null, "location.world");
         location.checkFinite();
+        WorldThreadPool.catchWrongThread(this.getWorld(), "CraftPlayer teleport");
 
         EntityPlayer entity = getHandle();
 
@@ -794,6 +796,12 @@
         // Grab the To and From World Handles.
         WorldServer fromWorld = ((CraftWorld) from.getWorld()).getHandle();
         WorldServer toWorld = ((CraftWorld) to.getWorld()).getHandle();
+        
+        if(toWorld != null){
+            if(toWorld != fromWorld && !toWorld.isClientSide){
+                WorldThreadPool.requestWaitForTask(fromWorld, toWorld);
+            }
+        }
 
         // Close any foreign inventory
         if (getHandle().activeContainer != getHandle().defaultContainer) {
diff --strip-trailing-cr -urN Original/Tuinity-Server/src/main/java/org/spigotmc/AsyncCatcher.java Chiyogami/Chiyogami-Server/src/main/java/org/spigotmc/AsyncCatcher.java
--- Original/Tuinity-Server/src/main/java/org/spigotmc/AsyncCatcher.java	2021-09-27 23:30:55.096352700 +0900
+++ Chiyogami/Chiyogami-Server/src/main/java/org/spigotmc/AsyncCatcher.java	2021-10-26 04:21:26.061741500 +0900
@@ -15,4 +15,8 @@
             throw new IllegalStateException( "Asynchronous " + reason + "!" );
         }
     }
+    
+    public static boolean isAsync(){
+        return !org.bukkit.Bukkit.isPrimaryThread();
+    }
 }
diff --strip-trailing-cr -urN Original/Tuinity-Server/src/main/java/world/chiyogami/ChiyogamiConfig.java Chiyogami/Chiyogami-Server/src/main/java/world/chiyogami/ChiyogamiConfig.java
--- Original/Tuinity-Server/src/main/java/world/chiyogami/ChiyogamiConfig.java	1970-01-01 09:00:00.000000000 +0900
+++ Chiyogami/Chiyogami-Server/src/main/java/world/chiyogami/ChiyogamiConfig.java	2021-10-26 04:21:26.169236300 +0900
@@ -0,0 +1,55 @@
+package world.chiyogami;
+
+import org.bukkit.configuration.file.YamlConfiguration;
+import world.chiyogami.chiyogamilib.monitor.WorkMode;
+import world.chiyogami.log.ChiyogamiLogger;
+import world.chiyogami.thread.WorldThreadPool;
+
+import java.io.File;
+
+public final class ChiyogamiConfig {
+    
+    private static final String MAX_THREADS = "max-world-threads";
+    
+    private static final String CHIYOGAMI_LOG = "show-detail-log";
+    
+    
+    private static YamlConfiguration yml;
+    
+    private static int maxThreads = 0;
+    
+    private static boolean showLogs = true;
+    
+    
+    public static void load(){
+        try {
+            
+            File file = new File("chiyogami.yml");
+    
+            if (file.exists()) {
+                yml = YamlConfiguration.loadConfiguration(file);
+            } else {
+                yml = new YamlConfiguration();
+                yml.set(MAX_THREADS, 0);
+                yml.set(CHIYOGAMI_LOG, true);
+                yml.save(file);
+            }
+            
+            if(yml.contains(MAX_THREADS)){
+                maxThreads = yml.getInt(MAX_THREADS);
+                WorldThreadPool.setMaxPoolSize(maxThreads);
+                WorkMode.MULTI_THREAD_TICK = maxThreads != 1;
+            }
+            
+            if(yml.contains(CHIYOGAMI_LOG)){
+                showLogs = yml.getBoolean(CHIYOGAMI_LOG);
+                ChiyogamiLogger.isShowLogs = showLogs;
+            }
+            
+        }catch (Exception e){e.printStackTrace();}
+    }
+    
+    public static String getMaxThreads() {return MAX_THREADS;}
+    
+    public static boolean isShowLogs() {return showLogs;}
+}
diff --strip-trailing-cr -urN Original/Tuinity-Server/src/main/java/world/chiyogami/log/ChiyogamiLogger.java Chiyogami/Chiyogami-Server/src/main/java/world/chiyogami/log/ChiyogamiLogger.java
--- Original/Tuinity-Server/src/main/java/world/chiyogami/log/ChiyogamiLogger.java	1970-01-01 09:00:00.000000000 +0900
+++ Chiyogami/Chiyogami-Server/src/main/java/world/chiyogami/log/ChiyogamiLogger.java	2021-10-26 04:21:26.170235800 +0900
@@ -0,0 +1,13 @@
+package world.chiyogami.log;
+
+public class ChiyogamiLogger {
+    
+    public static boolean isShowLogs = true;
+    
+    public static void info(String string){
+        if(!isShowLogs) return;
+        string = "Chiyogami : INFO > " + string;
+        System.out.println(string);
+    }
+    
+}
diff --strip-trailing-cr -urN Original/Tuinity-Server/src/main/java/world/chiyogami/thread/WorldThreadPool.java Chiyogami/Chiyogami-Server/src/main/java/world/chiyogami/thread/WorldThreadPool.java
--- Original/Tuinity-Server/src/main/java/world/chiyogami/thread/WorldThreadPool.java	1970-01-01 09:00:00.000000000 +0900
+++ Chiyogami/Chiyogami-Server/src/main/java/world/chiyogami/thread/WorldThreadPool.java	2021-10-26 04:21:26.209131800 +0900
@@ -0,0 +1,159 @@
+package world.chiyogami.thread;
+
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.server.WorldServer;
+import org.bukkit.World;
+import org.bukkit.craftbukkit.CraftWorld;
+import world.chiyogami.chiyogamilib.WorldThreads;
+import world.chiyogami.log.ChiyogamiLogger;
+
+import java.util.*;
+import java.util.concurrent.*;
+import java.util.concurrent.locks.ReentrantLock;
+
+public class WorldThreadPool {
+
+    public static final Map<WorldServer, Runnable> tickRunnableMap = new HashMap<>();
+    
+    public static final Set<WorldServer> worldServers = new HashSet<>();
+    
+    private static final Map<WorldServer, Future<?>> worldThreadFutureMap = new HashMap<>();
+    
+    
+    private static ExecutorService executorService = null;
+    
+    private static int maxPoolSize = 0;
+    
+    private static int previousPoolSize = 0;
+    
+    public static void setMaxPoolSize(int poolSize) {WorldThreadPool.maxPoolSize = poolSize;}
+    
+    
+    private static final Map<WorldServer, WorldServer> waitWorldServerMap = new HashMap<>();
+    
+    private static final Map<WorldServer, WorldServer> waitedWorldServerMap = new HashMap<>();
+    
+    private static final ReentrantLock WAIT_REQUEST_LOCK = new ReentrantLock(true);
+    
+    public static boolean isDoneWorldServerTask(WorldServer worldServer){
+        WAIT_REQUEST_LOCK.lock();
+        try {
+            return worldThreadFutureMap.get(worldServer).isDone();
+        } finally {
+            WAIT_REQUEST_LOCK.unlock();
+        }
+    }
+    
+    public static void catchWrongThread(World world, String reason){
+        
+        Thread currentThread = Thread.currentThread();
+        
+        if(currentThread == MinecraftServer.getServer().serverThread) return;
+        if(currentThread == WorldThreads.worldThreadMap.get(world)) return;
+        if(isDoneWorldServerTask(((CraftWorld) world).getHandle())) return;
+    
+        throw new IllegalStateException("Chiyogami > Called from a thread in another world -> " + reason
+                + System.lineSeparator() + "This operation is unacceptable because it can cause serious damage to this server."
+                + System.lineSeparator() + "It has been rejected by Chiyogami, it is not a bug.");
+    }
+    
+    public static void requestWaitForTask(WorldServer from, WorldServer to){
+    
+        if(maxPoolSize == 1) return;
+        if(Thread.currentThread() == MinecraftServer.getServer().serverThread) return;
+        if(!WorldThreads.isWorldThread()) return;
+    
+        ChiyogamiLogger.info("Lock request : " + from.getWorldData().getName() + " -> " + to.getWorldData().getName());
+        
+        Future<?> worldServerFuture = null;
+        
+        WAIT_REQUEST_LOCK.lock();
+        try{
+            if(!waitWorldServerMap.containsKey(from)){
+                
+                WorldServer lowest = getWaitWorldServer(to);
+                
+                if(lowest != from) {
+                    WorldServer highest = getWaitedWorldServer(to);
+                    waitWorldServerMap.put(from, highest);
+                    waitedWorldServerMap.put(highest, from);
+    
+                    ChiyogamiLogger.info("Wait thread : " + from.getWorldData().getName() + " -> " + highest.getWorldData().getName());
+                    worldServerFuture = worldThreadFutureMap.get(highest);
+                }
+            }else{
+                WorldServer fromHighest = getWaitedWorldServer(from);
+                WorldServer highest = getWaitedWorldServer(to);
+                WorldServer lowest = getWaitWorldServer(to);
+    
+                if(highest != fromHighest) {
+                    WorldServer low = waitWorldServerMap.get(from);
+                    waitWorldServerMap.put(lowest, low);
+                    waitedWorldServerMap.put(low, lowest);
+                    
+                    waitWorldServerMap.put(from, highest);
+                    waitedWorldServerMap.put(highest, from);
+    
+                    ChiyogamiLogger.info("Wait thread : " + from.getWorldData().getName() + " -> " + highest.getWorldData().getName());
+                    worldServerFuture = worldThreadFutureMap.get(highest);
+                }
+            }
+        } finally {
+            WAIT_REQUEST_LOCK.unlock();
+        }
+        
+        if(worldServerFuture != null){
+            try {
+                worldServerFuture.get();
+            } catch (Exception e){e.printStackTrace();}
+        }
+    }
+    
+    
+    public static WorldServer getWaitWorldServer(WorldServer from){
+        WorldServer worldServer = waitWorldServerMap.get(from);
+        if(worldServer == null) return from;
+        else return getWaitWorldServer(worldServer);
+    }
+    
+    public static WorldServer getWaitedWorldServer(WorldServer from){
+        WorldServer worldServer = waitedWorldServerMap.get(from);
+        if(worldServer == null) return from;
+        else return getWaitedWorldServer(worldServer);
+    }
+    
+    public static void shutdown(){
+        executorService.shutdown();
+    }
+    
+    public static void doTick(){
+        int pool = maxPoolSize > 0 ? maxPoolSize : worldServers.size();
+        
+        if(pool != previousPoolSize){
+            if(executorService != null) executorService.shutdown();
+            executorService = Executors.newFixedThreadPool(pool);
+            previousPoolSize = pool;
+        }
+        
+        WAIT_REQUEST_LOCK.lock();
+        try {
+            for (WorldServer worldServer : worldServers) {
+                Future<?> future = executorService.submit(tickRunnableMap.get(worldServer));
+                worldThreadFutureMap.put(worldServer, future);
+            }
+        } finally {
+            WAIT_REQUEST_LOCK.unlock();
+        }
+        
+        for(Future<?> future : worldThreadFutureMap.values()){
+            try {
+                future.get();
+            } catch (Exception e){e.printStackTrace();}
+        }
+        
+        waitWorldServerMap.clear();
+        worldThreadFutureMap.clear();
+        waitedWorldServerMap.clear();
+        worldServers.clear();
+    }
+}
