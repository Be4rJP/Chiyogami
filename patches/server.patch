diff --strip-trailing-cr -urN Original/Tuinity-Server/src/main/java/co/aikar/timings/WorldTimingsHandler.java Chiyogami/Chiyogami-Server/src/main/java/co/aikar/timings/WorldTimingsHandler.java
--- Original/Tuinity-Server/src/main/java/co/aikar/timings/WorldTimingsHandler.java	2021-09-26 18:20:13.862173700 +0900
+++ Chiyogami/Chiyogami-Server/src/main/java/co/aikar/timings/WorldTimingsHandler.java	2022-01-02 18:53:11.486479400 +0900
@@ -73,71 +73,71 @@
     public WorldTimingsHandler(World server) {
         String name = ((WorldDataServer) server.getWorldData()).getName() + " - ";
 
-        mobSpawn = Timings.ofSafe(name + "mobSpawn");
-        doChunkUnload = Timings.ofSafe(name + "doChunkUnload");
-        scheduledBlocks = Timings.ofSafe(name + "Scheduled Blocks");
-        scheduledBlocksCleanup = Timings.ofSafe(name + "Scheduled Blocks - Cleanup");
-        scheduledBlocksTicking = Timings.ofSafe(name + "Scheduled Blocks - Ticking");
-        chunkTicks = Timings.ofSafe(name + "Chunk Ticks");
-        lightChunk = Timings.ofSafe(name + "Light Chunk");
-        chunkTicksBlocks = Timings.ofSafe(name + "Chunk Ticks - Blocks");
-        doVillages = Timings.ofSafe(name + "doVillages");
-        doChunkMap = Timings.ofSafe(name + "doChunkMap");
-        doChunkMapUpdate = Timings.ofSafe(name + "doChunkMap - Update");
-        doChunkMapToUpdate = Timings.ofSafe(name + "doChunkMap - To Update");
-        doChunkMapSortMissing = Timings.ofSafe(name + "doChunkMap - Sort Missing");
-        doChunkMapSortSendToPlayers = Timings.ofSafe(name + "doChunkMap - Sort Send To Players");
-        doChunkMapPlayersNeedingChunks = Timings.ofSafe(name + "doChunkMap - Players Needing Chunks");
-        doChunkMapPendingSendToPlayers = Timings.ofSafe(name + "doChunkMap - Pending Send To Players");
-        doChunkMapUnloadChunks = Timings.ofSafe(name + "doChunkMap - Unload Chunks");
-        doSounds = Timings.ofSafe(name + "doSounds");
-        doChunkGC = Timings.ofSafe(name + "doChunkGC");
-        doPortalForcer = Timings.ofSafe(name + "doPortalForcer");
-        entityTick = Timings.ofSafe(name + "entityTick");
-        entityRemoval = Timings.ofSafe(name + "entityRemoval");
-        tileEntityTick = Timings.ofSafe(name + "tileEntityTick");
-        tileEntityPending = Timings.ofSafe(name + "tileEntityPending");
-
-        chunkLoad = Timings.ofSafe(name + "Chunk Load");
-        chunkLoadPopulate = Timings.ofSafe(name + "Chunk Load - Populate");
-        syncChunkLoad = Timings.ofSafe(name + "Sync Chunk Load");
-        chunkLoadLevelTimer = Timings.ofSafe(name + "Chunk Load - Load Level");
-        chunkIO = Timings.ofSafe(name + "Chunk Load - DiskIO");
-        chunkPostLoad = Timings.ofSafe(name + "Chunk Load - Post Load");
-        worldSave = Timings.ofSafe(name + "World Save");
-        worldSaveLevel = Timings.ofSafe(name + "World Save - Level");
-        worldSaveChunks = Timings.ofSafe(name + "World Save - Chunks");
-        chunkSaveData = Timings.ofSafe(name + "Chunk Save - Data");
-
-        tracker1 = Timings.ofSafe(name + "tracker stage 1");
-        tracker2 = Timings.ofSafe(name + "tracker stage 2");
-        doTick = Timings.ofSafe(name + "doTick");
-        tickEntities = Timings.ofSafe(name + "tickEntities");
-
-        chunks = Timings.ofSafe(name + "Chunks");
-        newEntities = Timings.ofSafe(name + "New entity registration");
-        raids = Timings.ofSafe(name + "Raids");
-        chunkProviderTick = Timings.ofSafe(name + "Chunk provider tick");
-        broadcastChunkUpdates = Timings.ofSafe(name + "Broadcast chunk updates");
-        countNaturalMobs = Timings.ofSafe(name + "Count natural mobs");
-
-
-        miscMobSpawning = Timings.ofSafe(name + "Mob spawning - Misc");
-        playerMobDistanceMapUpdate = Timings.ofSafe(name + "Per Player Mob Spawning - Distance Map Update");
-
-        poiUnload = Timings.ofSafe(name + "Chunk unload - POI");
-        chunkUnload = Timings.ofSafe(name + "Chunk unload - Chunk");
-        poiSaveDataSerialization = Timings.ofSafe(name + "Chunk save - POI Data serialization");
-        chunkSave = Timings.ofSafe(name + "Chunk save - Chunk");
-        chunkSaveOverwriteCheck = Timings.ofSafe(name + "Chunk save - Chunk Overwrite Check");
-        chunkSaveDataSerialization = Timings.ofSafe(name + "Chunk save - Chunk Data serialization");
-        chunkSaveIOWait = Timings.ofSafe(name + "Chunk save - Chunk IO Wait");
-        chunkUnloadPrepareSave = Timings.ofSafe(name + "Chunk unload - Async Save Prepare");
-        chunkUnloadPOISerialization = Timings.ofSafe(name + "Chunk unload - POI Data Serialization");
-        chunkUnloadDataSave = Timings.ofSafe(name + "Chunk unload - Data Serialization");
+        mobSpawn = Timings.ofSafeW(name + "mobSpawn");
+        doChunkUnload = Timings.ofSafeW(name + "doChunkUnload");
+        scheduledBlocks = Timings.ofSafeW(name + "Scheduled Blocks");
+        scheduledBlocksCleanup = Timings.ofSafeW(name + "Scheduled Blocks - Cleanup");
+        scheduledBlocksTicking = Timings.ofSafeW(name + "Scheduled Blocks - Ticking");
+        chunkTicks = Timings.ofSafeW(name + "Chunk Ticks");
+        lightChunk = Timings.ofSafeW(name + "Light Chunk");
+        chunkTicksBlocks = Timings.ofSafeW(name + "Chunk Ticks - Blocks");
+        doVillages = Timings.ofSafeW(name + "doVillages");
+        doChunkMap = Timings.ofSafeW(name + "doChunkMap");
+        doChunkMapUpdate = Timings.ofSafeW(name + "doChunkMap - Update");
+        doChunkMapToUpdate = Timings.ofSafeW(name + "doChunkMap - To Update");
+        doChunkMapSortMissing = Timings.ofSafeW(name + "doChunkMap - Sort Missing");
+        doChunkMapSortSendToPlayers = Timings.ofSafeW(name + "doChunkMap - Sort Send To Players");
+        doChunkMapPlayersNeedingChunks = Timings.ofSafeW(name + "doChunkMap - Players Needing Chunks");
+        doChunkMapPendingSendToPlayers = Timings.ofSafeW(name + "doChunkMap - Pending Send To Players");
+        doChunkMapUnloadChunks = Timings.ofSafeW(name + "doChunkMap - Unload Chunks");
+        doSounds = Timings.ofSafeW(name + "doSounds");
+        doChunkGC = Timings.ofSafeW(name + "doChunkGC");
+        doPortalForcer = Timings.ofSafeW(name + "doPortalForcer");
+        entityTick = Timings.ofSafeW(name + "entityTick");
+        entityRemoval = Timings.ofSafeW(name + "entityRemoval");
+        tileEntityTick = Timings.ofSafeW(name + "tileEntityTick");
+        tileEntityPending = Timings.ofSafeW(name + "tileEntityPending");
+
+        chunkLoad = Timings.ofSafeW(name + "Chunk Load");
+        chunkLoadPopulate = Timings.ofSafeW(name + "Chunk Load - Populate");
+        syncChunkLoad = Timings.ofSafeW(name + "Sync Chunk Load");
+        chunkLoadLevelTimer = Timings.ofSafeW(name + "Chunk Load - Load Level");
+        chunkIO = Timings.ofSafeW(name + "Chunk Load - DiskIO");
+        chunkPostLoad = Timings.ofSafeW(name + "Chunk Load - Post Load");
+        worldSave = Timings.ofSafeW(name + "World Save");
+        worldSaveLevel = Timings.ofSafeW(name + "World Save - Level");
+        worldSaveChunks = Timings.ofSafeW(name + "World Save - Chunks");
+        chunkSaveData = Timings.ofSafeW(name + "Chunk Save - Data");
+
+        tracker1 = Timings.ofSafeW(name + "tracker stage 1");
+        tracker2 = Timings.ofSafeW(name + "tracker stage 2");
+        doTick = Timings.ofSafeW(name + "doTick");
+        tickEntities = Timings.ofSafeW(name + "tickEntities");
+
+        chunks = Timings.ofSafeW(name + "Chunks");
+        newEntities = Timings.ofSafeW(name + "New entity registration");
+        raids = Timings.ofSafeW(name + "Raids");
+        chunkProviderTick = Timings.ofSafeW(name + "Chunk provider tick");
+        broadcastChunkUpdates = Timings.ofSafeW(name + "Broadcast chunk updates");
+        countNaturalMobs = Timings.ofSafeW(name + "Count natural mobs");
+
+
+        miscMobSpawning = Timings.ofSafeW(name + "Mob spawning - Misc");
+        playerMobDistanceMapUpdate = Timings.ofSafeW(name + "Per Player Mob Spawning - Distance Map Update");
+
+        poiUnload = Timings.ofSafeW(name + "Chunk unload - POI");
+        chunkUnload = Timings.ofSafeW(name + "Chunk unload - Chunk");
+        poiSaveDataSerialization = Timings.ofSafeW(name + "Chunk save - POI Data serialization");
+        chunkSave = Timings.ofSafeW(name + "Chunk save - Chunk");
+        chunkSaveOverwriteCheck = Timings.ofSafeW(name + "Chunk save - Chunk Overwrite Check");
+        chunkSaveDataSerialization = Timings.ofSafeW(name + "Chunk save - Chunk Data serialization");
+        chunkSaveIOWait = Timings.ofSafeW(name + "Chunk save - Chunk IO Wait");
+        chunkUnloadPrepareSave = Timings.ofSafeW(name + "Chunk unload - Async Save Prepare");
+        chunkUnloadPOISerialization = Timings.ofSafeW(name + "Chunk unload - POI Data Serialization");
+        chunkUnloadDataSave = Timings.ofSafeW(name + "Chunk unload - Data Serialization");
     }
 
     public static Timing getTickList(WorldServer worldserver, String timingsType) {
-        return Timings.ofSafe(((WorldDataServer) worldserver.getWorldData()).getName() + " - Scheduled " + timingsType);
+        return Timings.ofSafeW(((WorldDataServer) worldserver.getWorldData()).getName() + " - Scheduled " + timingsType);
     }
 }
diff --strip-trailing-cr -urN Original/Tuinity-Server/src/main/java/com/tuinity/tuinity/util/CachedLists.java Chiyogami/Chiyogami-Server/src/main/java/com/tuinity/tuinity/util/CachedLists.java
--- Original/Tuinity-Server/src/main/java/com/tuinity/tuinity/util/CachedLists.java	2021-09-26 18:20:17.583383300 +0900
+++ Chiyogami/Chiyogami-Server/src/main/java/com/tuinity/tuinity/util/CachedLists.java	2022-01-02 18:53:11.487478900 +0900
@@ -1,74 +1,251 @@
 package com.tuinity.tuinity.util;
 
+import net.minecraft.server.MinecraftServer;
 import net.minecraft.world.phys.AxisAlignedBB;
 import net.minecraft.world.level.chunk.Chunk;
 import net.minecraft.world.entity.Entity;
 import org.bukkit.Bukkit;
+import org.bukkit.World;
 import org.bukkit.craftbukkit.util.UnsafeList;
+import world.chiyogami.chiyogamilib.WorldThreads;
+
 import java.util.List;
+import java.util.Set;
+import java.util.concurrent.ConcurrentHashMap;
 
 public class CachedLists {
-
-    static final UnsafeList<AxisAlignedBB> TEMP_COLLISION_LIST = new UnsafeList<>(1024);
-    static boolean tempCollisionListInUse;
-
-    public static UnsafeList<AxisAlignedBB> getTempCollisionList() {
-        if (!Bukkit.isPrimaryThread() || tempCollisionListInUse) {
+    
+    private final World world;
+    
+    private final UnsafeList<AxisAlignedBB> TEMP_COLLISION_LIST = new UnsafeList<>(1024);
+    private boolean tempCollisionListInUse;
+    
+    private final UnsafeList<Entity> TEMP_GET_ENTITIES_LIST = new UnsafeList<>(1024);
+    private boolean tempGetEntitiesListInUse;
+    
+    private final UnsafeList<Chunk> TEMP_GET_CHUNKS_LIST = new UnsafeList<>(1024);
+    private boolean tempGetChunksListInUse;
+    
+    private CachedLists(World world){
+        this.world = world;
+    }
+    
+    
+    
+    // Paper start - optimise collisions
+    static final Set<CachedLists> cashedListSet = ConcurrentHashMap.newKeySet();
+    
+    public static List<AxisAlignedBB> getTempCollisionList(World world) {
+        
+        for(CachedLists cachedLists : cashedListSet){
+            if(world == cachedLists.world){
+                if (!Bukkit.isPrimaryThread() || cachedLists.tempCollisionListInUse) {
+                    return new UnsafeList<>(16);
+                }
+                
+                cachedLists.tempCollisionListInUse = true;
+                return cachedLists.TEMP_COLLISION_LIST;
+            }
+        }
+        
+        CachedLists cachedLists = new CachedLists(world);
+        cachedLists.tempCollisionListInUse = true;
+        cashedListSet.add(cachedLists);
+        return cachedLists.TEMP_COLLISION_LIST;
+    }
+    
+    
+    public static List<AxisAlignedBB> getTempCollisionList() {
+        
+        for(CachedLists cachedLists : cashedListSet){
+            World world = cachedLists.world;
+            Thread thread = WorldThreads.worldThreadMap.get(world);
+            
+            if(Thread.currentThread() == thread && !cachedLists.tempCollisionListInUse){
+                cachedLists.tempCollisionListInUse = true;
+                return cachedLists.TEMP_COLLISION_LIST;
+            }
+        }
+        
+        if (!Bukkit.isPrimaryThread()) {
             return new UnsafeList<>(16);
         }
-        tempCollisionListInUse = true;
-        return TEMP_COLLISION_LIST;
+        
+        UnsafeList<AxisAlignedBB> allList = new UnsafeList<>(1024);
+        for(CachedLists cachedLists : cashedListSet){
+            allList.addAll(cachedLists.TEMP_COLLISION_LIST);
+        }
+        return allList;
+    }
+    
+    public static void returnTempCollisionList(List<AxisAlignedBB> list, World world) {
+        for(CachedLists cachedLists : cashedListSet){
+            if(world == cachedLists.world){
+                if (cachedLists.TEMP_COLLISION_LIST != list) {
+                    return;
+                }
+                
+                cachedLists.TEMP_COLLISION_LIST.setSize(0);
+                cachedLists.tempCollisionListInUse = false;
+                return;
+            }
+        }
     }
-
+    
     public static void returnTempCollisionList(List<AxisAlignedBB> list) {
-        if (list != TEMP_COLLISION_LIST) {
-            return;
-        }
-        ((UnsafeList)list).setSize(0);
-        tempCollisionListInUse = false;
+        for(CachedLists cachedLists : cashedListSet){
+            if(cachedLists.TEMP_COLLISION_LIST == list){
+                cachedLists.TEMP_COLLISION_LIST.setSize(0);
+                cachedLists.tempCollisionListInUse = false;
+                return;
+            }
+        }
+        
+        ((UnsafeList<?>)list).setSize(0);
+    }
+    
+    
+    public static UnsafeList<Entity> getTempGetEntitiesList(World world) {
+        for(CachedLists cachedLists : cashedListSet){
+            if(world == cachedLists.world){
+                if (!Bukkit.isPrimaryThread() || cachedLists.tempGetEntitiesListInUse) {
+                    return new UnsafeList<>(16);
+                }
+                
+                cachedLists.tempGetEntitiesListInUse = true;
+                return cachedLists.TEMP_GET_ENTITIES_LIST;
+            }
+        }
+        
+        CachedLists cachedLists = new CachedLists(world);
+        cachedLists.tempGetEntitiesListInUse = true;
+        cashedListSet.add(cachedLists);
+        return cachedLists.TEMP_GET_ENTITIES_LIST;
     }
-
-    static final UnsafeList<Entity> TEMP_GET_ENTITIES_LIST = new UnsafeList<>(1024);
-    static boolean tempGetEntitiesListInUse;
-
+    
     public static UnsafeList<Entity> getTempGetEntitiesList() {
-        if (!Bukkit.isPrimaryThread() || tempGetEntitiesListInUse) {
+        for(CachedLists cachedLists : cashedListSet){
+            World world = cachedLists.world;
+            Thread thread = WorldThreads.worldThreadMap.get(world);
+            
+            if(Thread.currentThread() == thread && !cachedLists.tempGetEntitiesListInUse){
+                cachedLists.tempGetEntitiesListInUse = true;
+                return cachedLists.TEMP_GET_ENTITIES_LIST;
+            }
+        }
+        
+        if (!Bukkit.isPrimaryThread()) {
             return new UnsafeList<>(16);
         }
-        tempGetEntitiesListInUse = true;
-        return TEMP_GET_ENTITIES_LIST;
+        
+        UnsafeList<Entity> allList = new UnsafeList<>(1024);
+        for(CachedLists cachedLists : cashedListSet){
+            allList.addAll(cachedLists.TEMP_GET_ENTITIES_LIST);
+        }
+        return allList;
+    }
+    
+    public static void returnTempGetEntitiesList(List<Entity> list, World world) {
+        for(CachedLists cachedLists : cashedListSet){
+            if(world == cachedLists.world){
+                if (cachedLists.TEMP_GET_ENTITIES_LIST != list) {
+                    return;
+                }
+                
+                cachedLists.TEMP_GET_ENTITIES_LIST.setSize(0);
+                cachedLists.tempGetEntitiesListInUse = false;
+                return;
+            }
+        }
     }
-
+    
     public static void returnTempGetEntitiesList(List<Entity> list) {
-        if (list != TEMP_GET_ENTITIES_LIST) {
-            return;
-        }
-        ((UnsafeList)list).setSize(0);
-        tempGetEntitiesListInUse = false;
+        for(CachedLists cachedLists : cashedListSet){
+            if(cachedLists.TEMP_GET_ENTITIES_LIST == list){
+                cachedLists.TEMP_GET_ENTITIES_LIST.setSize(0);
+                cachedLists.tempGetEntitiesListInUse = false;
+                return;
+            }
+        }
+        
+        ((UnsafeList<?>)list).setSize(0);
+    }
+    
+    
+    public static UnsafeList<Chunk> getTempGetChunksList(World world) {
+        
+        for(CachedLists cachedLists : cashedListSet){
+            if(world == cachedLists.world){
+                if (!Bukkit.isPrimaryThread() || cachedLists.tempGetChunksListInUse) {
+                    return new UnsafeList<>(16);
+                }
+                
+                cachedLists.tempGetChunksListInUse = true;
+                return cachedLists.TEMP_GET_CHUNKS_LIST;
+            }
+        }
+        
+        CachedLists cachedLists = new CachedLists(world);
+        cachedLists.tempGetChunksListInUse = true;
+        cashedListSet.add(cachedLists);
+        return cachedLists.TEMP_GET_CHUNKS_LIST;
     }
-
-    static final UnsafeList<Chunk> TEMP_GET_CHUNKS_LIST = new UnsafeList<>(1024);
-    static boolean tempGetChunksListInUse;
-
+    
+    
     public static UnsafeList<Chunk> getTempGetChunksList() {
-        if (!Bukkit.isPrimaryThread() || tempGetChunksListInUse) {
-            return new UnsafeList<>();
+        
+        for(CachedLists cachedLists : cashedListSet){
+            World world = cachedLists.world;
+            Thread thread = WorldThreads.worldThreadMap.get(world);
+            
+            if(Thread.currentThread() == thread && !cachedLists.tempGetChunksListInUse){
+                cachedLists.tempGetChunksListInUse = true;
+                return cachedLists.TEMP_GET_CHUNKS_LIST;
+            }
+        }
+        
+        if (!Bukkit.isPrimaryThread()) {
+            return new UnsafeList<>(16);
+        }
+        
+        UnsafeList<Chunk> allList = new UnsafeList<>(1024);
+        for(CachedLists cachedLists : cashedListSet){
+            allList.addAll(cachedLists.TEMP_GET_CHUNKS_LIST);
+        }
+        return allList;
+    }
+    
+    public static void returnTempGetChunksList(List<Chunk> list, World world) {
+        for(CachedLists cachedLists : cashedListSet){
+            if(world == cachedLists.world){
+                if (cachedLists.TEMP_GET_CHUNKS_LIST != list) {
+                    return;
+                }
+                
+                cachedLists.TEMP_GET_CHUNKS_LIST.setSize(0);
+                cachedLists.tempGetChunksListInUse = false;
+                return;
+            }
         }
-        tempGetChunksListInUse = true;
-        return TEMP_GET_CHUNKS_LIST;
     }
-
+    
     public static void returnTempGetChunksList(List<Chunk> list) {
-        if (list != TEMP_GET_CHUNKS_LIST) {
-            return;
+        for(CachedLists cachedLists : cashedListSet){
+            if(cachedLists.TEMP_GET_CHUNKS_LIST == list){
+                cachedLists.TEMP_GET_CHUNKS_LIST.setSize(0);
+                cachedLists.tempGetChunksListInUse = false;
+                return;
+            }
         }
-        ((UnsafeList)list).setSize(0);
-        tempGetChunksListInUse = false;
+        
+        ((UnsafeList<?>)list).setSize(0);
     }
 
     public static void reset() {
-        TEMP_COLLISION_LIST.completeReset();
-        TEMP_GET_ENTITIES_LIST.completeReset();
-        TEMP_GET_CHUNKS_LIST.completeReset();
+        for(CachedLists cachedLists : cashedListSet){
+            cachedLists.TEMP_COLLISION_LIST.completeReset();
+            cachedLists.TEMP_GET_ENTITIES_LIST.completeReset();
+            cachedLists.TEMP_GET_CHUNKS_LIST.completeReset();
+        }
     }
 }
diff --strip-trailing-cr -urN Original/Tuinity-Server/src/main/java/net/minecraft/server/dedicated/DedicatedServer.java Chiyogami/Chiyogami-Server/src/main/java/net/minecraft/server/dedicated/DedicatedServer.java
--- Original/Tuinity-Server/src/main/java/net/minecraft/server/dedicated/DedicatedServer.java	2021-09-26 18:20:18.110781400 +0900
+++ Chiyogami/Chiyogami-Server/src/main/java/net/minecraft/server/dedicated/DedicatedServer.java	2022-01-02 18:53:11.630397600 +0900
@@ -1,19 +1,14 @@
 package net.minecraft.server.dedicated;
 
 import com.google.common.base.Strings;
-import com.google.common.collect.Lists;
 import com.mojang.authlib.GameProfile;
 import com.mojang.authlib.GameProfileRepository;
 import com.mojang.authlib.minecraft.MinecraftSessionService;
 import com.mojang.datafixers.DataFixer;
-import java.io.BufferedReader;
+
 import java.io.IOException;
-import java.io.InputStreamReader;
 import java.net.InetAddress;
 import java.net.Proxy;
-import java.nio.charset.StandardCharsets;
-import java.util.Collections;
-import java.util.List;
 import java.util.Locale;
 import java.util.Optional;
 import java.util.function.BooleanSupplier;
@@ -69,6 +64,7 @@
 import org.bukkit.event.server.ServerCommandEvent;
 import org.bukkit.craftbukkit.util.Waitable;
 import org.bukkit.event.server.RemoteServerCommandEvent;
+import world.chiyogami.config.ChiyogamiConfig;
 // CraftBukkit end
 
 public class DedicatedServer extends MinecraftServer implements IMinecraftServer {
@@ -216,6 +212,7 @@
         io.papermc.paper.brigadier.PaperBrigadierProviderImpl.INSTANCE.getClass(); // init PaperBrigadierProvider
         // Paper end
         com.tuinity.tuinity.config.TuinityConfig.init((java.io.File) options.valueOf("tuinity-settings")); // Tuinity - Server Config
+        ChiyogamiConfig.load();
 
         this.setPVP(dedicatedserverproperties.pvp);
         this.setAllowFlight(dedicatedserverproperties.allowFlight);
diff --strip-trailing-cr -urN Original/Tuinity-Server/src/main/java/net/minecraft/server/level/ChunkProviderServer.java Chiyogami/Chiyogami-Server/src/main/java/net/minecraft/server/level/ChunkProviderServer.java
--- Original/Tuinity-Server/src/main/java/net/minecraft/server/level/ChunkProviderServer.java	2021-09-26 18:20:19.173809700 +0900
+++ Chiyogami/Chiyogami-Server/src/main/java/net/minecraft/server/level/ChunkProviderServer.java	2022-01-02 18:53:11.491476700 +0900
@@ -51,6 +51,7 @@
 import it.unimi.dsi.fastutil.objects.Object2BooleanLinkedOpenHashMap;
 import it.unimi.dsi.fastutil.objects.ObjectBidirectionalIterator;
 import it.unimi.dsi.fastutil.objects.Object2BooleanMap;
+import org.spigotmc.AsyncCatcher;
 // Tuinity end
 
 public class ChunkProviderServer extends IChunkProvider {
@@ -146,7 +147,7 @@
     long chunkFutureAwaitCounter; // Tuinity - private -> package private
 
     public void getEntityTickingChunkAsync(int x, int z, java.util.function.Consumer<Chunk> onLoad) {
-        if (Thread.currentThread() != this.serverThread) {
+        if (AsyncCatcher.isAsync()) {
             this.serverThreadQueue.execute(() -> {
                 ChunkProviderServer.this.getEntityTickingChunkAsync(x, z, onLoad);
             });
@@ -156,7 +157,7 @@
     }
 
     public void getTickingChunkAsync(int x, int z, java.util.function.Consumer<Chunk> onLoad) {
-        if (Thread.currentThread() != this.serverThread) {
+        if (AsyncCatcher.isAsync()) {
             this.serverThreadQueue.execute(() -> {
                 ChunkProviderServer.this.getTickingChunkAsync(x, z, onLoad);
             });
@@ -166,7 +167,7 @@
     }
 
     public void getFullChunkAsync(int x, int z, java.util.function.Consumer<Chunk> onLoad) {
-        if (Thread.currentThread() != this.serverThread) {
+        if (AsyncCatcher.isAsync()) {
             this.serverThreadQueue.execute(() -> {
                 ChunkProviderServer.this.getFullChunkAsync(x, z, onLoad);
             });
@@ -176,7 +177,7 @@
     }
 
     private void getChunkFutureAsynchronously(int x, int z, int ticketLevel, Function<PlayerChunk, CompletableFuture<Either<Chunk, PlayerChunk.Failure>>> futureGet, java.util.function.Consumer<Chunk> onLoad) {
-        if (Thread.currentThread() != this.serverThread) {
+        if (AsyncCatcher.isAsync()) {
             throw new IllegalStateException();
         }
         ChunkCoordIntPair chunkPos = new ChunkCoordIntPair(x, z);
@@ -275,7 +276,7 @@
     void getChunkAtAsynchronously(int chunkX, int chunkZ, int ticketLevel,
                                   java.util.function.Function<PlayerChunk, CompletableFuture<Either<IChunkAccess, PlayerChunk.Failure>>> function,
                                   java.util.function.Consumer<IChunkAccess> consumer) {
-        if (Thread.currentThread() != this.serverThread) {
+        if (AsyncCatcher.isAsync()) {
             throw new IllegalStateException();
         }
         ChunkCoordIntPair chunkPos = new ChunkCoordIntPair(chunkX, chunkZ);
@@ -471,7 +472,7 @@
     public Chunk getChunkAtIfLoadedImmediately(int x, int z) {
         long k = ChunkCoordIntPair.pair(x, z);
 
-        if (Thread.currentThread() == this.serverThread) {
+        if (!AsyncCatcher.isAsync()) {
             return this.getChunkAtIfLoadedMainThread(x, z);
         }
 
@@ -511,7 +512,7 @@
     private long asyncLoadSeqCounter;
 
     public CompletableFuture<Either<IChunkAccess, PlayerChunk.Failure>> getChunkAtAsynchronously(int x, int z, boolean gen, boolean isUrgent) {
-        if (Thread.currentThread() != this.serverThread) {
+        if (AsyncCatcher.isAsync()) {
             CompletableFuture<Either<IChunkAccess, PlayerChunk.Failure>> future = new CompletableFuture<Either<IChunkAccess, PlayerChunk.Failure>>();
             this.serverThreadQueue.execute(() -> {
                 this.getChunkAtAsynchronously(x, z, gen, isUrgent).whenComplete((chunk, ex) -> {
@@ -659,7 +660,7 @@
     @Override
     public IChunkAccess getChunkAt(int i, int j, ChunkStatus chunkstatus, boolean flag) {
         final int x = i; final int z = j; // Paper - conflict on variable change
-        if (Thread.currentThread() != this.serverThread) {
+        if (AsyncCatcher.isAsync()) {
             return (IChunkAccess) CompletableFuture.supplyAsync(() -> {
                 return this.getChunkAt(i, j, chunkstatus, flag);
             }, this.serverThreadQueue).join();
@@ -721,7 +722,7 @@
     @Nullable
     @Override
     public Chunk a(int i, int j) {
-        if (Thread.currentThread() != this.serverThread) {
+        if (AsyncCatcher.isAsync()) {
             return null;
         } else {
             return this.getChunkAtIfLoadedMainThread(i, j); // Paper - optimise for loaded chunks
diff --strip-trailing-cr -urN Original/Tuinity-Server/src/main/java/net/minecraft/server/level/PlayerChunkMap.java Chiyogami/Chiyogami-Server/src/main/java/net/minecraft/server/level/PlayerChunkMap.java
--- Original/Tuinity-Server/src/main/java/net/minecraft/server/level/PlayerChunkMap.java	2021-09-26 18:20:19.633545400 +0900
+++ Chiyogami/Chiyogami-Server/src/main/java/net/minecraft/server/level/PlayerChunkMap.java	2022-01-02 18:53:11.585422600 +0900
@@ -34,11 +34,8 @@
 import java.util.Optional;
 import java.util.Queue;
 import java.util.Set;
-import java.util.concurrent.CancellationException;
+import java.util.concurrent.*;
 import java.util.UUID; // Paper
-import java.util.concurrent.CompletableFuture;
-import java.util.concurrent.CompletionException;
-import java.util.concurrent.Executor;
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.function.BooleanSupplier;
 import java.util.function.Consumer;
@@ -757,7 +754,7 @@
     @Nullable
     public PlayerChunk getVisibleChunk(long i) { // Paper - protected -> public
         // Tuinity start - Don't copy
-        if (Thread.currentThread() == this.world.serverThread) {
+        if (!AsyncCatcher.isAsync()) {
             return this.updatingChunks.getVisible(i);
         }
         return this.updatingChunks.getVisibleAsync(i);
diff --strip-trailing-cr -urN Original/Tuinity-Server/src/main/java/net/minecraft/server/level/WorldServer.java Chiyogami/Chiyogami-Server/src/main/java/net/minecraft/server/level/WorldServer.java
--- Original/Tuinity-Server/src/main/java/net/minecraft/server/level/WorldServer.java	2021-09-26 18:20:19.389684800 +0900
+++ Chiyogami/Chiyogami-Server/src/main/java/net/minecraft/server/level/WorldServer.java	2022-01-02 18:53:11.587422100 +0900
@@ -24,16 +24,10 @@
 import java.io.Writer;
 import java.nio.file.Files;
 import java.nio.file.Path;
-import java.util.Collection;
-import java.util.Comparator;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Map;
-import java.util.Objects;
-import java.util.Optional;
-import java.util.Queue;
-import java.util.Set;
-import java.util.UUID;
+import java.util.*;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ConcurrentLinkedDeque;
+import java.util.concurrent.CopyOnWriteArrayList;
 import java.util.concurrent.Executor;
 import java.util.function.BooleanSupplier;
 import java.util.function.Function;
@@ -169,6 +163,7 @@
 import org.bukkit.event.world.TimeSkipEvent;
 // CraftBukkit end
 import it.unimi.dsi.fastutil.ints.IntArrayList; // Tuinity
+import org.spigotmc.AsyncCatcher;
 
 public class WorldServer extends World implements GeneratorAccessSeed {
 
@@ -352,7 +347,7 @@
 
     public final void loadChunksForMoveAsync(AxisAlignedBB axisalignedbb, double toX, double toZ,
                                              java.util.function.Consumer<List<IChunkAccess>> onLoad) {
-        if (Thread.currentThread() != this.serverThread) {
+        if (AsyncCatcher.isAsync()) {
             this.getChunkProvider().serverThreadQueue.execute(() -> {
                 this.loadChunksForMoveAsync(axisalignedbb, toX, toZ, onLoad);
             });
@@ -831,7 +826,7 @@
     @Override
     public TileEntity getTileEntity(BlockPosition pos, boolean validate) {
         TileEntity result = super.getTileEntity(pos, validate);
-        if (!validate || Thread.currentThread() != this.serverThread) {
+        if (!validate || AsyncCatcher.isAsync()) {
             // SPIGOT-5378: avoid deadlock, this can be called in loading logic (i.e lighting) but getType() will block on chunk load
             return result;
         }
@@ -1439,7 +1434,7 @@
             // Spigot end
             // Paper start- timings
             final boolean isActive = org.spigotmc.ActivationRange.checkIfActive(entity);
-            timer = isActive ? entity.getEntityType().tickTimer.startTiming() : entity.getEntityType().inactiveTickTimer.startTiming(); // Paper
+            timer = isActive ? entity.getEntityType().getTickTimer(this).startTiming() : entity.getEntityType().getInactiveTickTimer(this).startTiming(); // Paper
             try {
             // Paper end - timings
             entity.g(entity.locX(), entity.locY(), entity.locZ());
@@ -1489,7 +1484,7 @@
             if (entity1 instanceof EntityHuman || this.getChunkProvider().a(entity1)) {
                 // Paper - EAR 2
                 final boolean isActive = org.spigotmc.ActivationRange.checkIfActive(entity1);
-                co.aikar.timings.Timing timer = isActive ? entity1.getEntityType().passengerTickTimer.startTiming() : entity1.getEntityType().passengerInactiveTickTimer.startTiming(); // Paper
+                co.aikar.timings.Timing timer = isActive ? entity1.getEntityType().getPassengerTickTimer(this).startTiming() : entity1.getEntityType().getPassengerInactiveTickTimer(this).startTiming(); // Paper
                 try {
                 // Paper end
                 entity1.g(entity1.locX(), entity1.locY(), entity1.locZ());
diff --strip-trailing-cr -urN Original/Tuinity-Server/src/main/java/net/minecraft/server/MCUtil.java Chiyogami/Chiyogami-Server/src/main/java/net/minecraft/server/MCUtil.java
--- Original/Tuinity-Server/src/main/java/net/minecraft/server/MCUtil.java	2021-09-26 18:20:19.167813600 +0900
+++ Chiyogami/Chiyogami-Server/src/main/java/net/minecraft/server/MCUtil.java	2022-01-02 18:53:11.488478500 +0900
@@ -379,7 +379,7 @@
      * @return
      */
     public static void ensureMain(String reason, Runnable run) {
-        if (AsyncCatcher.enabled && Thread.currentThread() != MinecraftServer.getServer().serverThread) {
+        if (AsyncCatcher.enabled && AsyncCatcher.isAsync()) {
             if (reason != null) {
                 new IllegalStateException("Asynchronous " + reason + "!").printStackTrace();
             }
@@ -404,7 +404,7 @@
      * @return
      */
     public static <T> T ensureMain(String reason, Supplier<T> run) {
-        if (AsyncCatcher.enabled && Thread.currentThread() != MinecraftServer.getServer().serverThread) {
+        if (AsyncCatcher.enabled && AsyncCatcher.isAsync()) {
             if (reason != null) {
                 new IllegalStateException("Asynchronous " + reason + "! Blocking thread until it returns ").printStackTrace();
             }
diff --strip-trailing-cr -urN Original/Tuinity-Server/src/main/java/net/minecraft/server/MinecraftServer.java Chiyogami/Chiyogami-Server/src/main/java/net/minecraft/server/MinecraftServer.java
--- Original/Tuinity-Server/src/main/java/net/minecraft/server/MinecraftServer.java	2021-09-26 18:20:18.106784000 +0900
+++ Chiyogami/Chiyogami-Server/src/main/java/net/minecraft/server/MinecraftServer.java	2022-01-02 18:53:11.584422800 +0900
@@ -1,5 +1,6 @@
 package net.minecraft.server;
 
+import co.aikar.timings.TimingHandler;
 import com.google.common.base.Splitter;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.Lists;
@@ -48,6 +49,7 @@
 import java.util.Set;
 import java.util.UUID;
 import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.Executor;
 import java.util.concurrent.atomic.AtomicReference;
 import java.util.function.BooleanSupplier;
@@ -180,9 +182,15 @@
 // CraftBukkit end
 
 import co.aikar.timings.MinecraftTimings; // Paper
+import org.spigotmc.AsyncCatcher;
 import org.spigotmc.SlackActivityAccountant; // Spigot
 import io.papermc.paper.util.PaperJvmChecker; // Paper
 import io.papermc.paper.event.server.ServerResourcesReloadedEvent; // Paper
+import world.chiyogami.chiyogamilib.WorldThreads;
+import world.chiyogami.chiyogamilib.monitor.PerformanceMonitor;
+import world.chiyogami.chiyogamilib.monitor.WorkMode;
+import world.chiyogami.chiyogamilib.scheduler.WorldThreadRunnable;
+import world.chiyogami.thread.WorldThreadPool;
 
 public abstract class MinecraftServer extends IAsyncTaskHandlerReentrant<TickTask> implements IMojangStatistics, ICommandListener, AutoCloseable {
 
@@ -907,6 +915,10 @@
         if (this.getServerConnection() != null) {
             this.getServerConnection().b();
         }
+        try{
+            MinecraftServer.LOGGER.info("Stopping WorldThreadPool");
+            WorldThreadPool.shutdown();
+        }catch (Exception e){e.printStackTrace();}
 
         if (this.playerList != null) {
             MinecraftServer.LOGGER.info("Saving players");
@@ -1244,6 +1256,7 @@
 
     public final void executeMidTickTasks() {
         org.spigotmc.AsyncCatcher.catchOp("mid tick chunk task execution");
+        if(Thread.currentThread() != this.serverThread) return;
         long startTime = System.nanoTime();
         if ((startTime - lastMidTickExecute) <= CHUNK_TASK_QUEUE_BACKOFF_MIN_TIME || (startTime - lastMidTickExecuteFailure) <= TASK_EXECUTION_FAILURE_BACKOFF) {
             // it's shown to be bad to constantly hit the queue (chunk loads slow to a crawl), even if no tasks are executed.
@@ -1384,6 +1397,7 @@
     protected void exit() {}
 
     protected void a(BooleanSupplier booleansupplier) {
+        long fullServerTickNanoTime = System.nanoTime(); // Chiyogami
         co.aikar.timings.TimingsManager.FULL_SERVER_TICK.startTiming(); // Paper
         this.slackActivityAccountant.tickStarted(); // Spigot
         long i = SystemUtils.getMonotonicNanos();
@@ -1481,7 +1495,10 @@
         org.spigotmc.WatchdogThread.tick(); // Spigot
         this.slackActivityAccountant.tickEnded(l); // Spigot
         co.aikar.timings.TimingsManager.FULL_SERVER_TICK.stopTiming(); // Paper
+        PerformanceMonitor.setFullServerTickNanoTime(System.nanoTime() - fullServerTickNanoTime); // Chiyogami
     }
+    
+    private static BooleanSupplier staticBooleanSupplier = null;
 
     protected void b(BooleanSupplier booleansupplier) {
         // Tuinity - replace logic
@@ -1526,16 +1543,31 @@
         }
         // Paper end
         MinecraftTimings.timeUpdateTimer.stopTiming(); // Spigot // Paper
-
+    
+        staticBooleanSupplier = booleansupplier;
+        long worldServerTickNanoTime = System.nanoTime();
         while (iterator.hasNext()) {
             WorldServer worldserver = (WorldServer) iterator.next();
-            worldserver.hasPhysicsEvent =  org.bukkit.event.block.BlockPhysicsEvent.getHandlerList().getRegisteredListeners().length > 0; // Paper
-            worldserver.hasEntityMoveEvent =  EntityMoveEvent.getHandlerList().getRegisteredListeners().length > 0; // Paper
-            TileEntityHopper.skipHopperEvents = worldserver.paperConfig.disableHopperMoveEvents || org.bukkit.event.inventory.InventoryMoveItemEvent.getHandlerList().getRegisteredListeners().length == 0; // Paper
-
-            this.methodProfiler.a(() -> {
-                return worldserver + " " + worldserver.getDimensionKey().a();
-            });
+    
+            WorldThreadPool.worldServers.add(worldserver);
+    
+            WorldThreadPool.tickRunnableMap.computeIfAbsent(worldserver, k -> () -> {
+    
+                WorldThreads.worldThreadMap.put(worldserver.getWorld(), Thread.currentThread());
+                
+                TimingHandler.initializeWorldTiming();
+    
+                long worldServerThreadNanoTime = System.nanoTime();
+    
+                WorldThreadRunnable.worldThreadHeartBeat(worldserver.getWorld(), currentTick); // Chiyogami
+    
+                worldserver.hasPhysicsEvent = org.bukkit.event.block.BlockPhysicsEvent.getHandlerList().getRegisteredListeners().length > 0; // Paper
+                worldserver.hasEntityMoveEvent = EntityMoveEvent.getHandlerList().getRegisteredListeners().length > 0; // Paper
+                TileEntityHopper.skipHopperEvents = worldserver.paperConfig.disableHopperMoveEvents || org.bukkit.event.inventory.InventoryMoveItemEvent.getHandlerList().getRegisteredListeners().length == 0; // Paper
+    
+                this.methodProfiler.a(() -> {
+                    return worldserver + " " + worldserver.getDimensionKey().a();
+                });
             /* Drop global time updates
             if (this.ticks % 20 == 0) {
                 this.methodProfiler.enter("timeSync");
@@ -1543,39 +1575,49 @@
                 this.methodProfiler.exit();
             }
             // CraftBukkit end */
-
-            this.methodProfiler.enter("tick");
-
-            try {
-                // Tuinity - replace logic
-                worldserver.timings.doTick.startTiming(); // Spigot
-                worldserver.doTick(booleansupplier);
-                // Tuinity start
-                for (final com.tuinity.tuinity.chunk.SingleThreadChunkRegionManager regionManager : worldserver.getChunkProvider().playerChunkMap.regionManagers) {
-                    regionManager.recalculateRegions();
-                }
-                // Tuinity end
-                worldserver.timings.doTick.stopTiming(); // Spigot
-                // Tuinity - replace logic
-            } catch (Throwable throwable) {
-                // Spigot Start
-                CrashReport crashreport;
+    
+                this.methodProfiler.enter("tick");
+    
                 try {
-                    crashreport = CrashReport.a(throwable, "Exception ticking world");
-                } catch (Throwable t) {
-                    if (throwable instanceof ThreadDeath) { throw (ThreadDeath)throwable; } // Paper
-                    throw new RuntimeException("Error generating crash report", t);
+                    // Tuinity - replace logic
+                    ((TimingHandler.WorldTiming)worldserver.timings.doTick).startTiming(true); // Spigot
+                    worldserver.doTick(/*booleansupplier*/staticBooleanSupplier);
+                    // Tuinity start
+                    for (final com.tuinity.tuinity.chunk.SingleThreadChunkRegionManager regionManager : worldserver.getChunkProvider().playerChunkMap.regionManagers) {
+                        regionManager.recalculateRegions();
+                    }
+                    // Tuinity end
+                    worldserver.timings.doTick.stopTiming(); // Spigot
+                    // Tuinity - replace logic
+                } catch (Throwable throwable) {
+                    // Spigot Start
+                    CrashReport crashreport;
+                    try {
+                        crashreport = CrashReport.a(throwable, "Exception ticking world");
+                    } catch (Throwable t) {
+                        if (throwable instanceof ThreadDeath) {
+                            throw (ThreadDeath) throwable;
+                        } // Paper
+                        throw new RuntimeException("Error generating crash report", t);
+                    }
+                    // Spigot End
+        
+                    worldserver.a(crashreport);
+                    throw new ReportedException(crashreport);
                 }
-                // Spigot End
-
-                worldserver.a(crashreport);
-                throw new ReportedException(crashreport);
-            }
-
-            this.methodProfiler.exit();
-            this.methodProfiler.exit();
-            worldserver.explosionDensityCache.clear(); // Paper - Optimize explosions
+    
+                this.methodProfiler.exit();
+                this.methodProfiler.exit();
+                worldserver.explosionDensityCache.clear(); // Paper - Optimize explosions
+                PerformanceMonitor.getWorldTickNanoTimeMap().put(worldserver.getWorld(), System.nanoTime() - worldServerThreadNanoTime);
+            });
         }
+    
+        WorldThreadPool.doTick();
+        
+        WorldThreads.worldThreadMap.clear();
+        TimingHandler.clearWorldTimings();
+        PerformanceMonitor.setAllWorldTickNanoTime(System.nanoTime() - worldServerTickNanoTime);
 
         this.methodProfiler.exitEnter("connection");
         MinecraftTimings.connectionTimer.startTiming(); // Spigot
@@ -1650,7 +1692,7 @@
     }
 
     public String getServerModName() {
-        return "Tuinity"; // Tuinity //Paper - Paper > // Spigot - Spigot > // CraftBukkit - cb > vanilla!
+        return "Chiyogami"; // Tuinity //Paper - Paper > // Spigot - Spigot > // CraftBukkit - cb > vanilla!
     }
 
     public CrashReport b(CrashReport crashreport) {
@@ -2033,7 +2075,7 @@
             this.saveData.a(a(this.resourcePackRepository));
             datapackresources.i();
             new ServerResourcesReloadedEvent(cause).callEvent(); // Paper
-            if (Thread.currentThread() != this.serverThread) return; // Paper
+            if (AsyncCatcher.isAsync()) return; // Paper
             //this.getPlayerList().savePlayers(); // Paper - we don't need to do this
             this.getPlayerList().reload();
             this.customFunctionData.a(this.dataPackResources.a());
diff --strip-trailing-cr -urN Original/Tuinity-Server/src/main/java/net/minecraft/server/network/PlayerConnection.java Chiyogami/Chiyogami-Server/src/main/java/net/minecraft/server/network/PlayerConnection.java
--- Original/Tuinity-Server/src/main/java/net/minecraft/server/network/PlayerConnection.java	2021-09-26 18:20:19.544596600 +0900
+++ Chiyogami/Chiyogami-Server/src/main/java/net/minecraft/server/network/PlayerConnection.java	2022-01-02 18:53:11.662378600 +0900
@@ -220,6 +220,7 @@
 import org.bukkit.inventory.SmithingInventory;
 import org.bukkit.util.NumberConversions;
 import co.aikar.timings.MinecraftTimings; // Paper
+import world.chiyogami.bridge.WrappedParallelWorld;
 // CraftBukkit end
 
 public class PlayerConnection implements PacketListenerPlayIn {
@@ -267,6 +268,8 @@
     private static final long KEEPALIVE_LIMIT = Long.getLong("paper.playerconnection.keepalive", 30) * 1000; // Paper - provide property to set keepalive limit
 
     private String clientBrandName = null; // Paper - Brand name
+    
+    public WrappedParallelWorld wrappedParallelWorld;
 
     public PlayerConnection(MinecraftServer minecraftserver, NetworkManager networkmanager, EntityPlayer entityplayer) {
         this.minecraftServer = minecraftserver;
@@ -1441,7 +1444,15 @@
                                 AxisAlignedBB newBox = this.player.getBoundingBox();
                                 if (didCollide || !axisalignedbb.equals(newBox)) {
                                     // note: only call after setLocation, or else getBoundingBox is wrong
-                                    teleportBack = this.hasNewCollision(worldserver, this.player, axisalignedbb, newBox);
+                                    if(this.wrappedParallelWorld == null) {
+                                        teleportBack = this.hasNewCollision(worldserver, this.player, axisalignedbb, newBox);
+                                    }else {
+                                        if (!wrappedParallelWorld.isEditedBlock(player.getWorldServer().getWorld(), (int) player.locX(), (int) player.locY(), (int) player.locZ())) {
+                                            if (!wrappedParallelWorld.isBoundingBoxInEditedBlock(player.getWorldServer().getWorld(), player.getBoundingBox())) {
+                                                teleportBack = this.hasNewCollision(worldserver, this.player, axisalignedbb, newBox);
+                                            }
+                                        }
+                                    }
                                 } // else: no collision at all detected, why do we care?
                             }
                             if (!this.player.noclip && !this.player.isSleeping() && teleportBack) { // Tuinity end - optimise out extra getCubes
@@ -1533,7 +1544,7 @@
 
     // Tuinity start - optimise out extra getCubes
     private boolean hasNewCollision(final WorldServer world, final Entity entity, final AxisAlignedBB oldBox, final AxisAlignedBB newBox) {
-        final List<AxisAlignedBB> collisions = com.tuinity.tuinity.util.CachedLists.getTempCollisionList();
+        final List<AxisAlignedBB> collisions = com.tuinity.tuinity.util.CachedLists.getTempCollisionList(world.getWorld());
         try {
             world.getCollisions(entity, newBox, collisions, true);
 
@@ -1546,7 +1557,7 @@
 
             return false;
         } finally {
-            com.tuinity.tuinity.util.CachedLists.returnTempCollisionList(collisions);
+            com.tuinity.tuinity.util.CachedLists.returnTempCollisionList(collisions, world.getWorld());
         }
     }
     // Tuinity end - optimise out extra getCubes
diff --strip-trailing-cr -urN Original/Tuinity-Server/src/main/java/net/minecraft/server/players/PlayerList.java Chiyogami/Chiyogami-Server/src/main/java/net/minecraft/server/players/PlayerList.java
--- Original/Tuinity-Server/src/main/java/net/minecraft/server/players/PlayerList.java	2021-09-26 18:20:19.188799900 +0900
+++ Chiyogami/Chiyogami-Server/src/main/java/net/minecraft/server/players/PlayerList.java	2022-01-02 18:53:11.664377400 +0900
@@ -122,6 +122,7 @@
 import org.bukkit.event.player.PlayerLoginEvent;
 import org.bukkit.event.player.PlayerQuitEvent;
 import org.bukkit.event.player.PlayerRespawnEvent;
+import world.chiyogami.bridge.ParallelWorldBridge;
 // CraftBukkit end
 
 public abstract class PlayerList {
@@ -341,6 +342,7 @@
         IChatBaseComponent joinMessage = chatmessage; // Paper - Adventure
 
         playerconnection.a(entityplayer.locX(), entityplayer.locY(), entityplayer.locZ(), entityplayer.yaw, entityplayer.pitch);
+        playerconnection.wrappedParallelWorld = ParallelWorldBridge.getWrappedParallelWorld(entityplayer.getUniqueID()); // Chiyogami - ParallelPluginBridge
         this.players.add(entityplayer);
         this.playersByName.put(entityplayer.getName().toLowerCase(java.util.Locale.ROOT), entityplayer); // Spigot
         this.j.put(entityplayer.getUniqueID(), entityplayer);
diff --strip-trailing-cr -urN Original/Tuinity-Server/src/main/java/net/minecraft/util/thread/IAsyncTaskHandler.java Chiyogami/Chiyogami-Server/src/main/java/net/minecraft/util/thread/IAsyncTaskHandler.java
--- Original/Tuinity-Server/src/main/java/net/minecraft/util/thread/IAsyncTaskHandler.java	2021-09-26 18:20:14.050735200 +0900
+++ Chiyogami/Chiyogami-Server/src/main/java/net/minecraft/util/thread/IAsyncTaskHandler.java	2022-01-02 18:53:11.497473100 +0900
@@ -8,6 +8,7 @@
 import java.util.function.BooleanSupplier;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
+import org.spigotmc.AsyncCatcher;
 
 public abstract class IAsyncTaskHandler<R extends Runnable> implements Mailbox<R>, Executor {
 
@@ -25,7 +26,7 @@
     protected abstract boolean canExecute(R r0);
 
     public boolean isMainThread() {
-        return Thread.currentThread() == this.getThread();
+        return !AsyncCatcher.isAsync();
     }
 
     protected abstract Thread getThread();
diff --strip-trailing-cr -urN Original/Tuinity-Server/src/main/java/net/minecraft/world/entity/Entity.java Chiyogami/Chiyogami-Server/src/main/java/net/minecraft/world/entity/Entity.java
--- Original/Tuinity-Server/src/main/java/net/minecraft/world/entity/Entity.java	2021-09-26 18:20:18.786030800 +0900
+++ Chiyogami/Chiyogami-Server/src/main/java/net/minecraft/world/entity/Entity.java	2022-01-02 18:53:11.589420600 +0900
@@ -140,6 +140,7 @@
 import org.bukkit.event.entity.EntityPoseChangeEvent;
 import org.bukkit.event.player.PlayerTeleportEvent;
 import org.bukkit.plugin.PluginManager;
+import world.chiyogami.thread.WorldThreadPool;
 // CraftBukkit end
 
 public abstract class Entity implements INamableTileEntity, ICommandListener, net.minecraft.server.KeyedObject { // Paper
@@ -1101,7 +1102,7 @@
         WorldServer world = ((WorldServer)this.world);
         AxisAlignedBB currBoundingBox = this.getBoundingBox();
 
-        List<AxisAlignedBB> potentialCollisions = com.tuinity.tuinity.util.CachedLists.getTempCollisionList();
+        List<AxisAlignedBB> potentialCollisions = com.tuinity.tuinity.util.CachedLists.getTempCollisionList(world.getWorld());
         try {
             AxisAlignedBB collisionBox;
             double stepHeight = (double)this.getStepHeight();
@@ -1156,7 +1157,7 @@
                 return limitedMoveVector;
             }
         } finally {
-            com.tuinity.tuinity.util.CachedLists.returnTempCollisionList(potentialCollisions);
+            com.tuinity.tuinity.util.CachedLists.returnTempCollisionList(potentialCollisions, world.getWorld());
         }
     }
     // Tuinity end - optimise entity movement
@@ -2952,6 +2953,14 @@
             LOGGER.warn("Illegal Entity Teleport " + this + " to " + worldserver + ":" + location, new Throwable());
             return null;
         }
+        WorldThreadPool.catchWrongThread(world.getWorld(), "Entity teleportTo");
+        if(!this.world.isClientSide) { // Chiyogami - Thread wait request
+            if(worldserver != null) {
+                if (worldserver != this.world) {
+                    WorldThreadPool.requestWaitForTask((WorldServer) this.world, worldserver);
+                }
+            }
+        }
         // Paper end
         if (this.world instanceof WorldServer && !this.dead) {
             this.world.getMethodProfiler().enter("changeDimension");
diff --strip-trailing-cr -urN Original/Tuinity-Server/src/main/java/net/minecraft/world/entity/EntityLiving.java Chiyogami/Chiyogami-Server/src/main/java/net/minecraft/world/entity/EntityLiving.java
--- Original/Tuinity-Server/src/main/java/net/minecraft/world/entity/EntityLiving.java	2021-09-26 18:20:16.817985300 +0900
+++ Chiyogami/Chiyogami-Server/src/main/java/net/minecraft/world/entity/EntityLiving.java	2022-01-02 18:53:11.500470800 +0900
@@ -2974,7 +2974,7 @@
         }
         // Paper - end don't run getEntities if we're not going to use its result
         // Tuinity start - reduce memory allocation from collideNearby
-        List<Entity> list = com.tuinity.tuinity.util.CachedLists.getTempGetEntitiesList();
+        List<Entity> list = com.tuinity.tuinity.util.CachedLists.getTempGetEntitiesList(world.getWorld());
         this.world.getEntities(this, this.getBoundingBox(), IEntitySelector.pushable(this, world.paperConfig.fixClimbingBypassingCrammingRule), list); // Paper - fix climbing bypassing cramming rule
         try {
         // Tuinity end - reduce memory allocation from collideNearby
diff --strip-trailing-cr -urN Original/Tuinity-Server/src/main/java/net/minecraft/world/entity/EntityTypes.java Chiyogami/Chiyogami-Server/src/main/java/net/minecraft/world/entity/EntityTypes.java
--- Original/Tuinity-Server/src/main/java/net/minecraft/world/entity/EntityTypes.java	2021-09-26 18:20:14.065725900 +0900
+++ Chiyogami/Chiyogami-Server/src/main/java/net/minecraft/world/entity/EntityTypes.java	2022-01-02 18:53:11.502470600 +0900
@@ -1,10 +1,13 @@
 package net.minecraft.world.entity;
 
+import co.aikar.timings.Timing;
+import co.aikar.timings.Timings;
 import com.google.common.collect.ImmutableSet;
 import java.util.Optional;
 import java.util.Set; // Paper
 import java.util.Map; // Paper
 import java.util.UUID;
+import java.util.concurrent.ConcurrentHashMap;
 import java.util.function.Function;
 import java.util.stream.Stream;
 import javax.annotation.Nullable;
@@ -305,6 +308,28 @@
         this.passengerInactiveTickTimer = co.aikar.timings.MinecraftTimings.getEntityTimings(id, "passengerInactiveTick");
         // Paper end
     }
+    
+    // Chiyogami - timings
+    private final Map<String, Timing> tickMap = new ConcurrentHashMap<>();
+    private final Map<String, Timing> inactiveTickMap = new ConcurrentHashMap<>();
+    private final Map<String, Timing> passengerTickMap = new ConcurrentHashMap<>();
+    private final Map<String, Timing> passengerInactiveTickMap = new ConcurrentHashMap<>();
+    
+    public Timing getTickTimer(World world){
+        return tickMap.computeIfAbsent(world.getWorld().getName(), k -> Timings.ofSafeW(k + ": " + id + " - tick"));
+    }
+    
+    public Timing getInactiveTickTimer(World world){
+        return inactiveTickMap.computeIfAbsent(world.getWorld().getName(), k -> Timings.ofSafeW(k + ": " + id + " - inactiveTick"));
+    }
+    
+    public Timing getPassengerTickTimer(World world){
+        return passengerTickMap.computeIfAbsent(world.getWorld().getName(), k -> Timings.ofSafeW(k + ": " + id + " - passengerTick"));
+    }
+    
+    public Timing getPassengerInactiveTickTimer(World world){
+        return passengerInactiveTickMap.computeIfAbsent(world.getWorld().getName(), k -> Timings.ofSafeW(k + ": " + id + " - passengerInactiveTick"));
+    }
 
     @Nullable
     public Entity spawnCreature(WorldServer worldserver, @Nullable ItemStack itemstack, @Nullable EntityHuman entityhuman, BlockPosition blockposition, EnumMobSpawn enummobspawn, boolean flag, boolean flag1) {
diff --strip-trailing-cr -urN Original/Tuinity-Server/src/main/java/net/minecraft/world/level/chunk/Chunk.java Chiyogami/Chiyogami-Server/src/main/java/net/minecraft/world/level/chunk/Chunk.java
--- Original/Tuinity-Server/src/main/java/net/minecraft/world/level/chunk/Chunk.java	2021-09-26 18:20:19.207788800 +0900
+++ Chiyogami/Chiyogami-Server/src/main/java/net/minecraft/world/level/chunk/Chunk.java	2022-01-02 18:53:11.591419300 +0900
@@ -14,6 +14,7 @@
 import java.util.Map;
 import java.util.Map.Entry;
 import java.util.Set;
+import java.util.concurrent.CopyOnWriteArrayList;
 import java.util.function.Consumer;
 import java.util.function.Predicate;
 import java.util.function.Supplier;
diff --strip-trailing-cr -urN Original/Tuinity-Server/src/main/java/net/minecraft/world/level/World.java Chiyogami/Chiyogami-Server/src/main/java/net/minecraft/world/level/World.java
--- Original/Tuinity-Server/src/main/java/net/minecraft/world/level/World.java	2021-09-26 18:20:19.203791400 +0900
+++ Chiyogami/Chiyogami-Server/src/main/java/net/minecraft/world/level/World.java	2022-01-02 18:53:11.503470000 +0900
@@ -91,6 +91,7 @@
 import org.bukkit.craftbukkit.block.CraftBlockState;
 import org.bukkit.craftbukkit.block.data.CraftBlockData;
 import org.bukkit.event.block.BlockPhysicsEvent;
+import org.spigotmc.AsyncCatcher;
 // CraftBukkit end
 
 public abstract class World implements GeneratorAccess, AutoCloseable {
@@ -417,7 +418,7 @@
     public final Chunk getChunkAt(int i, int j) { // Paper - final to help inline
         // Tuinity start - make sure loaded chunks get the inlined variant of this function
         net.minecraft.server.level.ChunkProviderServer cps = ((WorldServer)this).chunkProvider;
-        if (cps.serverThread == Thread.currentThread()) {
+        if (!AsyncCatcher.isAsync()) {
             Chunk ifLoaded = cps.getChunkAtIfLoadedMainThread(i, j);
             if (ifLoaded != null) {
                 return ifLoaded;
@@ -1077,7 +1078,7 @@
         // CraftBukkit end
         if (isOutsideWorld(blockposition)) {
             return null;
-        } else if (!this.isClientSide && Thread.currentThread() != this.serverThread) {
+        } else if (!this.isClientSide && AsyncCatcher.isAsync()) {
             return null;
         } else {
             // CraftBukkit start
@@ -1366,7 +1367,7 @@
             int lowerZ = MCUtil.fastFloor((boundingBox.minZ - 2.0D)) >> 4;
             int upperZ = MCUtil.fastFloor((boundingBox.maxZ + 2.0D)) >> 4;
 
-            org.bukkit.craftbukkit.util.UnsafeList<Chunk> chunks = com.tuinity.tuinity.util.CachedLists.getTempGetChunksList();
+            org.bukkit.craftbukkit.util.UnsafeList<Chunk> chunks = com.tuinity.tuinity.util.CachedLists.getTempGetChunksList(this.getWorld());
             try {
                 T closest = null;
                 double closestDistance = Double.MAX_VALUE;
diff --strip-trailing-cr -urN Original/Tuinity-Server/src/main/java/org/bukkit/craftbukkit/CraftServer.java Chiyogami/Chiyogami-Server/src/main/java/org/bukkit/craftbukkit/CraftServer.java
--- Original/Tuinity-Server/src/main/java/org/bukkit/craftbukkit/CraftServer.java	2021-09-26 18:20:15.646140400 +0900
+++ Chiyogami/Chiyogami-Server/src/main/java/org/bukkit/craftbukkit/CraftServer.java	2022-01-02 18:53:11.506467400 +0900
@@ -225,12 +225,13 @@
 import org.yaml.snakeyaml.error.MarkedYAMLException;
 
 import net.md_5.bungee.api.chat.BaseComponent; // Spigot
+import world.chiyogami.chiyogamilib.WorldThreads;
 
 import javax.annotation.Nullable; // Paper
 import javax.annotation.Nonnull; // Paper
 
 public final class CraftServer implements Server {
-    private final String serverName = "Tuinity"; // Paper // Tuinity
+    private final String serverName = "Chiyogami"; // Paper // Tuinity
     private final String serverVersion;
     private final String bukkitVersion = Versioning.getBukkitVersion();
     private final Logger logger = Logger.getLogger("Minecraft");
@@ -1942,7 +1943,7 @@
     public boolean isPrimaryThread() {
         // Tuinity start
         final Thread currThread = Thread.currentThread();
-        return currThread == console.serverThread || currThread instanceof com.tuinity.tuinity.util.TickThread || currThread.equals(net.minecraft.server.MinecraftServer.getServer().shutdownThread); // Paper - Fix issues with detecting main thread properly, the only time Watchdog will be used is during a crash shutdown which is a "try our best" scenario
+        return currThread == console.serverThread || currThread instanceof com.tuinity.tuinity.util.TickThread || currThread.equals(net.minecraft.server.MinecraftServer.getServer().shutdownThread) || WorldThreads.worldThreadMap.containsValue(Thread.currentThread()); // Paper - Fix issues with detecting main thread properly, the only time Watchdog will be used is during a crash shutdown which is a "try our best" scenario
         // Tuinity End
     }
 
diff --strip-trailing-cr -urN Original/Tuinity-Server/src/main/java/org/bukkit/craftbukkit/CraftWorld.java Chiyogami/Chiyogami-Server/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
--- Original/Tuinity-Server/src/main/java/org/bukkit/craftbukkit/CraftWorld.java	2021-09-26 18:20:19.638542800 +0900
+++ Chiyogami/Chiyogami-Server/src/main/java/org/bukkit/craftbukkit/CraftWorld.java	2022-01-02 18:53:11.507467400 +0900
@@ -268,6 +268,7 @@
 import org.bukkit.util.Consumer;
 import org.bukkit.util.RayTraceResult;
 import org.bukkit.util.Vector;
+import org.spigotmc.AsyncCatcher;
 
 public class CraftWorld implements World {
     public static final int CUSTOM_DIMENSION_OFFSET = 10;
@@ -487,7 +488,7 @@
     @Override
     public Chunk[] getLoadedChunks() {
         // Paper start
-        if (Thread.currentThread() != world.getMinecraftWorld().serverThread) {
+        if (AsyncCatcher.isAsync()) {
             // Tuinity start - change updating chunks map
             Long2ObjectLinkedOpenHashMap<PlayerChunk> chunks;
             synchronized (world.getChunkProvider().playerChunkMap.updatingChunks) {
diff --strip-trailing-cr -urN Original/Tuinity-Server/src/main/java/org/bukkit/craftbukkit/entity/CraftEntity.java Chiyogami/Chiyogami-Server/src/main/java/org/bukkit/craftbukkit/entity/CraftEntity.java
--- Original/Tuinity-Server/src/main/java/org/bukkit/craftbukkit/entity/CraftEntity.java	2021-09-26 18:20:16.930756100 +0900
+++ Chiyogami/Chiyogami-Server/src/main/java/org/bukkit/craftbukkit/entity/CraftEntity.java	2022-01-02 18:53:11.592419800 +0900
@@ -176,6 +176,7 @@
 import org.bukkit.util.BoundingBox;
 import org.bukkit.util.NumberConversions;
 import org.bukkit.util.Vector;
+import world.chiyogami.thread.WorldThreadPool;
 
 public abstract class CraftEntity implements org.bukkit.entity.Entity {
     private static PermissibleBase perm;
@@ -552,6 +553,7 @@
     public boolean teleport(Location location, TeleportCause cause) {
         Preconditions.checkArgument(location != null, "location");
         location.checkFinite();
+        WorldThreadPool.catchWrongThread(this.getWorld(), "CraftEntity teleport");
 
         if (entity.isVehicle() || entity.dead) {
             return false;
diff --strip-trailing-cr -urN Original/Tuinity-Server/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java Chiyogami/Chiyogami-Server/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
--- Original/Tuinity-Server/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java	2021-09-26 18:20:19.217783400 +0900
+++ Chiyogami/Chiyogami-Server/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java	2022-01-02 18:53:11.593419400 +0900
@@ -137,6 +137,7 @@
 import org.bukkit.scoreboard.Scoreboard;
 
 import net.md_5.bungee.api.chat.BaseComponent; // Spigot
+import world.chiyogami.thread.WorldThreadPool;
 
 @DelegateDeserialization(CraftOfflinePlayer.class)
 public class CraftPlayer extends CraftHumanEntity implements Player {
@@ -874,6 +875,7 @@
         Preconditions.checkArgument(location != null, "location");
         Preconditions.checkArgument(location.getWorld() != null, "location.world");
         location.checkFinite();
+        WorldThreadPool.catchWrongThread(this.getWorld(), "CraftPlayer teleport");
 
         EntityPlayer entity = getHandle();
 
@@ -917,6 +919,11 @@
         // Grab the To and From World Handles.
         WorldServer fromWorld = ((CraftWorld) from.getWorld()).getHandle();
         WorldServer toWorld = ((CraftWorld) to.getWorld()).getHandle();
+        if(toWorld != null){ // Chiyogami - Thread wait request
+            if(toWorld != fromWorld && !toWorld.isClientSide){
+                WorldThreadPool.requestWaitForTask(fromWorld, toWorld);
+            }
+        }
 
         // Close any foreign inventory
         if (getHandle().activeContainer != getHandle().defaultContainer) {
diff --strip-trailing-cr -urN Original/Tuinity-Server/src/main/java/org/spigotmc/AsyncCatcher.java Chiyogami/Chiyogami-Server/src/main/java/org/spigotmc/AsyncCatcher.java
--- Original/Tuinity-Server/src/main/java/org/spigotmc/AsyncCatcher.java	2021-09-26 18:20:15.787774000 +0900
+++ Chiyogami/Chiyogami-Server/src/main/java/org/spigotmc/AsyncCatcher.java	2022-01-02 18:53:11.509466100 +0900
@@ -1,6 +1,7 @@
 package org.spigotmc;
 
 import net.minecraft.server.MinecraftServer;
+import world.chiyogami.chiyogamilib.WorldThreads;
 
 public class AsyncCatcher
 {
@@ -16,4 +17,8 @@
             throw new IllegalStateException( "Asynchronous " + reason + "!" );
         }
     }
+    
+    public static boolean isAsync(){
+        return !org.bukkit.Bukkit.isPrimaryThread();
+    }
 }
diff --strip-trailing-cr -urN Original/Tuinity-Server/src/main/java/world/chiyogami/bridge/ParallelWorldBridge.java Chiyogami/Chiyogami-Server/src/main/java/world/chiyogami/bridge/ParallelWorldBridge.java
--- Original/Tuinity-Server/src/main/java/world/chiyogami/bridge/ParallelWorldBridge.java	1970-01-01 09:00:00.000000000 +0900
+++ Chiyogami/Chiyogami-Server/src/main/java/world/chiyogami/bridge/ParallelWorldBridge.java	2022-01-02 18:53:11.665376800 +0900
@@ -0,0 +1,19 @@
+package world.chiyogami.bridge;
+
+import java.util.Map;
+import java.util.UUID;
+import java.util.concurrent.ConcurrentHashMap;
+
+public class ParallelWorldBridge {
+    
+    public static boolean parallelWorldBridge = false;
+    
+    private static final Map<UUID, WrappedParallelWorld> wrappedParallelWorldMap = new ConcurrentHashMap<>();
+    
+    public static WrappedParallelWorld getWrappedParallelWorld(UUID uuid){
+        if(!parallelWorldBridge) return null;
+        return wrappedParallelWorldMap.computeIfAbsent(uuid, WrappedParallelWorld::new);
+    }
+    
+}
+
diff --strip-trailing-cr -urN Original/Tuinity-Server/src/main/java/world/chiyogami/bridge/WrappedParallelWorld.java Chiyogami/Chiyogami-Server/src/main/java/world/chiyogami/bridge/WrappedParallelWorld.java
--- Original/Tuinity-Server/src/main/java/world/chiyogami/bridge/WrappedParallelWorld.java	1970-01-01 09:00:00.000000000 +0900
+++ Chiyogami/Chiyogami-Server/src/main/java/world/chiyogami/bridge/WrappedParallelWorld.java	2022-01-02 18:53:11.666376200 +0900
@@ -0,0 +1,60 @@
+package world.chiyogami.bridge;
+
+import net.minecraft.server.MCUtil;
+import net.minecraft.world.phys.AxisAlignedBB;
+import org.bukkit.World;
+
+import java.util.Map;
+import java.util.Set;
+import java.util.UUID;
+import java.util.concurrent.ConcurrentHashMap;
+
+public class WrappedParallelWorld {
+    
+    private final UUID uuid;
+    
+    private final Map<World, Map<Long, Set<Integer>>> editedBlockMap = new ConcurrentHashMap<>();
+    
+    public WrappedParallelWorld(UUID uuid){
+        this.uuid = uuid;
+    }
+    
+    public void addEditedBlock(World world, int x, int y, int z){
+        long chunkCoordinate = MCUtil.getCoordinateKey(x, z);
+        editedBlockMap.computeIfAbsent(world, k -> new ConcurrentHashMap<>())
+                .computeIfAbsent(chunkCoordinate, k -> ConcurrentHashMap.newKeySet()).add((x & 0xF) * y * (z & 0xF));
+    }
+    
+    public void removeEditedBlock(World world, int x, int y, int z){
+        Map<Long, Set<Integer>> editedMap = editedBlockMap.get(world);
+        if(editedMap == null) return;
+        
+        Set<Integer> blocks = editedMap.get(MCUtil.getCoordinateKey(x, z));
+        if(blocks == null) return;
+        
+        blocks.remove((x & 0xF) * y * (z & 0xF));
+    }
+    
+    public boolean isEditedBlock(World world, int x, int y, int z){
+        Map<Long, Set<Integer>> editedMap = editedBlockMap.get(world);
+        if(editedMap == null) return false;
+        
+        Set<Integer> blocks = editedMap.get(MCUtil.getCoordinateKey(x, z));
+        if(blocks == null) return false;
+        
+        return blocks.contains((x & 0xF) * y * (z & 0xF));
+    }
+    
+    public boolean isBoundingBoxInEditedBlock(World world, AxisAlignedBB bb){
+        if(isEditedBlock(world, (int)bb.maxX, (int)bb.minY, (int)bb.maxZ)) return true;
+        if(isEditedBlock(world, (int)bb.maxX, (int)bb.minY, (int)bb.minZ)) return true;
+        if(isEditedBlock(world, (int)bb.minX, (int)bb.minY, (int)bb.maxZ)) return true;
+        if(isEditedBlock(world, (int)bb.minX, (int)bb.minY, (int)bb.minZ)) return true;
+        if(isEditedBlock(world, (int)bb.maxX, (int)bb.maxY, (int)bb.maxZ)) return true;
+        if(isEditedBlock(world, (int)bb.maxX, (int)bb.maxY, (int)bb.minZ)) return true;
+        if(isEditedBlock(world, (int)bb.minX, (int)bb.maxY, (int)bb.maxZ)) return true;
+        if(isEditedBlock(world, (int)bb.minX, (int)bb.maxY, (int)bb.minZ)) return true;
+        return false;
+    }
+    
+}
diff --strip-trailing-cr -urN Original/Tuinity-Server/src/main/java/world/chiyogami/config/ChiyogamiConfig.java Chiyogami/Chiyogami-Server/src/main/java/world/chiyogami/config/ChiyogamiConfig.java
--- Original/Tuinity-Server/src/main/java/world/chiyogami/config/ChiyogamiConfig.java	1970-01-01 09:00:00.000000000 +0900
+++ Chiyogami/Chiyogami-Server/src/main/java/world/chiyogami/config/ChiyogamiConfig.java	2022-01-02 18:53:11.667375300 +0900
@@ -0,0 +1,117 @@
+package world.chiyogami.config;
+
+import org.bukkit.configuration.file.YamlConfiguration;
+import org.bukkit.plugin.SimplePluginManager;
+import world.chiyogami.bridge.ParallelWorldBridge;
+import world.chiyogami.chiyogamilib.monitor.WorkMode;
+import world.chiyogami.log.ChiyogamiLogger;
+import world.chiyogami.thread.WorldThreadPool;
+
+import java.io.File;
+import java.util.ArrayList;
+import java.util.List;
+
+public final class ChiyogamiConfig {
+    
+    private static final int VERSION = 2;
+    
+    private static final List<ConfigComponent<?>> configComponentList = new ArrayList<>();
+    
+    private static final ConfigComponent<Integer> CONFIG_VERSION = new ConfigComponent<>("config-version", VERSION, VERSION);
+    private static final ConfigComponent<Integer> MAX_WORLD_THREADS = new ConfigComponent<>("max-world-threads", 0, 0);
+    private static final ConfigComponent<Boolean> SHOW_CHIYOGAMI_LOG = new ConfigComponent<>("show-detail-log", true, 0);
+    private static final ConfigComponent<Boolean> SYNCHRONIZED_EVENT = new ConfigComponent<>("synchronized-event", true, 1);
+    private static final ConfigComponent<Boolean> PARALLEL_WORLD_BRIDGE = new ConfigComponent<>("parallel-world-bridge", false, 2);
+    
+    
+    private static void setDefaultValues(YamlConfiguration yml){
+        int configVer = 0;
+        if(yml.contains(CONFIG_VERSION.path)) configVer = yml.getInt(CONFIG_VERSION.path);
+        
+        for(ConfigComponent<?> configComponent : configComponentList){
+            String path = configComponent.path;
+            Object defaultValue = configComponent.defaultValue;
+            int componentVer = configComponent.version;
+            
+            if(configVer < componentVer || !yml.contains(path)){
+                yml.set(path, defaultValue);
+            }
+        }
+    }
+    
+    
+    private static void loadValues(YamlConfiguration yml){
+        for(ConfigComponent<?> configComponent : configComponentList){
+            String path = configComponent.path;
+            if(yml.contains(path)){
+                try {
+                    configComponent.setValue(yml.get(path));
+                }catch (Exception e){e.printStackTrace();}
+            }
+        }
+    }
+    
+    
+    private static class ConfigComponent<T>{
+        
+        private final String path;
+        
+        private final T defaultValue;
+        
+        private final int version;
+        
+        private T value = null;
+        
+        private ConfigComponent(String path, T defaultValue, int version){
+            this.path = path;
+            this.defaultValue = defaultValue;
+            this.version = version;
+            configComponentList.add(this);
+        }
+        
+        private void setValue(Object value) {this.value = (T)value;}
+        
+        private T getValue() {
+            if(value != null) return value;
+            return defaultValue;
+        }
+    }
+    
+    
+    
+    
+    public static void load(){
+        try {
+            
+            File file = new File("chiyogami.yml");
+            
+            YamlConfiguration yml;
+            if (file.exists()) {
+                yml = YamlConfiguration.loadConfiguration(file);
+            } else {
+                yml = new YamlConfiguration();
+            }
+            setDefaultValues(yml);
+            yml.save(file);
+            
+            loadValues(yml);
+            
+            WorkMode.MULTI_THREAD_TICK = MAX_WORLD_THREADS.getValue() != 1;
+            WorldThreadPool.setMaxPoolSize(MAX_WORLD_THREADS.getValue());
+            
+            ChiyogamiLogger.isShowLogs = SHOW_CHIYOGAMI_LOG.getValue();
+            
+            SimplePluginManager.synchronizedEvent = SYNCHRONIZED_EVENT.getValue();
+    
+            ParallelWorldBridge.parallelWorldBridge = PARALLEL_WORLD_BRIDGE.getValue();
+            
+        }catch (Exception e){e.printStackTrace();}
+    }
+    
+    public static int getMaxWorldThreads() {return MAX_WORLD_THREADS.getValue();}
+    
+    public static boolean isShowLogs() {return SHOW_CHIYOGAMI_LOG.getValue();}
+    
+    public static boolean isSynchronizedEvent(){return SYNCHRONIZED_EVENT.getValue();}
+}
+
diff --strip-trailing-cr -urN Original/Tuinity-Server/src/main/java/world/chiyogami/log/ChiyogamiLogger.java Chiyogami/Chiyogami-Server/src/main/java/world/chiyogami/log/ChiyogamiLogger.java
--- Original/Tuinity-Server/src/main/java/world/chiyogami/log/ChiyogamiLogger.java	1970-01-01 09:00:00.000000000 +0900
+++ Chiyogami/Chiyogami-Server/src/main/java/world/chiyogami/log/ChiyogamiLogger.java	2022-01-02 18:53:11.596416000 +0900
@@ -0,0 +1,15 @@
+package world.chiyogami.log;
+
+
+public class ChiyogamiLogger {
+    
+    public static boolean isShowLogs = true;
+    
+    public static void info(String string){
+        if(!isShowLogs) return;
+        string = "Chiyogami : INFO > " + string;
+        System.out.println(string);
+    }
+    
+}
+
diff --strip-trailing-cr -urN Original/Tuinity-Server/src/main/java/world/chiyogami/thread/WorldThreadPool.java Chiyogami/Chiyogami-Server/src/main/java/world/chiyogami/thread/WorldThreadPool.java
--- Original/Tuinity-Server/src/main/java/world/chiyogami/thread/WorldThreadPool.java	1970-01-01 09:00:00.000000000 +0900
+++ Chiyogami/Chiyogami-Server/src/main/java/world/chiyogami/thread/WorldThreadPool.java	2022-01-02 18:53:11.694360000 +0900
@@ -0,0 +1,160 @@
+package world.chiyogami.thread;
+
+
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.server.level.WorldServer;
+import org.bukkit.World;
+import org.bukkit.craftbukkit.CraftWorld;
+import world.chiyogami.chiyogamilib.WorldThreads;
+import world.chiyogami.log.ChiyogamiLogger;
+
+import java.util.*;
+import java.util.concurrent.*;
+import java.util.concurrent.locks.ReentrantLock;
+
+public class WorldThreadPool {
+    
+    public static final Map<WorldServer, Runnable> tickRunnableMap = new HashMap<>();
+    
+    public static final Set<WorldServer> worldServers = new HashSet<>();
+    
+    private static final Map<WorldServer, Future<?>> worldThreadFutureMap = new HashMap<>();
+    
+    
+    private static ExecutorService executorService = null;
+    
+    private static int maxPoolSize = 0;
+    
+    private static int previousPoolSize = 0;
+    
+    public static void setMaxPoolSize(int poolSize) {WorldThreadPool.maxPoolSize = poolSize;}
+    
+    
+    private static final Map<WorldServer, WorldServer> waitWorldServerMap = new HashMap<>();
+    
+    private static final Map<WorldServer, WorldServer> waitedWorldServerMap = new HashMap<>();
+    
+    private static final ReentrantLock WAIT_REQUEST_LOCK = new ReentrantLock(true);
+    
+    public static boolean isDoneWorldServerTask(WorldServer worldServer){
+        WAIT_REQUEST_LOCK.lock();
+        try {
+            return worldThreadFutureMap.get(worldServer).isDone();
+        } finally {
+            WAIT_REQUEST_LOCK.unlock();
+        }
+    }
+    
+    public static void catchWrongThread(World world, String reason){
+        
+        Thread currentThread = Thread.currentThread();
+        
+        if(currentThread == MinecraftServer.getServer().serverThread) return;
+        if(currentThread == WorldThreads.worldThreadMap.get(world)) return;
+        if(isDoneWorldServerTask(((CraftWorld) world).getHandle())) return;
+        
+        throw new IllegalStateException("Chiyogami > Called from a thread in another world -> " + reason
+                + System.lineSeparator() + "This operation is unacceptable because it can cause serious damage to this server."
+                + System.lineSeparator() + "It has been rejected by Chiyogami, it is not a bug.");
+    }
+    
+    public static void requestWaitForTask(WorldServer from, WorldServer to){
+        
+        if(maxPoolSize == 1) return;
+        if(Thread.currentThread() == MinecraftServer.getServer().serverThread) return;
+        if(!WorldThreads.isWorldThread()) return;
+        
+        ChiyogamiLogger.info("Lock request : " + from.worldDataServer.getName() + " -> " + to.worldDataServer.getName());
+        
+        Future<?> worldServerFuture = null;
+        
+        WAIT_REQUEST_LOCK.lock();
+        try{
+            if(!waitWorldServerMap.containsKey(from)){
+                
+                WorldServer lowest = getWaitWorldServer(to);
+                
+                if(lowest != from) {
+                    WorldServer highest = getWaitedWorldServer(to);
+                    waitWorldServerMap.put(from, highest);
+                    waitedWorldServerMap.put(highest, from);
+                    
+                    ChiyogamiLogger.info("Wait thread : " + from.worldDataServer.getName() + " -> " + highest.worldDataServer.getName());
+                    worldServerFuture = worldThreadFutureMap.get(highest);
+                }
+            }else{
+                WorldServer fromHighest = getWaitedWorldServer(from);
+                WorldServer highest = getWaitedWorldServer(to);
+                WorldServer lowest = getWaitWorldServer(to);
+                
+                if(highest != fromHighest) {
+                    WorldServer low = waitWorldServerMap.get(from);
+                    waitWorldServerMap.put(lowest, low);
+                    waitedWorldServerMap.put(low, lowest);
+                    
+                    waitWorldServerMap.put(from, highest);
+                    waitedWorldServerMap.put(highest, from);
+                    
+                    ChiyogamiLogger.info("Wait thread : " + from.worldDataServer.getName() + " -> " + highest.worldDataServer.getName());
+                    worldServerFuture = worldThreadFutureMap.get(highest);
+                }
+            }
+        } finally {
+            WAIT_REQUEST_LOCK.unlock();
+        }
+        
+        if(worldServerFuture != null){
+            try {
+                worldServerFuture.get();
+            } catch (Exception e){e.printStackTrace();}
+        }
+    }
+    
+    
+    public static WorldServer getWaitWorldServer(WorldServer from){
+        WorldServer worldServer = waitWorldServerMap.get(from);
+        if(worldServer == null) return from;
+        else return getWaitWorldServer(worldServer);
+    }
+    
+    public static WorldServer getWaitedWorldServer(WorldServer from){
+        WorldServer worldServer = waitedWorldServerMap.get(from);
+        if(worldServer == null) return from;
+        else return getWaitedWorldServer(worldServer);
+    }
+    
+    public static void shutdown(){
+        if(executorService != null) executorService.shutdown();
+    }
+    
+    public static void doTick(){
+        int pool = maxPoolSize > 0 ? maxPoolSize : worldServers.size();
+        
+        if(pool != previousPoolSize){
+            if(executorService != null) executorService.shutdown();
+            executorService = Executors.newFixedThreadPool(pool);
+            previousPoolSize = pool;
+        }
+        
+        WAIT_REQUEST_LOCK.lock();
+        try {
+            for (WorldServer worldServer : worldServers) {
+                Future<?> future = executorService.submit(tickRunnableMap.get(worldServer));
+                worldThreadFutureMap.put(worldServer, future);
+            }
+        } finally {
+            WAIT_REQUEST_LOCK.unlock();
+        }
+        
+        for(Future<?> future : worldThreadFutureMap.values()){
+            try {
+                future.get();
+            } catch (Exception e){e.printStackTrace();}
+        }
+        
+        waitWorldServerMap.clear();
+        worldThreadFutureMap.clear();
+        waitedWorldServerMap.clear();
+        worldServers.clear();
+    }
+}
