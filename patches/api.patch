diff --strip-trailing-cr -urN Original/Paper-API/src/main/java/co/aikar/timings/TimingHandler.java Paper-API/src/main/java/co/aikar/timings/TimingHandler.java
--- Original/Paper-API/src/main/java/co/aikar/timings/TimingHandler.java	2021-08-21 15:30:02.331808800 +0900
+++ Paper-API/src/main/java/co/aikar/timings/TimingHandler.java	2021-09-09 22:48:36.465749800 +0900
@@ -28,6 +28,9 @@
 
 import java.util.ArrayDeque;
 import java.util.Deque;
+import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ConcurrentLinkedDeque;
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.logging.Level;
 import java.util.logging.Logger;
@@ -39,13 +42,13 @@
 class TimingHandler implements Timing {
 
     private static AtomicInteger idPool = new AtomicInteger(1);
-    private static Deque<TimingHandler> TIMING_STACK = new ArrayDeque<>();
+    private static Deque<TimingHandler> TIMING_STACK = new ConcurrentLinkedDeque<>();
     final int id = idPool.getAndIncrement();
 
     final TimingIdentifier identifier;
     private final boolean verbose;
 
-    private final Int2ObjectOpenHashMap<TimingData> children = new LoadingIntMap<>(TimingData::new);
+    private final Map<Integer, TimingData> children = new ConcurrentHashMap<>();
 
     final TimingData record;
     private TimingHandler startParent;
@@ -124,6 +127,8 @@
 
     private void popTimingStack() {
         TimingHandler last;
+        TIMING_STACK.remove(this);
+        /*
         while ((last = TIMING_STACK.removeLast()) != this) {
             last.timingDepth = 0;
             if ("Minecraft".equalsIgnoreCase(last.identifier.group)) {
@@ -138,7 +143,7 @@
                 TIMING_STACK.addLast(last);
                 break;
             }
-        }
+        }*/
     }
 
     @Override
@@ -148,7 +153,7 @@
 
     void addDiff(long diff, @Nullable TimingHandler parent) {
         if (parent != null) {
-            parent.children.get(id).add(diff);
+            parent.children.computeIfAbsent(id, TimingData::new).add(diff);
         }
 
         record.add(diff);
@@ -159,7 +164,7 @@
         }
         if (groupHandler != null) {
             groupHandler.addDiff(diff, parent);
-            groupHandler.children.get(id).add(diff);
+            groupHandler.children.computeIfAbsent(id, TimingData::new).add(diff);
         }
     }
 
diff --strip-trailing-cr -urN Original/Paper-API/src/main/java/org/bukkit/plugin/SimplePluginManager.java Paper-API/src/main/java/org/bukkit/plugin/SimplePluginManager.java
--- Original/Paper-API/src/main/java/org/bukkit/plugin/SimplePluginManager.java	2021-08-21 15:30:09.702265700 +0900
+++ Paper-API/src/main/java/org/bukkit/plugin/SimplePluginManager.java	2021-09-01 05:09:25.711245800 +0900
@@ -20,6 +20,7 @@
 import java.util.Map;
 import java.util.Set;
 import java.util.WeakHashMap;
+import java.util.concurrent.locks.ReentrantLock;
 import java.util.logging.Level;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
@@ -60,6 +61,8 @@
     private final Map<String, Map<Permissible, Boolean>> permSubs = new HashMap<String, Map<Permissible, Boolean>>();
     private final Map<Boolean, Map<Permissible, Boolean>> defSubs = new HashMap<Boolean, Map<Permissible, Boolean>>();
     private boolean useTimings = false;
+    
+    private final ReentrantLock EVENT_LOCK = new ReentrantLock(true); // Chiyogami
 
     public SimplePluginManager(@NotNull Server instance, @NotNull SimpleCommandMap commandMap) {
         server = instance;
@@ -588,45 +591,50 @@
      */
     @Override
     public void callEvent(@NotNull Event event) {
-        // Paper - replace callEvent by merging to below method
-        if (event.isAsynchronous() && server.isPrimaryThread()) {
-            throw new IllegalStateException(event.getEventName() + " may only be triggered asynchronously.");
-        } else if (!event.isAsynchronous() && !server.isPrimaryThread() && !server.isStopping() ) {
-            throw new IllegalStateException(event.getEventName() + " may only be triggered synchronously.");
-        }
-
-        HandlerList handlers = event.getHandlers();
-        RegisteredListener[] listeners = handlers.getRegisteredListeners();
-
-        for (RegisteredListener registration : listeners) {
-            if (!registration.getPlugin().isEnabled()) {
-                continue;
-            }
-
-            try {
-                registration.callEvent(event);
-            } catch (AuthorNagException ex) {
-                Plugin plugin = registration.getPlugin();
-
-                if (plugin.isNaggable()) {
-                    plugin.setNaggable(false);
-
-                    server.getLogger().log(Level.SEVERE, String.format(
+        try {
+            EVENT_LOCK.lock();
+            // Paper - replace callEvent by merging to below method
+            if (event.isAsynchronous() && server.isPrimaryThread()) {
+                throw new IllegalStateException(event.getEventName() + " may only be triggered asynchronously.");
+            } else if (!event.isAsynchronous() && !server.isPrimaryThread() && !server.isStopping()) {
+                throw new IllegalStateException(event.getEventName() + " may only be triggered synchronously.");
+            }
+    
+            HandlerList handlers = event.getHandlers();
+            RegisteredListener[] listeners = handlers.getRegisteredListeners();
+    
+            for (RegisteredListener registration : listeners) {
+                if (!registration.getPlugin().isEnabled()) {
+                    continue;
+                }
+        
+                try {
+                    registration.callEvent(event);
+                } catch (AuthorNagException ex) {
+                    Plugin plugin = registration.getPlugin();
+            
+                    if (plugin.isNaggable()) {
+                        plugin.setNaggable(false);
+                
+                        server.getLogger().log(Level.SEVERE, String.format(
                             "Nag author(s): '%s' of '%s' about the following: %s",
                             plugin.getDescription().getAuthors(),
                             plugin.getDescription().getFullName(),
                             ex.getMessage()
-                            ));
-                }
-            } catch (Throwable ex) {
-                // Paper start - error reporting
-                String msg = "Could not pass event " + event.getEventName() + " to " + registration.getPlugin().getDescription().getFullName();
-                server.getLogger().log(Level.SEVERE, msg, ex);
-                if (!(event instanceof ServerExceptionEvent)) { // We don't want to cause an endless event loop
-                    callEvent(new ServerExceptionEvent(new ServerEventException(msg, ex, registration.getPlugin(), registration.getListener(), event)));
+                        ));
+                    }
+                } catch (Throwable ex) {
+                    // Paper start - error reporting
+                    String msg = "Could not pass event " + event.getEventName() + " to " + registration.getPlugin().getDescription().getFullName();
+                    server.getLogger().log(Level.SEVERE, msg, ex);
+                    if (!(event instanceof ServerExceptionEvent)) { // We don't want to cause an endless event loop
+                        callEvent(new ServerExceptionEvent(new ServerEventException(msg, ex, registration.getPlugin(), registration.getListener(), event)));
+                    }
+                    // Paper end
                 }
-                // Paper end
             }
+        } finally {
+            EVENT_LOCK.unlock();
         }
     }
 
